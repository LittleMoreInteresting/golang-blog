[
{
	"uri": "http://blog.911015.com/beginner/01.html",
	"title": "01-Golang安装与体验",
	"tags": null,
	"description": "",
	"content": " 下载并安装按照一下步骤快速进行。 有关安装的其他内容，您可能对以下内容感兴趣：\nGo多版本安装管理 \u0026ndash;如何安装多版本并卸载。 Go 源码安装 \u0026ndash; 如何下载源码并在自己的机器上编译安装Go。 下载地址在这里 go.dev/dl/ 各系统版本都有，下载一个与自己系统匹配的版本，可以选最新版本进行安装学习。\n安装Go 选择下面对应的计算机操作系统，然后按照其安装说明进行操作。\nLinux 删除/usr/local/Go文件夹（如果存在），删除以前的Go安装，然后将刚下载的存档提取到/usr/local中，在/usr/local/go: Copy\rrm -rf /usr/local/go \u0026amp;\u0026amp; tar -C /usr/local -xzf go1.20.4.linux-amd64.tar.gz （您可能需要以root用户身份或通过sudo运行该命令）。不要将归档文件解压缩到现有的/usr/local/go目录中。这会导致Go安装失败\n将/usr/local/go/bin添加到PATH环境变量中 您可以通过将以内容添加到$HOME/.profile或/etc/profile（全局安装）来完成此操作：\nCopy\rexport PATH=$PATH:/usr/local/go/bin **注意**：对配置文件所做的更改可能要等到下次登录计算机时才能应用。要立即应用更改，只需直接运行shell命令，或者使用`source $HOME/.profile` 等命令从概要文件中执行这些命令。\r3. 通过打开命令提示符并输入以下命令来验证是否已安装Go\rCopy\r$ go version 4. 确认该命令打印已安装的Go版本。\rMac 打开下载的软件包文件，并按照提示安装Go 该软件包将Go安装到/usr/local/go。该包应该将/usr/local/go/bin目录放在PATH环境变量中。可能需要重新启动任何打开的终端会话才能使更改生效。\n通过打开命令提示符并键入以下命令来验证是否已安装Go go version\n确认该命令打印已安装的Go版本。 Window 1、打开您下载的MSI文件，并按照提示安装Go。 默认情况下，安装程序将安装Go到 Program Files或Program Files（x86）。您可以根据需要更改位置。安装后，您需要关闭并重新打开任何打开的命令提示符，以便在命令提示符下反映安装程序对环境所做的更改。\n2、验证您是否已安装Go；\n在Windows中，单击“开始”菜单。 在菜单的搜索框中，键入cmd，然后按Enter键。 在出现的“命令提示符”窗口中，键入以下命令： go version 确认该命令打印已安装的Go版本。 Reference Installing Go "
},
{
	"uri": "http://blog.911015.com/",
	"title": "Go语言入门",
	"tags": null,
	"description": "Go语言入门",
	"content": "\r《Go语言入门》 整理了从零开始学习Go语言的相关基础知识；\r跟着用户手册学Golang "
},
{
	"uri": "http://blog.911015.com/tour/01.html",
	"title": "基础篇（一）：包、变量和方法",
	"tags": null,
	"description": "基础篇（一）：包、变量和方法；学习任何Go程序的基本组成部分。",
	"content": "包（ package） 每个Go项目都是由程序包组成的。 程序在main包中运行。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; ) func main() { fmt.Println(\u0026#34;My favorite number is\u0026#34;, rand.Intn(10)) } 此程序使用导入的“fmt”和“math/rand”包。 按照惯例，包名称为导入路径的最后一个元素。例如，“math/rand”包含以rand为包名的文件。\nimport 此代码将导入分组到一个带括号的的import语句中。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func main() { fmt.Printf(\u0026#34;Now you have %g problems.\\n\u0026#34;, math.Sqrt(7)) } 您还可以编写多个import语句，如：\nimport \u0026#34;fmt\u0026#34; import \u0026#34;math\u0026#34; 但是，建议使用带括号的import语句。\n导出名称 在 Go 中，如果名称以大写字母开头，则会导出该名称。例如，Pizza，Pi 是是从math包中导出的名称。 pizza并且pi不要以大写字母开头，因此它们不会被导出。 导入包时，您只能引用其导出的名称。任何“未导出”的名称都无法从包外部访问。 运行代码。请注意错误消息。 要修复错误，请重命名math.pi为math.Pi并重试。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func main() { fmt.Println(math.pi) } 函数/方法 (Functions) Functions 函数可以接受零个或多个参数。 在本例中，add接收两个int类型的参数。\n请注意，该类型位于变量名之后。\npackage main import \u0026#34;fmt\u0026#34; func add(x int, y int) int { return x + y } func main() { fmt.Println(add(42, 13)) } 当两个或多个连续的命名函数参数共享一个类型时，可以从除最后一个之外的所有参数中省略该类型。在这个例子中，可以把 x int, y int 简写为 x, y int\n多返回值 Multiple results 函数可以返回任意数量的结果。函数可以返回任意数量的结果。\npackage main import \u0026#34;fmt\u0026#34; func swap(x, y string) (string, string) { return y, x } func main() { a, b := swap(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;) fmt.Println(a, b) } 具名返回值 Named return values Go的返回值可以命名。这种写法将视为在函数顶部定义的变量。这些变量用于记录返回值。不带参数的return语句返回命名的返回值。这种方式适合比较短的函数；如果是函数体比较长的函数这种方式可读性会比较差\npackage main import \u0026#34;fmt\u0026#34; func split(sum int) (x, y int) { x = sum * 4 / 9 y = sum - x return } func main() { fmt.Println(split(17)) } 变量（Variables） var语句声明了一个变量列表；在函数参数列表中，类型是最后一个。 var语句可以是包级别的，也可以是函数级别的。例子中分别展示了这两种情况。\npackage main import \u0026#34;fmt\u0026#34; var c, python, java bool func main() { var i int fmt.Println(i, c, python, java) } 定义带初始值的变量 var 声明每个变量包含初始值的变量。 如果存在初始值，则可以省略类型；该变量将采用初始值设定项的类型。\npackage main import \u0026#34;fmt\u0026#34; var i, j int = 1, 2 func main() { var c, python, java = true, false, \u0026#34;no!\u0026#34; fmt.Println(i, j, c, python, java) } 短变量声明 在函数内部，可以使用 := 短赋值语句来代替隐式类型的var声明。在函数之外，每条语句都以关键字（var、func等）开头，因此:=构造不可用。\npackage main import \u0026#34;fmt\u0026#34; func main() { var i, j int = 1, 2 k := 3 c, python, java := true, false, \u0026#34;no!\u0026#34; fmt.Println(i, j, k, c, python, java) } 基本类型 Go语言的基本类型有\nbool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // alias for uint8 rune // alias for int32 // represents a Unicode code point float32 float64 complex64 complex128 该示例显示了几种类型的变量，还显示了变量声明可以被“分解”到块中，就像import语句一样\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/cmplx\u0026#34; ) var ( ToBe bool = false MaxInt uint64 = 1\u0026lt;\u0026lt;64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i) ) func main() { fmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, ToBe, ToBe) fmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, MaxInt, MaxInt) fmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, z, z) } int、uint和uintptr类型在32位系统上通常为32位宽，在64位系统上为64位宽。当您需要一个整数值时，您应该使用int，除非您有特定的理由使用大小或无符号整数类型。\n零值 在没有显式初始值的情况下声明的变量将被赋予零值。 各类型零值:\n数字类型 0, 布尔类型 false string类型 \u0026quot;\u0026quot; (空字符串) . package main import \u0026#34;fmt\u0026#34; func main() { var i int var f float64 var b bool var s string fmt.Printf(\u0026#34;%v %v %v %q\\n\u0026#34;, i, f, b, s) } 类型转换 表达式T(v) 将值v转换为类型T。 一些数字转换\nvar i int = 42 var f float64 = float64(i) var u uint = uint(f) 或者，更简单地说：\ni := 42 f := float64(i) u := uint(f) 与C不同，Go语言不同类型的项之间的赋值需要显式转换。尝试删除示例中的float64或uint转换，看看会发生什么。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func main() { var x, y int = 3, 4 var f float64 = math.Sqrt(float64(x*x + y*y)) var z uint = uint(f) fmt.Println(x, y, z) } 类型推断 当声明变量而不指定显式类型时（通过使用 := 语法或var =表达式语法），变量的类型是从右侧的值推断出来的。 当声明的右侧被输入时，新变量是相同类型的\nvar i int j := i // j 是 int 类型 但是，当右侧包含非类型化的数字常量时，新变量可能是int、float64或complex128，具体取决于常量的精度：\ni := 42 // int f := 3.142 // float64 g := 0.867 + 0.5i // complex128 package main import \u0026#34;fmt\u0026#34; func main() { v := 42 // change me! fmt.Printf(\u0026#34;v is of type %T\\n\u0026#34;, v) } 尝试更改示例代码中v的初始值，并观察其类型是如何受到影响的。\n常量 常量是像变量一样声明的，但使用const关键字。常量可以是字符、字符串、布尔值或数值。不能使用 := 语法声明常量。\npackage main import \u0026#34;fmt\u0026#34; const Pi = 3.14 func main() { const World = \u0026#34;世界\u0026#34; fmt.Println(\u0026#34;Hello\u0026#34;, World) fmt.Println(\u0026#34;Happy\u0026#34;, Pi, \u0026#34;Day\u0026#34;) const Truth = true fmt.Println(\u0026#34;Go rules?\u0026#34;, Truth) } 数值常量 数值常量是高精度的值。非类型化的常量采用其上下文所需的类型。\npackage main import \u0026#34;fmt\u0026#34; const ( // 通过向左移动1位100位来创建一个巨大的数字。 // 换句话说，二进制数是1，后面跟着100个零。 Big = 1 \u0026lt;\u0026lt; 100 // 再次向右移动99位，所以我们最终得到1\u0026lt;\u0026lt;1或2。 Small = Big \u0026gt;\u0026gt; 99 ) func needInt(x int) int { return x*10 + 1 } func needFloat(x float64) float64 { return x * 0.1 } func main() { fmt.Println(needInt(Small)) fmt.Println(needFloat(Small)) fmt.Println(needFloat(Big)) } 也可以尝试打印needInt（Big）。（int最多可以存储64位整数，有时可以存储更少的整数。）\n"
},
{
	"uri": "http://blog.911015.com/beginner/",
	"title": "跟着用户手册学Golang",
	"tags": null,
	"description": "Go编程语言是一个开源项目，旨在提高程序员的工作效率。",
	"content": "\r文档简介\rGo编程语言是一个开源项目，旨在提高程序员的工作效率。\nGo表现力强、简洁、干净、高效。它的并发机制使编写程序变得容易，从而最大限度地利用多核和网络机器，而它的新型系统则实现了灵活和模块化的程序构建。Go可以快速编译为机器代码，但同时具有垃圾收集的便利性和运行时反射的功能。这是一种快速、静态类型化、编译的语言，感觉就像是一种动态类型化、解释的语言。\nGolang官方文档地址为：go.dev/doc ；文档开始简单介绍了Golang 的语言特性：简洁、高效、天然并发、快速编译、垃圾回收、反射，新类型系统等等。接下来分按入门，进阶、高级划分了大模块让初学者能够寻寻渐进的深入学习理解Golang；接下来我们将根据 Getting Started部分一步一步入门Golang。\n本章节内容为官方文档内容翻译；部分内容和代码为个人补充；Copyright\n如果内容有误请 与我联系\n教程列表 说明 安装Golang 有关下载和安装Go的说明。 新手入门 一个简短的Hello，World入门教程。了解一些Go代码、工具、包和模块。 创建Go项目 介绍函数、错误处理、数组、映射、单元测试和编译的简短主题教程。 入门多模块工作区 介绍在Go中创建和使用多模块工作区的基本知识。多模块工作空间对于跨多个模块进行更改非常有用。（Go 1.18增加了工作空间模式，本地做多版本管理很方便） 用Go和Gin开发RESTful API 介绍使用Go和Gin web Framework编写RESTful web服务API的基础知识。 使用Go泛型 使用泛型，您可以声明和使用函数或类型，这些函数或类型是为与调用代码提供的任何一组类型一起工作而编写的。(Go 1.18 Go语言增加泛型) 使用fuzzing模糊测试 fuzzing可以为您的测试生成输入，这些输入可以捕捉到您可能错过的边缘案例和安全问题。（模糊测试是一种通过向目标系统提供非预期的输入并监视异常结果来发现软件漏洞的方法。） 编写Web应用程序 构建一个简单的web应用程序。 如何编写Go代码 本文档解释了如何在模块中开发一组简单的Go包，并展示了如何使用Go命令来构建和测试包。 Go之旅 Go语言的互动介绍分为三个部分。第一部分介绍了基本语法和数据结构；第二部分讨论了方法和接口；第三部分介绍了Go的并发原语。每一节都以一些练习作为结束，这样你就可以练习你所学到的东西。您可以在线参观，也可以使用以下软件在本地安装： go install golang.org/x/website/tour@latest这将把tour二进制文件放在GOPATH的bin目录中。 学习计划 阅读官方文档； 通过代码练习语法 通过项目熟悉代码 01-Golang安装与体验 02-新手入门 03-创建Go项目 04-入门多模块工作区 Go 编程语言之旅 "
},
{
	"uri": "http://blog.911015.com/beginner/02.html",
	"title": "02-新手入门",
	"tags": null,
	"description": "",
	"content": " 在本教程中，您将获得Go编程的简要介绍\n安装Go . 写一些简单的 \u0026ldquo;Hello, world\u0026rdquo; . 使用go命令运行代码. 使用Go程序包发现工具查找可以在自己的代码中使用的程序包. 调用外部模块的功能. 前期准备 一些编程经验。 这里的代码非常简单，但了解一些函数相关的知识会有所帮助。. 用于编辑代码的工具。** ** 任何文本编辑器都可以。大多数文本编辑器都很好地支持Go。最受欢迎的是VSCode（免费）、GoLand（付费）和Vim（免费）。 一个命令终端. Go在Linux和Mac上以及Windows中的PowerShell或cmd上使用任何终端都能很好地工作。 Hello World 按一下步骤写一段 “Hello World”代码\n1、打开一个命令提示符并cd到您的主目录。 Linux/Mac 系统执行 : cd Window系统执行： cd %HOMEPATH%\n2、为您的第一个Go源代码创建一个hello目录 可以使用一下命令：\nmkdir hello cd hello 3、为代码启用依赖管理\n当您的代码导入其他项目中的包（package）时，您可以通过自己的代码来管理这些模块的依赖关系。该模块由go.mod文件定义，通过该文件追踪提供包的这些模块。该go.mod文件与您的代码一起保存，包括在您的源代码存储库中。\r要通过创建go.mod文件为代码启用依赖管理，请运行go mod init+模块的名称 命令。该名称是模块的模块路径。\r在实际开发中，模块路径通常是保存源代码的存储仓库位置。例如，模块路径可能是github.com/mymodule。如果您计划发布您的模块供他人使用，则模块路径必须是Go工具可以下载您的模块的位置。\r对于本教程，只需使用example/hello。\ngo mod init example/hello go: creating new go.mod: module example/hello 4、在编辑器中，创建一个文件hello.go，在其中编写代码。 5、将以下代码粘贴到hello.go文件中并保存该文件。\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;Hello World（^-^）\u0026#34;) } 接下来看一下这段代码的内容：\n声明一个主包(main)（包是对函数进行分组的一种方式，它由同一目录中的所有文件组成）。 导入流行的fmt包，其中包含格式化文本的功能，包括打印到控制台。这个包是Go的标准库之一。 实现一个主要功能，将消息打印到控制台。当您运行主程序包时，默认情况下会执行一个主函数（main）。 6、运行代码\ngo run . # Hello World（^-^） 7、go run命令是众多go命令之一。使用 go help 命令可以查看其他命令帮助文档：\n调用外部包 当你需要你的代码来做一些可能已经被其他人实现的事情时，你可以导入一个实现了这些功能的包直接使用。\n1、使用外部模块的功能，使打印的消息更加有趣\r访问pkg.go.dev并搜索“quote”包 在搜索结果中找到并单击rsc.io/quote包（如果您看到rsc.io/quote/v3，请暂时忽略它）。 在“文档”部分的“索引”下，记下可以从代码中调用的函数列表。您将使用Go功能。 请注意，在本页顶部，\u0026ldquo;quote\u0026quot;包含在rsc.io/quote模块中。 您可以使用pkg.go.dev网站查找已发布的模块，这些模块的包中有您可以在自己的代码中使用的功能。包发布在模块中，比如rsc.io/quote，其他人可以在其中使用它们。随着时间的推移，新版本会对模块进行改进，您可以升级代码以使用改进的版本。\r2、在Go代码中，导入rsc.io/quote包并调用其函数 quote.Go()。之后，您的代码应该包括以下内容：\rpackage main import \u0026#34;fmt\u0026#34; import \u0026#34;rsc.io/quote\u0026#34; func main() { fmt.Println(quote.Go()) } 3、添加模块依赖和校验 Go程序把“quote”包添加到依赖中（go.mod），以及用于验证模块的go.sum文件中。\n$ go mod tidy go: finding module for package rsc.io/quote go: found rsc.io/quote in rsc.io/quote v1.5.2 4、运行您的代码以查看您正在调用的函数生成的消息。\n$ go run . # Don\u0026#39;t communicate by sharing memory, share memory by communicating. 请注意，您的代码调用Go函数，打印出一条关于通信的格言。\n当您运行go mod tidy，它找到并下载了包含您导入的包的rsc.io/quote模块。默认情况下，它下载了最新版本v1.5.2。\n"
},
{
	"uri": "http://blog.911015.com/tour/02.html",
	"title": "基础篇（二）：Go语言流程控制",
	"tags": null,
	"description": "基础篇（二）：Go语言流程控制",
	"content": "For Go只有一个循环结构，即for循环。\npackage main import \u0026#34;fmt\u0026#34; func main() { sum := 0 for i := 0; i \u0026lt; 10; i++ { sum += i } fmt.Println(sum) } 基本的for循环有三个用分号分隔的部分：\n初始化语句：在第一次迭代之前执行 条件表达式：在每次迭代之前求值 后置语句：在每次循环结束时执行 初始化语句通常是一个简短的变量声明，在那里声明的变量只在for语句的范围内可见。 一旦条件表达式的计算结果为false，循环将停止迭代。 注意：与C、Java或JavaScript等其他语言不同，for语句的三个组件周围没有括号，并且必须要有大括号{}。 初始化语句和后置语句是可选的。如下：\npackage main import \u0026#34;fmt\u0026#34; func main() { sum := 1 for ; sum \u0026lt; 1000; { sum += sum } fmt.Println(sum) } 更进一步，还可以去掉分号：类似C语言中的的while那样，在Go中是用for实现的。如下：\npackage main import \u0026#34;fmt\u0026#34; func main() { sum := 1 for sum \u0026lt; 1000 { sum += sum } fmt.Println(sum) } 如果省略循环条件，它将永远循环，因此一个死循环就可以这样写：\npackage main func main() { for { // Do something forever } } If Go的if语句类似于它的for循环；表达式不需要用括号（）括起来，但必须要有大括号｛｝。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func sqrt(x float64) string { if x \u0026lt; 0 { return sqrt(-x) + \u0026#34;i\u0026#34; } return fmt.Sprint(math.Sqrt(x)) } func main() { fmt.Println(sqrt(2), sqrt(-4)) } 与for一样，if语句可以在条件之前以执行一个短语句。语句声明的变量只能在if结束之前使用。如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v \u0026lt; lim { return v } return lim } func main() { fmt.Println( pow(3, 2, 10), pow(3, 3, 20), ) } （请尝试在最后一个return(line 12)语句中使用v。）\nIf and else 在if短语句中声明的变量在任何else块中都可用。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v \u0026lt; lim { return v } else { fmt.Printf(\u0026#34;%g \u0026gt;= %g\\n\u0026#34;, v, lim) } // can\u0026#39;t use v here, though return lim } func main() { fmt.Println( pow(3, 2, 10), pow(3, 3, 20), ) } （在main中对fmt.Println的调用之前，会先对两个pow调用求值。）\n练习：循环和函数 为了练习函数和方法，让我们实现一个平方根函数： 给定一个数字x，找到z²最接近x的数字z。 计算机通常使用循环计算x的平方根。从一些可能的z开始，我们可以根据z²与x的接近程度来调整z，从而产生更好的结果：\nz -= (z*z - x) / (2*z) 重复这种调整会使结果变得越来越好，直到我们得出尽可能接近实际平方根的答案 在函数Sqrt中实现这一功能。z的一个不错的起始值是1，无论输入是什么。首先，重复计算10次，并在计算过程中打印每个z。看看你离x（1，2，3，…）的各种值的答案有多近，以及猜测改进的速度有多快。 提示：要声明和初始化浮点值，请定义为浮点类型或使用类型转换转换：\nz := 1.0 z := float64(1) 接下来，一旦值停止更改（或仅更改很小的量），就将循环条件更改为停止。看看这是多于还是少于10次迭代。尝试对z进行其他初始猜测，如x或x/2。您的函数的结果与标准库中的math.Sqrt有多接近？ （注意：如果你对算法的细节感兴趣，上面的z²−x是z²离它需要的位置（x）有多远，除以2z是z²的导数，通过z²的变化速度来衡量我们调整z的程度。这种通用方法被称为牛顿方法。它适用于许多函数，但特别适用于平方根。） 以下代码仅供参考\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func Sqrt(x float64) float64 { var z = 1.0 var old float64 for math.Abs(old-z) \u0026gt;= 0.000001 { old = z z -= (z*z - x) / (2 * z) } return z } func main() { fmt.Println(Sqrt(2), math.Sqrt(2)) fmt.Println(Sqrt(10), math.Sqrt(10)) } Switch switch语句是编写if-else的一种更简短的方法。它执行第一个满足条件的分支。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; ) func main() { fmt.Print(\u0026#34;Go runs on \u0026#34;) switch os := runtime.GOOS; os { case \u0026#34;darwin\u0026#34;: fmt.Println(\u0026#34;OS X.\u0026#34;) case \u0026#34;linux\u0026#34;: fmt.Println(\u0026#34;Linux.\u0026#34;) default: // freebsd, openbsd, // plan9, windows... fmt.Printf(\u0026#34;%s.\\n\u0026#34;, os) } } Go的switch结构与C、C++、Java、JavaScript和PHP中的开关类似，只是Go只运行第一个符合条件的分支，而不是随后的所有案例。实际上，在Go中在每个分支最后都加了break语句。另一个重要的区别是Go的switch的分支条件不一定是常数，所涉及的值也不需要是整数。\n执行顺序 switch 分支是从上到下进行判断的，当某一个分支成功时停止向下执行。例如：\nswitch i { case 0: case f(): } // 如果i = 0 f函数是不执行的 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { fmt.Println(\u0026#34;When\u0026#39;s Saturday?\u0026#34;) today := time.Now().Weekday() switch time.Saturday { case today + 0: fmt.Println(\u0026#34;Today.\u0026#34;) case today + 1: fmt.Println(\u0026#34;Tomorrow.\u0026#34;) case today + 2: fmt.Println(\u0026#34;In two days.\u0026#34;) default: fmt.Println(\u0026#34;Too far away.\u0026#34;) } } 无条件Switch 无条件Switch等同于 Switch true。这种构造可以用来编写长if-then-else链。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { t := time.Now() switch { case t.Hour() \u0026lt; 12: fmt.Println(\u0026#34;Good morning!\u0026#34;) case t.Hour() \u0026lt; 17: fmt.Println(\u0026#34;Good afternoon.\u0026#34;) default: fmt.Println(\u0026#34;Good evening.\u0026#34;) } } Defer defer语句将一个函数的执行延迟到锁住函数返回时。延迟调用的参数会立即求值，但在周围的函数返回之前不会执行函数调用。\npackage main import \u0026#34;fmt\u0026#34; func main() { defer fmt.Println(\u0026#34;world\u0026#34;) fmt.Println(\u0026#34;hello\u0026#34;) } defer的函数调用被推送到堆栈中。当函数返回时，其defer调用将按后进先出的顺序执行。\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;counting\u0026#34;) for i := 0; i \u0026lt; 10; i++ { defer fmt.Println(i) } fmt.Println(\u0026#34;done\u0026#34;) } "
},
{
	"uri": "http://blog.911015.com/beginner/03.html",
	"title": "03-创建Go项目",
	"tags": null,
	"description": "",
	"content": "这是教程的第一部分，介绍了Go语言的一些基本功能。如果你刚开始使用Go语言，一定要看一下教程：Go入门，它介绍了Go命令、Go模块和非常简单的Go代码。 在本教程中，您将创建两个模块。第一种是用来被其他库或应用导入。第二个模块在程序中调用第一个模块的方法。 本教程包括七个小的部分：\n创建一个模块：编写一个小模块，其中包含可以从另一个模块调用的函数。 从另一个模块调用您的代码：导入并使用您的新模块。 返回并处理错误：添加简单的错误处理。 返回一个随机的问候语：处理切片（slices）中的数据（slices：Go的动态大小数组）。 为多个人返回问候语：将键/值对存储在映射（map）中。 添加测试：使用Go内置的单元测试功能来测试代码。 编译并安装应用程序：在本地编译并安装。 前期准备 一些编程经验。这里的代码非常简单，但了解函数、循环和数组会有所帮助。 用于编辑代码的工具。 一种命令终端。Go在Linux和Mac上以及Windows中的PowerShell或cmd上使用任何终端都能很好地工作。 开始创建模块 首先创建Go模块。我们通常会把一些包含同一类功能函数的包放在同一模块中，例如，您可以创建模块，模块的包具有进行财务分析的功能，以便其他编写财务应用程序的人可以使用您的代码。有关开发模块的更多信息，请参阅开发和发布模块.。 Go语言中 代码，包(package)，模块（module）之间的关系是:代码组成包，包组成模块。您开发的模块需要指定运行代码所需的依赖项，包括Go版本及其所需的其他模块。 当您在模块中添加或改进功能时，您将发布模块的新版本。编写调用这个模块的开发人员可以导入新版本模块，并在将其上线之前使用新版本进行测试。\n打开命令行，cd到home目录（或其他存放代码的目录） 新建目录 greetings 用来存放Go代码 使用 go mod init 命令初始化一个module 执行 go mod init 命令；本例中我们用 example.com/greetings；如果您发布模块，这必须是Go工具可以下载模块的路径，那就是本模块代码仓库的路径（例如：github.com/example）；\ngo mod init example.com/greetings # go: creating new go.mod: module example.com/greetings go mod init 命令创建一个go.mod文件来跟踪代码的依赖关系。到目前为止，该文件只包括模块的名称和代码支持的Go版本。但当你添加依赖项时，go.mod文件会列出你的代码所依赖的版本。这可以保持构建的可复制性，并让你直接控制要使用的模块版本。\n在编辑器中新建 greetings.go 文件 在greetings.go文件中写入一下代码并保存 package greetings import \u0026#34;fmt\u0026#34; // Hello returns a greeting for the named person. func Hello(name string) string { // Return a greeting that embeds the name in a message. message := fmt.Sprintf(\u0026#34;Hi, %v. Welcome!\u0026#34;, name) return message } 这是您的模块的第一个代码。它会向任何要求调用者返回问候语。下一步我们将调用此函数。 代码解读：\n声明greetings包存放相关的功能方法 实现Hello功能来返回问候语 此函数接受字符串类型的name参数。该函数返回一个字符串。在Go中，名称以大写字母开头的函数可以由不在同一个包中的函数调用。这在Go中被称为导出名称。 声明一个用于保存问候语的message变量 在Go中，:= 运算符是在一行中声明和初始化变量的快捷方式（Go使用右侧的值来确定变量的类型）。完整格式可以这样写：\nvar message string message = fmt.Sprintf(\u0026#34;Hi, %v. Welcome!\u0026#34;, name) 使用fmt包的Sprintf函数可以创建一条问候消息。第一个参数是一个格式字符串，Sprintf将name参数的值替换%v。插入name参数的值将完成问候语 将格式化的问候语文本返回给调用者 在下一步中，您将从另一个模块调用此函数。\n调用模块 在上一节中，您创建了一个greetings模块。在本节中，您将编写代码来调用刚刚编写的模块中的Hello函数。您将编写可执行的代码，并调用问候语模块中的代码。\n创建一个hello目录编写调用代码 创建此目录后，您应该在层次结构的同一级别同时拥有hello和greetings目录，如下所示：\n\u0026lt;home\u0026gt;/ |-- greetings/ |-- hello/ 为即将编写的代码启用依赖项跟踪。 go mod init example.com/hello 在文本编辑器的hello目录中，创建hello.go文件。 编写代码调用Hello函数，打印返回值。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;example.com/greetings\u0026#34; ) func main() { // Get a greeting message and print it. message := greetings.Hello(\u0026#34;Gladys\u0026#34;) fmt.Println(message) } 代码解读：\n声明一个主程序包(main)。在Go中，作为应用程序执行的代码必须在主包中。 导入两个包：example.com/greetings和fmt包。这使您的代码可以访问这些包中的函数。导入example.com/greetings（包含在您之前创建的模块中的包）可以访问Hello函数。您还可以导入fmt，它具有处理输入和输出文本的功能（例如将文本打印到控制台）。 通过调用greetings包的Hello 方法来获得返回值。 编辑example.com/hello模块以使用本地example.com/hellos 在生产环境，Go工具可以从远程代码仓库中下载得到example.com/helles模块。目前，由于您尚未发布该模块，您需要调整example.com/hello模块的依赖关系，以便它可以在本地找到example.com/hellos代码。 用go mod edit命令编辑example.com/hello模块，将go工具从其模块路径（模块不在的地方）重定向到本地目录（模块所在的地方）。 a、在hello目录中的命令提示符下，运行以下命令\ngo mod edit -replace example.com/greetings=../greetings 该命令指定将依赖example.com/greetings应替换为/greetings。运行该命令后，hello目录中的go.mod文件应包含一个replace指令：\nmodule example.com/hello go 1.16 replace example.com/greetings =\u0026gt; ../greetings b、在hello目录中的命令提示符下，运行go mod tidy 命令来同步example.com/hello模块的依赖项，添加代码所需但尚未在模块中加载的依赖项。\n$ go mod tidy go: found example.com/greetings in example.com/greetings v0.0.0-00010101000000-000000000000 命令完成后，example.com/hello模块的go.mod文件应该如下所示：\nmodule example.com/hello go 1.16 replace example.com/greetings =\u0026gt; ../greetings require example.com/greetings v0.0.0-00010101000000-000000000000 该命令在greetings目录中找到了本地代码，然后添加了一个require指令，指定example.com/hello需要example.com/greetings。hello.go中导入greetings包时创建了此依赖项。 模块路径后面的数字是一个伪版本号,是自动生成的代替版本号的数字（模块实际还没有）。 要引用已发布的模块，go.mod文件通常会省略replace指令，并使用末尾带有标记版本号的require指令。\nrequire example.com/greetings v1.1.0 在hello目录中的命令提示符下，运行代码以确认它是否工作 $ go run . Hi, Gladys. Welcome! 恭喜！您已经编写了两个功能模块。在下节内容是错误处理。\n返回并处理错误 处理错误是健壮代码的一个基本特征。在本节中，您将添加一些代码，从greetings 模块返回一个错误，然后在调用者中进行处理。\n在 greetings/greetings.go 中添加代码: 如果你不知道该向谁打招呼，那么回电是没有意义的。如果name参数为空，则向调用方返回一个错误。\npackage greetings import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) // Hello returns a greeting for the named person. func Hello(name string) (string, error) { // If no name was given, return an error with a message. if name == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;empty name\u0026#34;) } // If a name was received, return a value that embeds the name // in a greeting message. message := fmt.Sprintf(\u0026#34;Hi, %v. Welcome!\u0026#34;, name) return message, nil } 代码解析：\n更改函数，使其返回两个值：一个string和一个error。调用者通过第二个返回值判断是否发生错误 (任何Go函数都可以返回多个值。有关更多信息，请参阅 Effective Go.) 导入Go标准库error包，使用 errors.New 函数。 添加if语句判断无效请求（name为空），如果请求无效则返回error。errors.New 函数返回一个错误，其中包含错误消息。 在成功返回中添加nil（表示没有错误）作为第二个返回值。这样，调用者就可以判断函数执行成功了。 在hello/hello.go文件中，处理hello函数返回的error以及非error值 将以下代码添加到hello.go。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;example.com/greetings\u0026#34; ) func main() { // Set properties of the predefined Logger, including // the log entry prefix and a flag to disable printing // the time, source file, and line number. log.SetPrefix(\u0026#34;greetings: \u0026#34;) log.SetFlags(0) // Request a greeting message. message, err := greetings.Hello(\u0026#34;\u0026#34;) // If an error was returned, print it to the console and // exit the program. if err != nil { log.Fatal(err) } // If no error was returned, print the returned message // to the console. fmt.Println(message) } 代码解析：\n将日志包配置为在其日志消息的开头打印命令名（“greetings：”），不带时间戳或源文件信息。 将两个Hello返回值（包括错误）分配给变量。 将Hello参数从Gladys的名称更改为空字符串，这样您就可以测试错误处理代码。判断 error 不等于 - nil，在这种情况下继续下去是没有意义。 使用标准库的log包中的函数来输出错误信息。如果出现错误，则使用日志包的Fatal函数打印错误并停止程序。 在hello目录的命令行中，运行hello.go以确认代码是否有效 $ go run . # greetings: empty name # exit status 1 这是Go中常见的错误处理：将错误作为值返回，以便调用方可以检查它。\n随机返回问候语 在本节中，您将更改代码，使其不再每次返回一个问候语，而是返回几个预定义的问候语消息中的一个。 为此，您将使用Go切片(slice)。切片就像一个数组，只是它的大小随着添加和删除项目而动态变化。切片是Go语言最有用的类型之一。 添加一个slice 存放三条问候消息，然后让代码随机返回其中一条消息。\n在问候语/问候语.go中，更改代码，如下 package greetings import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) // Hello returns a greeting for the named person. func Hello(name string) (string, error) { // If no name was given, return an error with a message. if name == \u0026#34;\u0026#34; { return name, errors.New(\u0026#34;empty name\u0026#34;) } // Create a message using a random format. message := fmt.Sprintf(randomFormat(), name) return message, nil } // init sets initial values for variables used in the function. func init() { rand.Seed(time.Now().UnixNano()) } // randomFormat returns one of a set of greeting messages. The returned // message is selected at random. func randomFormat() string { // A slice of message formats. formats := []string{ \u0026#34;Hi, %v. Welcome!\u0026#34;, \u0026#34;Great to see you, %v!\u0026#34;, \u0026#34;Hail, %v! Well met!\u0026#34;, } // Return a randomly selected message format by specifying // a random index for the slice of formats. return formats[rand.Intn(len(formats))] } 代码解析：\n添加一个randomFormat函数，该函数可为问候语返回随机选择的格式。请注意，randomFormat以小写字母开头，使其只能由自己包中的代码访问（换句话说，它不导出）。 在randomFormat中，用三种消息格式声明一个formats切片。在声明切片时，可以省略括号中的大小，如下所示：[]string。这告诉Go，片下面的数组大小可以动态更改。 使用math/rand包生成一个随机数，用于从切片(slice)中选择项目。 添加一个init函数，用当前时间为rand包设定种子。Go在初始化全局变量后，在程序启动时自动执行init函数。 在Hello中，调用randomFormat函数来获取要返回的消息的格式，然后将格式和名称值一起使用来创建消息。 像以前一样返回消息（或错误）。 在hello/hello.go中，更改代码，如下所示。 只将Gladys的名字（或者其他名字，如果您愿意的话）作为参数添加到Hello.go中的Hello函数调用中。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;example.com/greetings\u0026#34; ) func main() { // Set properties of the predefined Logger, including // the log entry prefix and a flag to disable printing // the time, source file, and line number. log.SetPrefix(\u0026#34;greetings: \u0026#34;) log.SetFlags(0) // Request a greeting message. message, err := greetings.Hello(\u0026#34;Gladys\u0026#34;) // If an error was returned, print it to the console and // exit the program. if err != nil { log.Fatal(err) } // If no error was returned, print the returned message // to the console. fmt.Println(message) } 在hello目录的命令行中，运行hello.go以确认代码是否有效。多次运行它，注意问候语变化。 $ go run . Great to see you, Gladys! $ go run . Hi, Gladys. Welcome! $ go run . Hail, Gladys! Well met! 为多人回复问候 在您将对模块代码进行的最后一次更改中，您将添加对在一个请求中获得多人问候的支持。换句话说，您将处理多值输入，然后将该输入中的值与多值输出配对。要做到这一点，您需要将一组名称传递给一个函数，该函数可以为每个名称返回一个问候语。 但有一个问题。将Hello函数的参数从单个名称更改为一组名称将更改函数的签名。如果您已经发布了example.com/greetings模块，并且用户已经编写了调用Hello的代码，那么这种更改将破坏他们的程序。 在这种情况下，更好的选择是用不同的名称编写一个新函数。新功能将采用多个参数。这保留了旧功能以实现向后兼容性。\n在greetings/greetings.go中，更改代如下所示。 package greetings import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) // Hello returns a greeting for the named person. func Hello(name string) (string, error) { // If no name was given, return an error with a message. if name == \u0026#34;\u0026#34; { return name, errors.New(\u0026#34;empty name\u0026#34;) } // Create a message using a random format. message := fmt.Sprintf(randomFormat(), name) return message, nil } // Hellos returns a map that associates each of the named people // with a greeting message. func Hellos(names []string) (map[string]string, error) { // A map to associate names with messages. messages := make(map[string]string) // Loop through the received slice of names, calling // the Hello function to get a message for each name. for _, name := range names { message, err := Hello(name) if err != nil { return nil, err } // In the map, associate the retrieved message with // the name. messages[name] = message } return messages, nil } // Init sets initial values for variables used in the function. func init() { rand.Seed(time.Now().UnixNano()) } // randomFormat returns one of a set of greeting messages. The returned // message is selected at random. func randomFormat() string { // A slice of message formats. formats := []string{ \u0026#34;Hi, %v. Welcome!\u0026#34;, \u0026#34;Great to see you, %v!\u0026#34;, \u0026#34;Hail, %v! Well met!\u0026#34;, } // Return one of the message formats selected at random. return formats[rand.Intn(len(formats))] } 代码解析:\n添加一个Hellos函数，该函数的参数是名称slice，而不是一个单独的名称。此外，您还可以将其返回类型从字符串更改为map，以便返回名称与问候语的映射。 让新的Hellos函数调用现有的Hello函数。这有助于减少重复，同时保留两个功能。 创建一个map 变量messages，将每个接收到的名称（作为key）与生成的消息（作为Value）关联起来。Go中可以使用以下语法初始化映射：make（map[key-type]value-type）。您可以使用Hellos函数将此映射返回给调用者。 循环查看函数接收到的names，检查每个name是否都有非空值，然后将消息与每个名称关联起来。在这个for循环中，range返回两个值：循环中当前项的索引和项值的副本。索引值用不到，用Go blank标识符（下划线）来忽略它。 在hello/hello.go调用代码中，传入names 切片，然后打印返回的name/message映射的内容。 在hello.go中，更改代码，如下所示。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;example.com/greetings\u0026#34; ) func main() { // Set properties of the predefined Logger, including // the log entry prefix and a flag to disable printing // the time, source file, and line number. log.SetPrefix(\u0026#34;greetings: \u0026#34;) log.SetFlags(0) // A slice of names. names := []string{\u0026#34;Gladys\u0026#34;, \u0026#34;Samantha\u0026#34;, \u0026#34;Darrin\u0026#34;} // Request greeting messages for the names. messages, err := greetings.Hellos(names) if err != nil { log.Fatal(err) } // If no error was returned, print the returned map of // messages to the console. fmt.Println(messages) } 代码解析:\n创建一个names 切片，包含三个name。 将names变量作为参数传递给Hellos函数。 在命令行中，切换到包含hello/hello.go的目录，然后使用go run确认代码是否有效。 输出应该是将name与message关联起来的map，如下所示：\n$ go run . map[Darrin:Hail, Darrin! Well met! Gladys:Hi, Gladys. Welcome! Samantha:Hail, Samantha! Well met!] 本主题介绍了用于表示名称/值对的映射。它还引入了通过为模块中的新功能或更改的功能实现新功能来保持向后兼容性的想法。\n添加测试 现在您已经将代码放到了一个固定的位置，添加一个测试。在开发过程中测试代码可能会暴露出在您进行更改时出现的错误。在本章节中，您将为 Hello 函数添加一个测试。 Go 内置的对单元测试的支持使得在进行测试时更容易。具体来说，使用命名约定、Go 的 testing 包和 Go test 命令，您可以快速编写和执行测试。\n在 greetings 目录中，创建一个名为 greetings_test.go 的文件。 以_test.go 结尾的文件名告诉 go test 命令此文件包含测试函数。\n在 greeting_test.go 中，添加以下代码并保存文件。 package greetings import ( \u0026#34;testing\u0026#34; \u0026#34;regexp\u0026#34; ) // TestHelloName calls greetings.Hello with a name, checking // for a valid return value. func TestHelloName(t *testing.T) { name := \u0026#34;Gladys\u0026#34; want := regexp.MustCompile(`\\b`+name+`\\b`) msg, err := Hello(\u0026#34;Gladys\u0026#34;) if !want.MatchString(msg) || err != nil { t.Fatalf(`Hello(\u0026#34;Gladys\u0026#34;) = %q, %v, want match for %#q, nil`, msg, err, want) } } // TestHelloEmpty calls greetings.Hello with an empty string, // checking for an error. func TestHelloEmpty(t *testing.T) { msg, err := Hello(\u0026#34;\u0026#34;) if msg != \u0026#34;\u0026#34; || err == nil { t.Fatalf(`Hello(\u0026#34;\u0026#34;) = %q, %v, want \u0026#34;\u0026#34;, error`, msg, err) } } 代码解析:\n在与您正在测试的代码相同的包中实现测试函数。 创建两个测试函数来测试 greetings.Hello 函数。测试函数名称的形式为 TestName，其中 Name 表示特定测试的内容。此外，测试函数将指向测试包的 testing.T 类型的指针作为参数。您可以使用此参数的方法从测试中进行报告和日志记录。 执行两次测试 TestHelloName 调用 Hello 函数，传递一个名称值，该函数应该能够使用该名称值返回有效的响应消息。如果调用返回错误或意外响应消息（其中不包括您传入的名称），则使用 t 参数的 Fatalf 方法将消息打印到控制台并结束执行。 TestHelloEmpty 使用一个空字符串调用 Hello 函数。此测试旨在确认您的错误处理是否有效。如果调用返回非空字符串或没有错误，则使用 t 参数的 Fatalf 方法将消息打印到控制台并结束执行。 在问候目录的命令行中，运行 go test 命令来执行测试。 go test 命令在测试文件（名称以\\test.go 结尾）中执行测试函数（名称以 test 开头）。您可以添加-v 标志来获得详细的输出，其中列出了所有测试及其结果。 $ go test PASS ok example.com/greetings 0.364s $ go test -v === RUN TestHelloName --- PASS: TestHelloName (0.00s) === RUN TestHelloEmpty --- PASS: TestHelloEmpty (0.00s) PASS ok example.com/greetings 0.372s 打断 greetings.Hello 函数用于查看未通过的测试。 TestHelloName 测试函数检查您指定为 Hello 函数参数的名称的返回值。要查看失败的测试结果，请更改 greetings.Hello 函数，使其不再包含名称。 在 greetings/greetings.go 中，粘贴以下代码来代替 Hello 函数。请注意，高亮显示的行会更改函数返回的值，就好像名称参数被意外删除了一样。 // Hello returns a greeting for the named person. func Hello(name string) (string, error) { // If no name was given, return an error with a message. if name == \u0026#34;\u0026#34; { return name, errors.New(\u0026#34;empty name\u0026#34;) } // Create a message using a random format. // message := fmt.Sprintf(randomFormat(), name) message := fmt.Sprint(randomFormat()) return message, nil } 在 greetings 目录的命令行中，运行 go test 来执行测试。 这一次，在没有-v 标志的情况下运行 go test。输出将只包括失败测试的结果，当您有很多测试时，这可能很有用。TestHelloName 测试应该失败—— TestHelloEmpty 仍然通过。 $ go test --- FAIL: TestHelloName (0.00s) greetings_test.go:15: Hello(\u0026#34;Gladys\u0026#34;) = \u0026#34;Hail, %v! Well met!\u0026#34;, \u0026lt;nil\u0026gt;, want match for `\\bGladys\\b`, nil FAIL exit status 1 FAIL example.com/greetings 0.182s 编译并安装应用 在最后一个主题中，您将学习几个新的 go 命令。虽然 go run 命令是在频繁更改时编译和运行程序的有用快捷方式，但它不会生成二进制可执行文件。\n本主题介绍了用于构建代码的两个附加命令:\ngo-build 命令编译包及其依赖项，但不安装结果。 go install 命令编译并安装程序包。 在 hello 目录的命令行中，运行 go build 命令将代码编译为可执行文件。 $ go build 在 hello 目录中的命令行中，运行新的 hello 可执行文件以确认代码是否有效。 请注意，您的结果可能会有所不同，这取决于您在测试后是否更改了 greetings.go 代码。 Linux or Mac: $ ./hello map[Darrin:Great to see you, Darrin! Gladys:Hail, Gladys! Well met! Samantha:Hail, Samantha! Well met!] On Windows: $ hello.exe map[Darrin:Great to see you, Darrin! Gladys:Hail, Gladys! Well met! Samantha:Hail, Samantha! Well met!] 您已将应用程序编译为可执行文件，以便运行它。但要当前运行它，您的提示需要位于可执行文件的目录中，或者指定可执行文件路径。 接下来，您将安装可执行文件，这样您就可以在不指定其路径的情况下运行它。\n查找 Go 安装路径，Go 命令将在其中安装当前软件包。 您可以通过运行 go list 命令来发现安装路径，如以下示例所示： $ go list -f \u0026#39;{{.Target}}\u0026#39; 例如，命令的输出可能会说/home/gopher/bin/hello，这意味着二进制文件被安装到/home/gopaher/bin。在下一步中，您将需要此安装目录。\n将 Go 安装目录添加到系统的 shell 路径 这样，您就可以运行程序的可执行文件，而无需指定可执行文件的位置。 在 Linux 或 Mac 上，运行以下命令:\n$ export PATH=$PATH:/path/to/your/install/directory 在 Windows, 运行以下命令:\n$ set PATH=%PATH%;C:\\path\\to\\your\\install\\directory 另一种选择是，如果您的 shell 路径中已经有一个类似$HOME/bin 的目录，并且您想在那里安装 Go 程序，则可以使用 Go-env 命令设置 GOBIN 变量来更改安装目标：\n$ go env -w GOBIN=/path/to/your/bin # or $ go env -w GOBIN=C:\\path\\to\\your\\bin 更新完 shell 路径后，运行 go install 命令来编译和安装包。 $ go install 只需输入应用程序的名称即可运行应用程序。为了让这变得有趣，打开一个新的命令提示符，并在其他目录中运行 hello 可执行文件名。 $ hello map[Darrin:Hail, Darrin! Well met! Gladys:Great to see you, Gladys! Samantha:Hail, Samantha! Well met!] "
},
{
	"uri": "http://blog.911015.com/tour/03.html",
	"title": "基础篇（三）：更多类型: struct, slices, 和 map",
	"tags": null,
	"description": "基础篇（三）：更多类型: struct, slices, 和 map",
	"content": "指针 Go提供了指针类型。指针保存的是一个值的内存地址。 类型*T是指向T值的指针。它的零值为nil。\nvar p *int \u0026amp;运算符生成指向其操作数的指针。\ni := 42 p = \u0026amp;i *运算符表示指针的基本值。\nfmt.Println(*p) // read i through the pointer p *p = 21 // set i through the pointer p 与C不同，Go没有指针运算。\npackage main import \u0026#34;fmt\u0026#34; func main() { i, j := 42, 2701 p := \u0026amp;i // point to i fmt.Println(*p) // read i through the pointer *p = 21 // set i through the pointer fmt.Println(i) // see the new value of i p = \u0026amp;j // point to j *p = *p / 37 // divide j through the pointer fmt.Println(j) // see the new value of j } 结构体（Structs） 结构体是字段的集合。使用点访问结构字段。\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { X int Y int } func main() { fmt.Println(Vertex{1, 2}) v := Vertex{1, 2} v.X = 4 fmt.Println(v.X) } 结构体指针 可以通过结构指针访问结构字段。\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { X int Y int } func main() { v := Vertex{1, 2} p := \u0026amp;v p.X = 1e9 fmt.Println(v) } 当我们通过结构指针p访问结构的字段X，可以这样写（*p）.X。然而，这种表示法很麻烦，所以Go语言允许我们只写p.X，而不显式解引用。\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { X, Y int } var ( v1 = Vertex{1, 2} // has type Vertex v2 = Vertex{X: 1} // Y:0 is implicit v3 = Vertex{} // X:0 and Y:0 p = \u0026amp;Vertex{1, 2} // has type *Vertex ) func main() { fmt.Println(v1, p, v2, v3) } 结构字面量通过设置其字段的值来表示新分配的结构值。您可以使用 Name: 语法设置部分字段的值。（命名字段的顺序无关紧要。） 特殊前缀\u0026amp;返回一个指向结构值的指针。\nArrays 类型[n]T是n个类型为T的值的数组。 表达式 ：\nvar a [10]int 将变量a声明为一个由十个整数组成的数组。 数组的长度是其类型的一部分，因此无法调整数组的大小。这似乎有局限性，但不要担心；Go提供了一种使用数组的方便方法。\npackage main import \u0026#34;fmt\u0026#34; func main() { var a [2]string a[0] = \u0026#34;Hello\u0026#34; a[1] = \u0026#34;World\u0026#34; fmt.Println(a[0], a[1]) fmt.Println(a) primes := [6]int{2, 3, 5, 7, 11, 13} fmt.Println(primes) } Slices 数组具有固定的大小。切片是动态数组。在实践中，切片比数组更常见。类型[]T是具有类型T的元素的slice 。切片是通过指定两个索引来形成的，一个是由冒号分隔的下界和上界：a[low : high] 这会截取一个包括第一个元素（low ）但不包括最后一个元素（high）的slice。 以下表达式创建一个切片，该切片包括的元素1到3：a[1:4]\npackage main import \u0026#34;fmt\u0026#34; func main() { primes := [6]int{2, 3, 5, 7, 11, 13} var s []int = primes[1:4] fmt.Println(s) } 切片类似于对数组的引用 切片不存储任何数据，它只描述底层数组的一部分。更改切片的元素会修改其底层数组的相应元素。共享相同底层阵列的其他切片将看到这些变化。\npackage main import \u0026#34;fmt\u0026#34; func main() { names := [4]string{ \u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;, \u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;, } fmt.Println(names) a := names[0:2] b := names[1:3] fmt.Println(a, b) b[0] = \u0026#34;XXX\u0026#34; fmt.Println(a, b) fmt.Println(names) } Slice字面量 切片就像一个没有长度的数组。 这是一个数组：\n[]bool{true, true, false} 这会创建与上面相同的数组，然后构建一个引用它的切片：\n[]bool{true, true, false} package main import \u0026#34;fmt\u0026#34; func main() { q := []int{2, 3, 5, 7, 11, 13} fmt.Println(q) r := []bool{true, false, true, true, false, true} fmt.Println(r) s := []struct { i int b bool }{ {2, true}, {3, false}, {5, true}, {7, true}, {11, false}, {13, true}, } fmt.Println(s) } Slice 默认值 使用切片时，可以省略上限或下限，而使用它们的默认值。对于下限，默认为零，对于上限，默认为切片长度。 对数组 var a [10]int，这些切片表达式是等效的：\na[0:10] a[:10] a[0:] a[:] package main import \u0026#34;fmt\u0026#34; func main() { s := []int{2, 3, 5, 7, 11, 13} s = s[1:4] fmt.Println(s) s = s[:2] fmt.Println(s) s = s[1:] fmt.Println(s) } slice长度和容量 切片既有长度也有容量。切片的长度是它包含的元素个数。片的容量是底层数组中的元素数，从切片中的第一个元素开始计数。切片的长度和容量s可以使用表达式len（s）和cap（s）来获得。\npackage main import \u0026#34;fmt\u0026#34; func main() { s := []int{2, 3, 5, 7, 11, 13} printSlice(s) // Slice the slice to give it zero length. s = s[:0] printSlice(s) // Extend its length. s = s[:4] printSlice(s) // Drop its first two values. s = s[2:] printSlice(s) } func printSlice(s []int) { fmt.Printf(\u0026#34;len=%d cap=%d %v\\n\u0026#34;, len(s), cap(s), s) } 您可以通过重新切片来延长切片的长度，前提是它有足够的容量。尝试更改示例程序中的一个切片操作，以将其扩展到其容量之外，然后看看会发生什么。\nSlice零值 切片的零值为nil。值位nil的切片长度和容量为0，并且没有底层数组。\npackage main import \u0026#34;fmt\u0026#34; func main() { var s []int fmt.Println(s, len(s), cap(s)) if s == nil { fmt.Println(\u0026#34;nil!\u0026#34;) } } 使用make创建切片 切片可以使用内置的make函数创建；这就是创建动态大小数组的方法。make函数分配一个空数组，并返回一个引用该数组的切片：\na := make([]int, 5) // len(a)=5 要指定容量，请传递make函数的第三个参数以：\nb := make([]int, 0, 5) // len(b)=0, cap(b)=5 b = b[:cap(b)] // len(b)=5, cap(b)=5 b = b[1:] // len(b)=4, cap(b)=4 package main import \u0026#34;fmt\u0026#34; func main() { a := make([]int, 5) printSlice(\u0026#34;a\u0026#34;, a) b := make([]int, 0, 5) printSlice(\u0026#34;b\u0026#34;, b) c := b[:2] printSlice(\u0026#34;c\u0026#34;, c) d := c[2:5] printSlice(\u0026#34;d\u0026#34;, d) } func printSlice(s string, x []int) { fmt.Printf(\u0026#34;%s len=%d cap=%d %v\\n\u0026#34;, s, len(x), cap(x), x) } 二维slice 切片可以包含任何类型，包括其他切片。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { // Create a tic-tac-toe board. board := [][]string{ []string{\u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;}, []string{\u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;}, []string{\u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;}, } // The players take turns. board[0][0] = \u0026#34;X\u0026#34; board[2][2] = \u0026#34;O\u0026#34; board[1][2] = \u0026#34;X\u0026#34; board[1][0] = \u0026#34;O\u0026#34; board[0][2] = \u0026#34;X\u0026#34; for i := 0; i \u0026lt; len(board); i++ { fmt.Printf(\u0026#34;%s\\n\u0026#34;, strings.Join(board[i], \u0026#34; \u0026#34;)) } } Append 将新元素附加到切片中是很常见的，因此Go提供了一个内置函数append 。\nfunc append(s []T, vs ...T) []T //append的第一个参数s是T类型的切片，其余的是要附加到切片的T值。 append的结果值是一个切片，包含原始切片的所有元素加上提供的值。 如果s的底层数组太小，无法容纳所有给定的值，则会分配一个更大的数组。返回的切片将指向新分配的数组。\npackage main import \u0026#34;fmt\u0026#34; func main() { var s []int printSlice(s) // append works on nil slices. s = append(s, 0) printSlice(s) // The slice grows as needed. s = append(s, 1) printSlice(s) // We can add more than one element at a time. s = append(s, 2, 3, 4) printSlice(s) } func printSlice(s []int) { fmt.Printf(\u0026#34;len=%d cap=%d %v\\n\u0026#34;, len(s), cap(s), s) } Range for循环的range形式在切片或映射上进行迭代。在切片上进行遍历时，每次迭代都会返回两个值。第一个是索引，第二个是该索引处元素的副本。\npackage main import \u0026#34;fmt\u0026#34; var pow = []int{1, 2, 4, 8, 16, 32, 64, 128} func main() { for i, v := range pow { fmt.Printf(\u0026#34;2**%d = %d\\n\u0026#34;, i, v) } } 您可以用 _ 来跳过索引或值。如果只需要索引，可以省略第二个变量。\nfor i, _ := range pow for _, value := range pow for i := range pow package main import \u0026#34;fmt\u0026#34; func main() { pow := make([]int, 10) for i := range pow { pow[i] = 1 \u0026lt;\u0026lt; uint(i) // == 2**i } for _, value := range pow { fmt.Printf(\u0026#34;%d\\n\u0026#34;, value) } } 练习：切片 实现 Pic函数.它应该返回一个长度为dy的切片，其中的每个元素都是dx 8位无符号整数的切片. 当你运行该程序时, 它将显示您的图片，将整数解释为灰度值. 图像的选择取决于您。有趣的函数包括（x+y）/2、x*y和x^y 您需要使用一个循环来分配[][]uint8中的每个[]uint8。 (使用uint8（intValue）在类型之间进行转换。)\n一下代码仅供参考\npackage main import \u0026#34;golang.org/x/tour/pic\u0026#34; func Pic(dx, dy int) [][]uint8 { total := make([]uint8, dx*dy) res := make([][]uint8, dx) for x := 0; x \u0026lt; dx; x++ { res[x], total = total[0:dy], total[dy:] for y := 0; y \u0026lt; dy; y++ { res[x][y] = uint8(x * y) } } return res } func main() { pic.Show(Pic) } Maps Map 是键值对的映射 map的零值为nil。nil map 没有key，也不能向其添加key。 make函数返回给定类型的map，该map已初始化并可以使用。\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { Lat, Long float64 } var m map[string]Vertex func main() { m = make(map[string]Vertex) m[\u0026#34;Bell Labs\u0026#34;] = Vertex{ 40.68433, -74.39967, } fmt.Println(m[\u0026#34;Bell Labs\u0026#34;]) } map 赋值与结构赋值类似，但key是必需的。\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { Lat, Long float64 } var m = map[string]Vertex{ \u0026#34;Bell Labs\u0026#34;: Vertex{ 40.68433, -74.39967, }, \u0026#34;Google\u0026#34;: Vertex{ 37.42202, -122.08408, }, } func main() { fmt.Println(m) } 如果顶级类型只是一个类型名称，则可以从赋值的元素中省略它。\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { Lat, Long float64 } var m = map[string]Vertex{ \u0026#34;Bell Labs\u0026#34;: {40.68433, -74.39967}, \u0026#34;Google\u0026#34;: {37.42202, -122.08408}, } func main() { fmt.Println(m) } 修改map package main import \u0026#34;fmt\u0026#34; func main() { m := make(map[string]int) m[\u0026#34;Answer\u0026#34;] = 42 fmt.Println(\u0026#34;The value:\u0026#34;, m[\u0026#34;Answer\u0026#34;]) m[\u0026#34;Answer\u0026#34;] = 48 fmt.Println(\u0026#34;The value:\u0026#34;, m[\u0026#34;Answer\u0026#34;]) delete(m, \u0026#34;Answer\u0026#34;) fmt.Println(\u0026#34;The value:\u0026#34;, m[\u0026#34;Answer\u0026#34;]) v, ok := m[\u0026#34;Answer\u0026#34;] fmt.Println(\u0026#34;The value:\u0026#34;, v, \u0026#34;Present?\u0026#34;, ok) } 在map m中插入或更新元素：\nm[key] = elem 查找元素：\nelem = m[key] 删除元素：\ndelete(m, key) 通过接收第二个参数测试是否存在对应的key：\nelem, ok = m[key] 若key在m中，则ok为true。否则ok为false。 若key不在map中，则elem是map元素类型的零值。 注意：如果尚未声明elem或ok，则可以使用简短的声明形式：\nelem, ok := m[key] 练习：map 实现WordCount。它应该返回字符串s中每个“单词”计数的map。wc.Test函数针对所提供的函数运行一个测试套件，并打印成功或失败。你可能会用到 strings.Fields。 一下代码仅供参考\npackage main import ( \u0026#34;strings\u0026#34; \u0026#34;golang.org/x/tour/wc\u0026#34; ) func WordCount(s string) map[string]int { res := make(map[string]int) words := strings.Fields(s) for _, word := range words { res[word]++ } return res } func main() { wc.Test(WordCount) } 函数类型 函数也是值。它们可以像其他值一样传递。函数值可以用作函数参数和返回值。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func compute(fn func(float64, float64) float64) float64 { return fn(3, 4) } func main() { hypot := func(x, y float64) float64 { return math.Sqrt(x*x + y*y) } fmt.Println(hypot(5, 12)) fmt.Println(compute(hypot)) fmt.Println(compute(math.Pow)) } 函数闭包 Go函数可能是闭包。闭包是一个函数值，它引用来自其主体外部的变量。函数可以访问并分配给引用的变量；从这个意义上说，函数是“绑定”到变量的。例如，addr函数返回一个闭包。每个闭包都绑定到它自己的sum变量。\npackage main import \u0026#34;fmt\u0026#34; func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } func main() { pos, neg := adder(), adder() for i := 0; i \u0026lt; 10; i++ { fmt.Println( pos(i), neg(-2*i), ) } } 练习：斐波那契闭包 让我们玩一下function。 实现一个fibonacci函数，它返回一个函数（闭包），该函数返回连续的fibonacci数（0，1，1，2，3，5，…）。 一下代码仅供参考\npackage main import \u0026#34;fmt\u0026#34; // fibonacci is a function that returns // a function that returns an int. func fibonacci() func() int { var pre,cur = 0,0 return func()int{ temp := cur cur = pre+cur pre = temp if cur == 0 { cur = 1 return 0 } return temp } } func fibonacci1() func() int { var pre, cur, idx = 0, 1, -1 return func() int { idx++ if idx \u0026lt;= 1 { return idx } temp := cur cur = pre + cur pre = temp return cur } } func main() { f := fibonacci() for i := 0; i \u0026lt; 10; i++ { fmt.Println(f()) } } "
},
{
	"uri": "http://blog.911015.com/beginner/04.html",
	"title": "04-入门多模块工作区",
	"tags": null,
	"description": "",
	"content": "本教程介绍了 Go 中多模块工作区的基础知识。使用多模块工作区，您可以告诉 Go 命令您正在同时在多个模块中编写代码，并轻松地在这些模块中构建和运行代码。 在本教程中，您将在共享的多模块工作区中创建两个模块，对这些模块进行更改，并在构建中查看这些更改的结果。\n前期准备 安装 Go 1.18 或更高版本。 一个编辑代码的工具。 一个命令终端。 本教程需要** go1.18** 或更高版本。使用go.dev/dl中的链接确保您已在 Go 1.18 或更高版本中安装了 Go 。\n创建一个模块 首先，为您要编写的代码创建一个模块。 一、打开命令提示符并切换到您的主目录。\n# Linux 或 Mac： $ cd # Windows： C:\\\u0026gt; cd %HOMEPATH% 本教程的其余部分将显示 $ 作为提示符。您使用的命令也适用于 Windows。\n二、在命令提示符下，创建workspace目录。\n$ mkdir workspace $ cd workspace 三、初始化模块\n本示例将创建一个依赖 golang.org/x/example 模块的hello 模块。\n1、创建 hello 模块：\n$ mkdir hello $ cd hello $ go mod init example.com/hello go: creating new go.mod: module example.com/hello 2、使用 go get 添加 golang.org/x/example 依赖、。\n$ go get golang.org/x/example 3、在 hello 目录下创建 hello.go，内容如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;golang.org/x/example/stringutil\u0026#34; ) func main() { fmt.Println(stringutil.Reverse(\u0026#34;Hello\u0026#34;)) } 4、运行 hello 程序：\n$ go run example.com/hello olleH 创建工作区 在此步骤中，我们将创建一个go.work文件来指定模块的工作区。\n初始化工作区 在workspace目录中，运行：\n$ go work init ./hello 该go work init命令会生成go.work文件从而创建一个包含 ./hello 目录的工作空间\n该go命令生成一个go.work如下所示的文件：\ngo 1.18 use ./hello 该go.work文件的语法与go.mod 类似 第一行 go 1.18 告诉 Go 应使用哪个版本的 Go 编译文件，与go.mod文件go.mod 。 第二行 use ./hello 告诉 Go 在编译时 hello 目录的模块应该是主模块 所以在任何子目录下的workspace模块都会被激活。\n运行工作区目录下的程序 在workspace目录中，运行：\n$ go run example.com/hello olleH Go 命令包括工作区中的所有模块作为主模块。这允许我们引用模块中he模块外的包。在模块或工作区外运行该go run命令会报错，因为该go命令不知道要使用哪些模块。\n接下来，我们将模块的本地golang.org/x/example添加到工作区。然后我们将向stringutil包中添加一个新函数，我们可以使用它来代替Reverse.\n下载并修改golang.org/x/example模块 在此步骤中，我们将下载包含该模块的 Git 存储库的副本golang.org/x/example，将其添加到工作区，然后向其中添加我们将在 hello 程序中使用的新函数。 克隆存储库 1、在工作区目录中，运行git命令以克隆存储库：\n$ git clone https://go.googlesource.com/example Cloning into \u0026#39;example\u0026#39;... remote: Total 165 (delta 27), reused 165 (delta 27) Receiving objects: 100% (165/165), 434.18 KiB | 1022.00 KiB/s, done. Resolving deltas: 100% (27/27), done. 2、将模块添加到工作区\n$ go work use ./example 该go work use命令将一个新模块添加到 go.work 文件中。如下：\ngo 1.18 use ( ./hello ./example ) 该模块现在包括模块example.com/hello和golang.org/x/example模块。 我们将在本地stringutil模块中编写的新代码，而不是使用go get命令下载的模块版本。\n3、添加新功能。 添加一个将字符串转大写的新函数到golang.org/x/example/stringutil包中。 在 workspace/example/stringutil 目录中创建一个toupper.go；写入一下代码：\npackage stringutil import \u0026#34;unicode\u0026#34; // ToUpper uppercases all the runes in its argument string. func ToUpper(s string) string { r := []rune(s) for i := range r { r[i] = unicode.ToUpper(r[i]) } return string(r) } 4、修改 hello 程序以使用该函数。 修改内容为workspace/hello/hello.go包含以下内容：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;golang.org/x/example/stringutil\u0026#34; ) func main() { fmt.Println(stringutil.ToUpper(\u0026#34;Hello\u0026#34;)) } 在工作区运行代码 从工作区目录，运行\n$ go run example.com/hello HELLO Go命令在go.work文件指定的目录example.com/hello下查找命令行指定的模块 ，同样使用go.work文件解析导入golang.org/x/example go.work可以替换 replace 指令来跨多个模块工作。 由于这两个模块位于同一个工作区中，因此很容易在一个模块中进行更改并在另一个模块中使用它。\n更进一步 现在，要正确发布这些模块，我们需要发布模块golang.org/x/example ，例如在v0.1.0. 这通常是通过在模块的版本控制存储库上标记提交来完成的。 有关更多详细信息，请参阅 模块发布工作流程文档。发布完成后，我们可以在hello/go.mod中增加对 golang.org/x/example的依赖：\ncd hello go get golang.org/x/example@v0.1.0 这样，该go命令就可以正确解析工作区外的模块。\n了解有关工作区的更多信息 除了我们在本教程前面看到的go work init之外，该go命令还有几个用于处理工作区的子命令：\ngo work use [-r] [dir] ：如果文件存在，则为go.work文件添加一个use dir指令，如果参数目录不存在，则删除该目录。-r表示递归地检查子目录。 go work edit：编辑go.work文件类似于go mod edit go work sync：将工作区构建列表中的依赖项同步到每个工作区模块中。 "
},
{
	"uri": "http://blog.911015.com/tour/",
	"title": "Go 编程语言之旅",
	"tags": null,
	"description": "欢迎来到Go 编程语言之旅。",
	"content": "欢迎来到Go 编程语言之旅。 欢迎来到 Go 之旅 基础篇（一）：包、变量和方法 基础篇（二）：Go语言流程控制 基础篇（三）：更多类型: struct, slices, 和 map 基础篇 学习语言的所有基础知识。 声明变量、调用函数以及学习下一课之前需要了解的所有内容。\r包、变量和函数。\r了解任何 Go 程序的基本组件。\r流程控制语句：for、if、else、switch 和 defer\r了解如何使用条件、循环、开关和延迟来控制代码流。\r更多类型：结构、切片和映射。\r了解如何根据现有类型定义类型：本课程涵盖结构、数组、切片和映射。\r方法和接口 了解如何定义类型的方法、如何声明接口以及如何将所有内容组合在一起。\r方法和接口\r本课涵盖方法和接口、定义对象及其行为的结构。\r泛型 了解如何在 Go 函数和结构中使用类型参数。\r泛型\rGo 支持使用类型参数的泛型编程。本课展示了一些在代码中使用泛型的示例。\r并发 Go 提供并发功能作为核心语言的一部分。该模块介绍了 goroutines 和通道，以及如何使用它们来实现不同的并发模式。\r并发\rGo 提供并发结构作为核心语言的一部分。本课将介绍它们并给出一些有关如何使用它们的示例。\r"
},
{
	"uri": "http://blog.911015.com/contact.html",
	"title": "与我联系",
	"tags": null,
	"description": "联系方式",
	"content": " Email： create98715@duck.com QQ： 3336449889 关注公众号\n关注公众号\n"
},
{
	"uri": "http://blog.911015.com/categories/",
	"title": "Categories",
	"tags": null,
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.911015.com/tags/",
	"title": "Tags",
	"tags": null,
	"description": "",
	"content": ""
}]
