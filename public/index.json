[
{
	"uri": "http://blog.911015.com/beginner/01.html",
	"title": "01-Golang安装与体验",
	"tags": null,
	"description": "",
	"content": " 下载并安装按照一下步骤快速进行。 有关安装的其他内容，您可能对以下内容感兴趣：\nGo多版本安装管理 \u0026ndash;如何安装多版本并卸载。 Go 源码安装 \u0026ndash; 如何下载源码并在自己的机器上编译安装Go。 下载地址在这里 go.dev/dl/ 各系统版本都有，下载一个与自己系统匹配的版本，可以选最新版本进行安装学习。\n安装Go 选择下面对应的计算机操作系统，然后按照其安装说明进行操作。\nLinux 删除/usr/local/Go文件夹（如果存在），删除以前的Go安装，然后将刚下载的存档提取到/usr/local中，在/usr/local/go: Copy\rrm -rf /usr/local/go \u0026amp;\u0026amp; tar -C /usr/local -xzf go1.20.4.linux-amd64.tar.gz （您可能需要以root用户身份或通过sudo运行该命令）。不要将归档文件解压缩到现有的/usr/local/go目录中。这会导致Go安装失败\n将/usr/local/go/bin添加到PATH环境变量中 您可以通过将以内容添加到$HOME/.profile或/etc/profile（全局安装）来完成此操作：\nCopy\rexport PATH=$PATH:/usr/local/go/bin **注意**：对配置文件所做的更改可能要等到下次登录计算机时才能应用。要立即应用更改，只需直接运行shell命令，或者使用`source $HOME/.profile` 等命令从概要文件中执行这些命令。\r3. 通过打开命令提示符并输入以下命令来验证是否已安装Go\rCopy\r$ go version 4. 确认该命令打印已安装的Go版本。\rMac 打开下载的软件包文件，并按照提示安装Go 该软件包将Go安装到/usr/local/go。该包应该将/usr/local/go/bin目录放在PATH环境变量中。可能需要重新启动任何打开的终端会话才能使更改生效。\n通过打开命令提示符并键入以下命令来验证是否已安装Go go version\n确认该命令打印已安装的Go版本。 Window 1、打开您下载的MSI文件，并按照提示安装Go。 默认情况下，安装程序将安装Go到 Program Files或Program Files（x86）。您可以根据需要更改位置。安装后，您需要关闭并重新打开任何打开的命令提示符，以便在命令提示符下反映安装程序对环境所做的更改。\n2、验证您是否已安装Go；\n在Windows中，单击“开始”菜单。 在菜单的搜索框中，键入cmd，然后按Enter键。 在出现的“命令提示符”窗口中，键入以下命令： go version 确认该命令打印已安装的Go版本。 Reference Installing Go "
},
{
	"uri": "http://blog.911015.com/tour/01.html",
	"title": "1、基础篇（一）：包、变量和方法",
	"tags": null,
	"description": "基础篇（一）：包、变量和方法；学习任何Go程序的基本组成部分。",
	"content": "包（ package） 每个Go项目都是由程序包组成的。 程序在main包中运行。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; ) func main() { fmt.Println(\u0026#34;My favorite number is\u0026#34;, rand.Intn(10)) } 此程序使用导入的“fmt”和“math/rand”包。 按照惯例，包名称为导入路径的最后一个元素。例如，“math/rand”包含以rand为包名的文件。\nimport 此代码将导入分组到一个带括号的的import语句中。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func main() { fmt.Printf(\u0026#34;Now you have %g problems.\\n\u0026#34;, math.Sqrt(7)) } 您还可以编写多个import语句，如：\nimport \u0026#34;fmt\u0026#34; import \u0026#34;math\u0026#34; 但是，建议使用带括号的import语句。\n导出名称 在 Go 中，如果名称以大写字母开头，则会导出该名称。例如，Pizza，Pi 是是从math包中导出的名称。 pizza并且pi不要以大写字母开头，因此它们不会被导出。 导入包时，您只能引用其导出的名称。任何“未导出”的名称都无法从包外部访问。 运行代码。请注意错误消息。 要修复错误，请重命名math.pi为math.Pi并重试。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func main() { fmt.Println(math.pi) } 函数/方法 (Functions) Functions 函数可以接受零个或多个参数。 在本例中，add接收两个int类型的参数。\n请注意，该类型位于变量名之后。\npackage main import \u0026#34;fmt\u0026#34; func add(x int, y int) int { return x + y } func main() { fmt.Println(add(42, 13)) } 当两个或多个连续的命名函数参数共享一个类型时，可以从除最后一个之外的所有参数中省略该类型。在这个例子中，可以把 x int, y int 简写为 x, y int\n多返回值 Multiple results 函数可以返回任意数量的结果。函数可以返回任意数量的结果。\npackage main import \u0026#34;fmt\u0026#34; func swap(x, y string) (string, string) { return y, x } func main() { a, b := swap(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;) fmt.Println(a, b) } 具名返回值 Named return values Go的返回值可以命名。这种写法将视为在函数顶部定义的变量。这些变量用于记录返回值。不带参数的return语句返回命名的返回值。这种方式适合比较短的函数；如果是函数体比较长的函数这种方式可读性会比较差\npackage main import \u0026#34;fmt\u0026#34; func split(sum int) (x, y int) { x = sum * 4 / 9 y = sum - x return } func main() { fmt.Println(split(17)) } 变量（Variables） var语句声明了一个变量列表；在函数参数列表中，类型是最后一个。 var语句可以是包级别的，也可以是函数级别的。例子中分别展示了这两种情况。\npackage main import \u0026#34;fmt\u0026#34; var c, python, java bool func main() { var i int fmt.Println(i, c, python, java) } 定义带初始值的变量 var 声明每个变量包含初始值的变量。 如果存在初始值，则可以省略类型；该变量将采用初始值设定项的类型。\npackage main import \u0026#34;fmt\u0026#34; var i, j int = 1, 2 func main() { var c, python, java = true, false, \u0026#34;no!\u0026#34; fmt.Println(i, j, c, python, java) } 短变量声明 在函数内部，可以使用 := 短赋值语句来代替隐式类型的var声明。在函数之外，每条语句都以关键字（var、func等）开头，因此:=构造不可用。\npackage main import \u0026#34;fmt\u0026#34; func main() { var i, j int = 1, 2 k := 3 c, python, java := true, false, \u0026#34;no!\u0026#34; fmt.Println(i, j, k, c, python, java) } 基本类型 Go语言的基本类型有\nbool string int int8 int16 int32 int64 uint uint8 uint16 uint32 uint64 uintptr byte // alias for uint8 rune // alias for int32 // represents a Unicode code point float32 float64 complex64 complex128 该示例显示了几种类型的变量，还显示了变量声明可以被“分解”到块中，就像import语句一样\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math/cmplx\u0026#34; ) var ( ToBe bool = false MaxInt uint64 = 1\u0026lt;\u0026lt;64 - 1 z complex128 = cmplx.Sqrt(-5 + 12i) ) func main() { fmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, ToBe, ToBe) fmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, MaxInt, MaxInt) fmt.Printf(\u0026#34;Type: %T Value: %v\\n\u0026#34;, z, z) } int、uint和uintptr类型在32位系统上通常为32位宽，在64位系统上为64位宽。当您需要一个整数值时，您应该使用int，除非您有特定的理由使用大小或无符号整数类型。\n零值 在没有显式初始值的情况下声明的变量将被赋予零值。 各类型零值:\n数字类型 0, 布尔类型 false string类型 \u0026quot;\u0026quot; (空字符串) . package main import \u0026#34;fmt\u0026#34; func main() { var i int var f float64 var b bool var s string fmt.Printf(\u0026#34;%v %v %v %q\\n\u0026#34;, i, f, b, s) } 类型转换 表达式T(v) 将值v转换为类型T。 一些数字转换\nvar i int = 42 var f float64 = float64(i) var u uint = uint(f) 或者，更简单地说：\ni := 42 f := float64(i) u := uint(f) 与C不同，Go语言不同类型的项之间的赋值需要显式转换。尝试删除示例中的float64或uint转换，看看会发生什么。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func main() { var x, y int = 3, 4 var f float64 = math.Sqrt(float64(x*x + y*y)) var z uint = uint(f) fmt.Println(x, y, z) } 类型推断 当声明变量而不指定显式类型时（通过使用 := 语法或var =表达式语法），变量的类型是从右侧的值推断出来的。 当声明的右侧被输入时，新变量是相同类型的\nvar i int j := i // j 是 int 类型 但是，当右侧包含非类型化的数字常量时，新变量可能是int、float64或complex128，具体取决于常量的精度：\ni := 42 // int f := 3.142 // float64 g := 0.867 + 0.5i // complex128 package main import \u0026#34;fmt\u0026#34; func main() { v := 42 // change me! fmt.Printf(\u0026#34;v is of type %T\\n\u0026#34;, v) } 尝试更改示例代码中v的初始值，并观察其类型是如何受到影响的。\n常量 常量是像变量一样声明的，但使用const关键字。常量可以是字符、字符串、布尔值或数值。不能使用 := 语法声明常量。\npackage main import \u0026#34;fmt\u0026#34; const Pi = 3.14 func main() { const World = \u0026#34;世界\u0026#34; fmt.Println(\u0026#34;Hello\u0026#34;, World) fmt.Println(\u0026#34;Happy\u0026#34;, Pi, \u0026#34;Day\u0026#34;) const Truth = true fmt.Println(\u0026#34;Go rules?\u0026#34;, Truth) } 数值常量 数值常量是高精度的值。非类型化的常量采用其上下文所需的类型。\npackage main import \u0026#34;fmt\u0026#34; const ( // 通过向左移动1位100位来创建一个巨大的数字。 // 换句话说，二进制数是1，后面跟着100个零。 Big = 1 \u0026lt;\u0026lt; 100 // 再次向右移动99位，所以我们最终得到1\u0026lt;\u0026lt;1或2。 Small = Big \u0026gt;\u0026gt; 99 ) func needInt(x int) int { return x*10 + 1 } func needFloat(x float64) float64 { return x * 0.1 } func main() { fmt.Println(needInt(Small)) fmt.Println(needFloat(Small)) fmt.Println(needFloat(Big)) } 也可以尝试打印needInt（Big）。（int最多可以存储64位整数，有时可以存储更少的整数。）\n"
},
{
	"uri": "http://blog.911015.com/go-zero/01.html",
	"title": "go-zero 单体应用实践（一）",
	"tags": null,
	"description": "单体应用实践",
	"content": "环境搭建 官方文档\nGolang 环境安装 👉 golang Go Module设置 go env -w GO111MODULE=\u0026quot;on\u0026quot; goctl安装 👉 goctl protoc \u0026amp; protoc-gen-go安装 goctl env check -i -f --verbose etcd，redis，mysql 等开发工具可以通过Docker 快速搭建；可参考👉 gonivinck\n创建单体应用 1、创建目录 mkdir user-login cd user-login go mod init user-login 2、编辑api文件 userlogin.api api语法介绍\ntype ( RegisterRequest { Name string `json:\u0026#34;name\u0026#34;` Email string `json:\u0026#34;email\u0026#34;` Password string `json:\u0026#34;password\u0026#34;` } RegisterResponse { ID int `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Email string `json:\u0026#34;email\u0026#34;` } LoginRequest { Email string `json:\u0026#34;email\u0026#34;` Password string `json:\u0026#34;password\u0026#34;` } LoginResponse { Token string `json:\u0026#34;token\u0026#34;` Expire int64 `json:\u0026#34;expire\u0026#34;` } ) service userlogin-api { @handler RegisterHandler post /api/register(RegisterRequest) returns (RegisterResponse); @handler LoginHandler post /api/login(LoginRequest) returns (LoginResponse); } 3、执行生成代码命令 goctl api go -api userlogin.api -dir . go mod tidy\n生成文件目录\nuserlogin ├─etc // // 配置文件 ├─internal │ ├─config // 配置声明type │ ├─handler // 路由及handler转发 │ ├─logic // 业务逻辑 │ ├─svc // logic所依赖的资源池 │ └─types // request、response的struct，根据api自动生成 4、编辑配置文件 userlogin/etc/userlogin-api.yaml\nName: userlogin-api Host: 0.0.0.0 Port: 8888 Mysql: DataSource: root:123456@tcp(mysql:3306)/user?charset=utf8mb4\u0026amp;parseTime=true\u0026amp;loc=Asia%2FShanghai CacheRedis: - Host: redis:6379 Type: node Salt: DWe7OZf6KPlnv7yy Auth: AccessSecret: uOvKLmVfztaXGpNYd4Z0I1SiT7MweJhl AccessExpire: 86400 添加config声明 userlogin/internal/config/config.go 其中Salt 用来密码加密存储，Auth 用于 jwt鉴权\ntype Config struct { rest.RestConf Mysql struct { DataSource string } CacheRedis cache.CacheConf Salt string Auth struct { AccessSecret string AccessExpire int64 } } 4、生成Model文件 添加用户表 userlogin/model/user.sql\nCREATE TABLE `user` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL DEFAULT \u0026#39;\u0026#39; COMMENT \u0026#39;用户姓名\u0026#39;, `email` varchar(255) NOT NULL DEFAULT \u0026#39;\u0026#39; COMMENT \u0026#39;用户邮箱\u0026#39;, `password` varchar(255) NOT NULL DEFAULT \u0026#39;\u0026#39; COMMENT \u0026#39;用户密码\u0026#39;, `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP, `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`), UNIQUE KEY `idx_email_unique` (`email`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 通过命令生成model文件 model 指令\ngoctl model mysql ddl -src=\u0026ldquo;userlogin/model/user.sql\u0026rdquo; -dir=\u0026ldquo;userlogin/model/\u0026rdquo; -c\n-c 参数代表 在model层使用缓存 需要配置对应的 CacheRedis 生成文件如下：\nuser.sql\rusermodel.go\rusermodel_gen.go\rvars.go 可以看到 goctl 已经生成了 UserModel interface 并实现了基本的增删改查询代码； 5、完善服务依赖 编辑 userlogin/internal/svc/servicecontext.go 添加 logic所依赖的 UserModel\ntype ServiceContext struct { Config config.Config UserModel model.UserModel } func NewServiceContext(c config.Config) *ServiceContext { conn := sqlx.NewMysql(c.Mysql.DataSource) return \u0026amp;ServiceContext{ Config: c, UserModel: model.NewUserModel(conn, c.CacheRedis), } } 6、业务逻辑代码 1、注册逻辑代码\ntype RegisterLogic struct { logx.Logger ctx context.Context svcCtx *svc.ServiceContext } func NewRegisterLogic(ctx context.Context, svcCtx *svc.ServiceContext) *RegisterLogic { return \u0026amp;RegisterLogic{ Logger: logx.WithContext(ctx), ctx: ctx, svcCtx: svcCtx, } } func (l *RegisterLogic) Register(req *types.RegisterRequest) (resp *types.RegisterResponse, err error) { _, err = l.svcCtx.UserModel.FindOneByEmail(l.ctx, req.Email) if err == nil { return nil, status.Error(100, \u0026#34;该用户已存在\u0026#34;) } if err != model.ErrNotFound { return nil, status.Error(100, err.Error()) } newUser := model.User{ Name: req.Name, Email: req.Email, Password: cryptx.PasswordEncrypt(l.svcCtx.Config.Salt, req.Password), } res, err := l.svcCtx.UserModel.Insert(l.ctx, \u0026amp;newUser) if err != nil { return nil, status.Error(500, err.Error()) } newUser.Id, err = res.LastInsertId() if err != nil { return nil, status.Error(500, err.Error()) } return \u0026amp;types.RegisterResponse{ ID: int(newUser.Id), Name: newUser.Name, Email: newUser.Email, }, nil } 2、添加 JWT 工具 userlogin/common/jwtx/jwt.go\npackage jwtx import \u0026#34;github.com/golang-jwt/jwt\u0026#34; func GetToken(secretKey string, iat, seconds, uid int64) (string, error) { claims := make(jwt.MapClaims) claims[\u0026#34;exp\u0026#34;] = iat + seconds claims[\u0026#34;iat\u0026#34;] = iat claims[\u0026#34;uid\u0026#34;] = uid token := jwt.New(jwt.SigningMethodHS256) token.Claims = claims return token.SignedString([]byte(secretKey)) } 3、用户登录逻辑 userlogin/internal/logic/loginlogic.go\ntype LoginLogic struct { logx.Logger ctx context.Context svcCtx *svc.ServiceContext } func NewLoginLogic(ctx context.Context, svcCtx *svc.ServiceContext) *LoginLogic { return \u0026amp;LoginLogic{ Logger: logx.WithContext(ctx), ctx: ctx, svcCtx: svcCtx, } } func (l *LoginLogic) Login(req *types.LoginRequest) (resp *types.LoginResponse, err error) { res, err := l.svcCtx.UserModel.FindOneByEmail(l.ctx, req.Email) if err != nil { if err == model.ErrNotFound { return nil, status.Error(100, \u0026#34;用户不存在\u0026#34;) } return nil, status.Error(500, err.Error()) } // 判断密码是否正确 password := cryptx.PasswordEncrypt(l.svcCtx.Config.Salt, req.Password) if password != res.Password { return nil, status.Error(100, \u0026#34;密码错误\u0026#34;) } now := time.Now().Unix() accessExpire := l.svcCtx.Config.Auth.AccessExpire accessToken, err := jwtx.GetToken(l.svcCtx.Config.Auth.AccessSecret, now, accessExpire, res.Id) if err != nil { return nil, err } return \u0026amp;types.LoginResponse{ Token: accessToken, Expire: now + accessExpire, }, nil } 7、启动测试\ngo run userlogin.go -f etc/userlogin-api.yaml # Starting server at 0.0.0.0:8888... 注册测试\ncurl -i -X POST http://127.0.0.1:8888/api/register -H \u0026#39;Content-Type: application/json\u0026#39; -d \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;test\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;test@gmail.com\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;123456\u0026#34;}\u0026#39; HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Traceparent: 00-91ee4162c2a42c7df3111ab73cdb242f-1b886700e9099cc8-00 Date: Tue, 19 Jul 2022 16:19:33 GMT Content-Length: 47 {\u0026#34;id\u0026#34;:1,\u0026#34;name\u0026#34;:\u0026#34;test\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;test@gmail.com\u0026#34;} 登录测试\ncurl -i -X POST http://127.0.0.1:8888/api/login -H \u0026#39;Content-Type: application/json\u0026#39; -d \u0026#39;{\u0026#34;email\u0026#34;:\u0026#34;test@gmail.com\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;123456\u0026#34;}\u0026#39; HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Traceparent: 00-4cc2b11a99a2216590c50a2a7215e832-d7af5dc45fa6a65b-00 Date: Tue, 19 Jul 2022 16:22:28 GMT Content-Length: 171 {\u0026#34;token\u0026#34;:\u0026#34;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NTgzMzQxNDgsImlhdCI6MTY1ODI0Nzc0OCwidWlkIjoxfQ.QGrhGWCRSMWGyEZyV7GatGYU_XgBVdjQRJqW7qEBk04\u0026#34;,\u0026#34;expire\u0026#34;:1658334148} jwt鉴权应用 上面已经完成了登录注册功能；并且登录返回了Token；接下来就用一下Token\n1、开启jwt鉴权 编写 api 文件 在 service 上方声明使用jwt鉴权 修改 userlogin/userlogin.api 重新执行 goctl api 命令\ntype UserInfoResponse { ID int64 `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Email string `json:\u0026#34;email\u0026#34;` } @server( jwt: Auth // Auth 与 userlogin/internal/config/config.go 中配置的 jwt 参数对应 ) service userlogin-api { @handler UserInfo get /api/userinfo returns (UserInfoResponse) } 可以看到路由文件中 userlogin/internal/handler/routes.go 新增的路由中通 WithJwt 声明了使用jwt鉴权\nserver.AddRoutes( []rest.Route{ { Method: http.MethodGet, Path: \u0026#34;/api/userinfo\u0026#34;, Handler: UserInfoHandler(serverCtx), }, }, rest.WithJwt(serverCtx.Config.Auth.AccessSecret), ) 2、编写logic 代码 userlogin/internal/logic/userinfologic.go\nfunc NewUserInfoLogic(ctx context.Context, svcCtx *svc.ServiceContext) *UserInfoLogic { return \u0026amp;UserInfoLogic{ Logger: logx.WithContext(ctx), ctx: ctx, svcCtx: svcCtx, } } func (l *UserInfoLogic) UserInfo() (resp *types.UserInfoResponse, err error) { uid, _ := l.ctx.Value(\u0026#34;uid\u0026#34;).(json.Number).Int64() one, err := l.svcCtx.UserModel.FindOne(l.ctx, uid) if err != nil { return nil, err } return \u0026amp;types.UserInfoResponse{ ID: one.Id, Name: one.Name, Email: one.Email, }, nil } 3、运行测试 # curl -i http://127.0.0.1:8000/api/userinfo HTTP/1.1 401 Unauthorized Traceparent: 00-a418d68212d9e2c29664a7e9aeefbd14-7282c005bbcd5f24-00 Date: Thu, 21 Jul 2022 17:01:21 GMT Content-Length: 0 #curl -i -X GET \u0026#39;http://127.0.0.1:8000/api/userinfo\u0026#39; -H \u0026#39;Authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2NTg1MDkzNDAsImlhdCI6MTY1ODQyMjk0MCwidWlkIjoxfQ.j6K0CjJ9jM5a3a7-DRUGq6b3uvMFcelvR7vQkZAQXWw\u0026#39; HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Traceparent: 00-e547b466d3e7da54d932838bfdee17c4-4ec7aaedb056ef03-00 Date: Thu, 21 Jul 2022 17:07:42 GMT Content-Length: 47 {\u0026#34;id\u0026#34;:1,\u0026#34;name\u0026#34;:\u0026#34;test\u0026#34;,\u0026#34;email\u0026#34;:\u0026#34;test@gmail.com\u0026#34;} "
},
{
	"uri": "http://blog.911015.com/",
	"title": "Go语言入门",
	"tags": null,
	"description": "Go语言入门",
	"content": "\r《Go语言入门》 整理了从零开始学习Go语言的相关基础知识；\r跟着用户手册学Golang gRPC 快速体验 go-zero应用实践 Go语言入门之路公众号文章 "
},
{
	"uri": "http://blog.911015.com/wx/2023052202.html",
	"title": "Go语言流程控制:Defer",
	"tags": null,
	"description": "Go语言流程控制:Defer",
	"content": "在 Golang 中，defer 是一个关键字，用于定义延迟执行函数。它可以将一个函数推迟到当前函数返回之后执行，即使该函数出现异常或错误也不会影响 defer 定义的代码块。\n常见用例 以下是 defer 的一些常见用例： 1、关闭文件资源 使用 defer 关闭文件资源是一种非常常见的方法，可以确保无论代码中发生了什么，文件都能够被关闭。\nf, err := os.Open(\u0026#34;/path/to/file\u0026#34;) if err != nil { log.Fatal(err) } defer f.Close() 2、记录耗时 我们可以在开始处理某个请求前调用 time.Now() 函数来记录起始时间，然后在退出函数时计算经过的时间并打印出来。\nfunc processRequest(req *http.Request) { start := time.Now() defer logTime(start) // 处理请求 } func logTime(start time.Time) { log.Printf(\u0026#34;request took %v\u0026#34;, time.Since(start)) } 3、锁的释放 当我们在使用互斥锁时，必须确保每次获取锁后都要及时释放锁，否则会导致死锁的情况。使用 defer 语句可以确保在任何情况下都会释放锁。\nvar mu sync.Mutex func someFunc() { mu.Lock() defer mu.Unlock() // 执行一些需要锁定的操作 } 注意事项 在使用 defer 时，需要注意以下几个问题：\n延迟执行的函数参数会在定义时被计算，而不是在实际执行时计算。这意味着如果参数是一个指针或一个引用类型，并且在函数退出之前被修改了，那么这些修改会影响到延迟执行的函数。例如： func someFunc() { var a = 10 defer fmt.Println(a) a = 20 } // 输出结果为 10 如果有多个 defer 语句，它们的执行顺序与声明的顺序相反。也就是说，最后一个 defer 语句将首先执行，最先声明的 defer 语句将最后执行。 func someFunc() { defer fmt.Println(\u0026#34;first\u0026#34;) defer fmt.Println(\u0026#34;second\u0026#34;) defer fmt.Println(\u0026#34;third\u0026#34;) } // 输出结果为 third, second, first 在函数中，return 语句并不是原子操作。具体来说，它分为两个步骤：第一步是将返回值赋给调用者；第二步是执行函数的清理工作（包括 defer 语句）。因此，在使用 defer 时，需要注意不要让 defer 影响函数的返回值。例如： func someFunc() (result int) { defer func() { result++ }() return 0 } // 返回值为 1 如果在 defer 语句中使用了一个函数返回的错误值并且该函数可能会失败，则应该在调用函数后立即检查返回值。否则，在函数最后执行时，可能会忽略错误并导致不可预测的行为。例如： func someFunc() (err error) { file, err := os.Open(\u0026#34;filename.txt\u0026#34;) if err != nil { return err } defer func() { if err := file.Close(); err != nil { log.Fatal(err) } }() // ... } "
},
{
	"uri": "http://blog.911015.com/grpc/01.html",
	"title": "一、Hello World",
	"tags": null,
	"description": "gRPC 是 Google 开发的一款高性能、开源的远程过程调用（RPC）框架。它使用 Protocol Buffers 作为接口定义语言（IDL），可以在多种编程语言和平台之间进行通信。",
	"content": " 一个高性能、开源的通用RPC框架 A high performance, open source universal RPC framework\n一、环境配置 1、下载并安装 protocol-buffers 2、安装Go语言插件\ngo install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28 go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2\n3、创建GRPC项目目录：\nmkdir grpc-demo go mod init grpc-demo\n二、创建并编译proto 文件 hello/proto/helloworld.proto\nProtobuf 中 除了支持如double、float、 int32、int64、 uint32、uint64、 bool、 string 和bytes 等基本数据类型还支持enum，oneof，map，repeated 等类型；更详细的Protobuf文档可以查阅 ：protocol-buffers 文档\nsyntax = \u0026#34;proto3\u0026#34;; package helloworld; option go_package = \u0026#34;proto/;proto\u0026#34;; service Greeter { rpc SayHello(HelloRequest) returns (HelloReply) {}; } enum Gender { Unknown = 0; Female = 1; Male = 2; } message HelloRequest { string name = 1; int64 age = 2; oneof call { string mobile = 3; string phone = 4; } map\u0026lt;int64,string\u0026gt; role = 5; Gender gender = 6; } message HelloReply { string message = 1; } 创建好proto文件后执行编译命令，生成go文件代码\nprotoc -I=./hello/proto/ \u0026ndash;go_out=./hello/ \u0026ndash;go-grpc_out=./hello/ ./hello/proto/helloworld.proto\n参数说明： -I** 或 \u0026ndash;proto_path ：指定指定要搜索的目录进口。可以指定多次；将按顺序搜索目录。如果当前proto文件中依赖第三方文件，一般需要指定第三方文件路径； _\u0026ndash;go_out**= ：设置所生成的Go代码输出的目录 _\u0026ndash;go-grpc_out**= ： **设置所生成的 protoc-gen-go-grpc 生成代码输出的目录 执行成功后生成 hello/proto/helloworld.pb.go hello/proto/helloworld_grep.pb.go 两个文件\n三、服务端代码实现 我们在第二步中的proto文件中定义了 Greeter 服务，Greeter 服务包含一个SayHello方法；在生成的grpc文件中可以找到 一个方法\nfunc RegisterGreeterServer(s grpc.ServiceRegistrar, srv GreeterServer)\n接下来服务端要做的就是实现 GreeterServer 接口注册并启动服务\nvar port string func init() { flag.StringVar(\u0026amp;port, \u0026#34;p\u0026#34;, \u0026#34;8000\u0026#34;, \u0026#34;启动端口号\u0026#34;) flag.Parse() } type Server struct { pb.UnimplementedGreeterServer } func (gs Server) SayHello(ctx context.Context, r *pb.HelloRequest) (*pb.HelloReply, error) { str := r.GetMobile() if len(str) == 0 { str = r.GetPhone() } var url string for k, v := range r.Role { url = fmt.Sprintf(\u0026#34;%d=%s\u0026amp;\u0026#34;, k, v) } return \u0026amp;pb.HelloReply{Message: \u0026#34;Hello World \u0026#34; + r.Name + str + \u0026#34;?\u0026#34; + url}, nil } func main() { server := grpc.NewServer() pb.RegisterGreeterServer(server, \u0026amp;Server{}) reflection.Register(server) lis, _ := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:\u0026#34;+port) server.Serve(lis) } 26：reflection.Register(server) 增加后，可以通过grpcurl进行测试\n四、客户端代码开发 客户端调用代码 在helloworld_grpc.pb.go 已经生成：func NewGreeterClient(cc grpc.ClientConnInterface) GreeterClient 创建客户端对象，直接调用服务端方法；\nvar port string func init() { flag.StringVar(\u0026amp;port, \u0026#34;p\u0026#34;, \u0026#34;8000\u0026#34;, \u0026#34;启动端口号\u0026#34;) flag.Parse() } func main() { conn, _ := grpc.Dial(\u0026#34;:\u0026#34;+port, grpc.WithInsecure()) defer conn.Close() client := pb.NewGreeterClient(conn) _ = SayHello(client) } func SayHello(client pb.GreeterClient) error { reapy := \u0026amp;pb.HelloRequest{ Name: \u0026#34;eddycjy\u0026#34;, Call: \u0026amp;pb.HelloRequest_Mobile{Mobile: \u0026#34;151\u0026#34;}, Role: map[int64]string{1: \u0026#34;888\u0026#34;}, } resp, _ := client.SayHello(context.Background(), reapy) log.Printf(\u0026#34;client.SayHello resp: %s\u0026#34;, resp.Message) return nil } 其中8行中 grpc.WithInsecure() 方法在新版本中已经不赞成使用；建议使用 ** grpc.WithTransportCredentials(insecure.NewCredentials())**替换\n"
},
{
	"uri": "http://blog.911015.com/beginner/",
	"title": "跟着用户手册学Golang",
	"tags": null,
	"description": "Go编程语言是一个开源项目，旨在提高程序员的工作效率。",
	"content": "\r文档简介\rGo编程语言是一个开源项目，旨在提高程序员的工作效率。\nGo表现力强、简洁、干净、高效。它的并发机制使编写程序变得容易，从而最大限度地利用多核和网络机器，而它的新型系统则实现了灵活和模块化的程序构建。Go可以快速编译为机器代码，但同时具有垃圾收集的便利性和运行时反射的功能。这是一种快速、静态类型化、编译的语言，感觉就像是一种动态类型化、解释的语言。\nGolang官方文档地址为：go.dev/doc ；文档开始简单介绍了Golang 的语言特性：简洁、高效、天然并发、快速编译、垃圾回收、反射，新类型系统等等。接下来分按入门，进阶、高级划分了大模块让初学者能够寻寻渐进的深入学习理解Golang；接下来我们将根据 Getting Started部分一步一步入门Golang。\n本章节内容为官方文档内容翻译；部分内容和代码为个人补充；Copyright\n如果内容有误请 与我联系\n教程列表 说明 安装Golang 有关下载和安装Go的说明。 新手入门 一个简短的Hello，World入门教程。了解一些Go代码、工具、包和模块。 创建Go项目 介绍函数、错误处理、数组、映射、单元测试和编译的简短主题教程。 入门多模块工作区 介绍在Go中创建和使用多模块工作区的基本知识。多模块工作空间对于跨多个模块进行更改非常有用。（Go 1.18增加了工作空间模式，本地做多版本管理很方便） 用Go和Gin开发RESTful API 介绍使用Go和Gin web Framework编写RESTful web服务API的基础知识。 使用Go泛型 使用泛型，您可以声明和使用函数或类型，这些函数或类型是为与调用代码提供的任何一组类型一起工作而编写的。(Go 1.18 Go语言增加泛型) 使用fuzzing模糊测试 fuzzing可以为您的测试生成输入，这些输入可以捕捉到您可能错过的边缘案例和安全问题。（模糊测试是一种通过向目标系统提供非预期的输入并监视异常结果来发现软件漏洞的方法。） 编写Web应用程序 构建一个简单的web应用程序。 如何编写Go代码 本文档解释了如何在模块中开发一组简单的Go包，并展示了如何使用Go命令来构建和测试包。 Go之旅 Go语言的互动介绍分为三个部分。第一部分介绍了基本语法和数据结构；第二部分讨论了方法和接口；第三部分介绍了Go的并发原语。每一节都以一些练习作为结束，这样你就可以练习你所学到的东西。您可以在线参观，也可以使用以下软件在本地安装： go install golang.org/x/website/tour@latest这将把tour二进制文件放在GOPATH的bin目录中。 学习计划 阅读官方文档； 通过代码练习语法 通过项目熟悉代码 01-Golang安装与体验 02-新手入门 03-创建Go项目 04-入门多模块工作区 Go 编程语言之旅 "
},
{
	"uri": "http://blog.911015.com/beginner/02.html",
	"title": "02-新手入门",
	"tags": null,
	"description": "",
	"content": " 在本教程中，您将获得Go编程的简要介绍\n安装Go . 写一些简单的 \u0026ldquo;Hello, world\u0026rdquo; . 使用go命令运行代码. 使用Go程序包发现工具查找可以在自己的代码中使用的程序包. 调用外部模块的功能. 前期准备 一些编程经验。 这里的代码非常简单，但了解一些函数相关的知识会有所帮助。. 用于编辑代码的工具。** ** 任何文本编辑器都可以。大多数文本编辑器都很好地支持Go。最受欢迎的是VSCode（免费）、GoLand（付费）和Vim（免费）。 一个命令终端. Go在Linux和Mac上以及Windows中的PowerShell或cmd上使用任何终端都能很好地工作。 Hello World 按一下步骤写一段 “Hello World”代码\n1、打开一个命令提示符并cd到您的主目录。 Linux/Mac 系统执行 : cd Window系统执行： cd %HOMEPATH%\n2、为您的第一个Go源代码创建一个hello目录 可以使用一下命令：\nmkdir hello cd hello 3、为代码启用依赖管理\n当您的代码导入其他项目中的包（package）时，您可以通过自己的代码来管理这些模块的依赖关系。该模块由go.mod文件定义，通过该文件追踪提供包的这些模块。该go.mod文件与您的代码一起保存，包括在您的源代码存储库中。\r要通过创建go.mod文件为代码启用依赖管理，请运行go mod init+模块的名称 命令。该名称是模块的模块路径。\r在实际开发中，模块路径通常是保存源代码的存储仓库位置。例如，模块路径可能是github.com/mymodule。如果您计划发布您的模块供他人使用，则模块路径必须是Go工具可以下载您的模块的位置。\r对于本教程，只需使用example/hello。\ngo mod init example/hello go: creating new go.mod: module example/hello 4、在编辑器中，创建一个文件hello.go，在其中编写代码。 5、将以下代码粘贴到hello.go文件中并保存该文件。\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;Hello World（^-^）\u0026#34;) } 接下来看一下这段代码的内容：\n声明一个主包(main)（包是对函数进行分组的一种方式，它由同一目录中的所有文件组成）。 导入流行的fmt包，其中包含格式化文本的功能，包括打印到控制台。这个包是Go的标准库之一。 实现一个主要功能，将消息打印到控制台。当您运行主程序包时，默认情况下会执行一个主函数（main）。 6、运行代码\ngo run . # Hello World（^-^） 7、go run命令是众多go命令之一。使用 go help 命令可以查看其他命令帮助文档：\n调用外部包 当你需要你的代码来做一些可能已经被其他人实现的事情时，你可以导入一个实现了这些功能的包直接使用。\n1、使用外部模块的功能，使打印的消息更加有趣\r访问pkg.go.dev并搜索“quote”包 在搜索结果中找到并单击rsc.io/quote包（如果您看到rsc.io/quote/v3，请暂时忽略它）。 在“文档”部分的“索引”下，记下可以从代码中调用的函数列表。您将使用Go功能。 请注意，在本页顶部，\u0026ldquo;quote\u0026quot;包含在rsc.io/quote模块中。 您可以使用pkg.go.dev网站查找已发布的模块，这些模块的包中有您可以在自己的代码中使用的功能。包发布在模块中，比如rsc.io/quote，其他人可以在其中使用它们。随着时间的推移，新版本会对模块进行改进，您可以升级代码以使用改进的版本。\r2、在Go代码中，导入rsc.io/quote包并调用其函数 quote.Go()。之后，您的代码应该包括以下内容：\rpackage main import \u0026#34;fmt\u0026#34; import \u0026#34;rsc.io/quote\u0026#34; func main() { fmt.Println(quote.Go()) } 3、添加模块依赖和校验 Go程序把“quote”包添加到依赖中（go.mod），以及用于验证模块的go.sum文件中。\n$ go mod tidy go: finding module for package rsc.io/quote go: found rsc.io/quote in rsc.io/quote v1.5.2 4、运行您的代码以查看您正在调用的函数生成的消息。\n$ go run . # Don\u0026#39;t communicate by sharing memory, share memory by communicating. 请注意，您的代码调用Go函数，打印出一条关于通信的格言。\n当您运行go mod tidy，它找到并下载了包含您导入的包的rsc.io/quote模块。默认情况下，它下载了最新版本v1.5.2。\n"
},
{
	"uri": "http://blog.911015.com/tour/02.html",
	"title": "2、基础篇（二）：Go语言流程控制",
	"tags": null,
	"description": "基础篇（二）：Go语言流程控制",
	"content": "For Go只有一个循环结构，即for循环。\npackage main import \u0026#34;fmt\u0026#34; func main() { sum := 0 for i := 0; i \u0026lt; 10; i++ { sum += i } fmt.Println(sum) } 基本的for循环有三个用分号分隔的部分：\n初始化语句：在第一次迭代之前执行 条件表达式：在每次迭代之前求值 后置语句：在每次循环结束时执行 初始化语句通常是一个简短的变量声明，在那里声明的变量只在for语句的范围内可见。 一旦条件表达式的计算结果为false，循环将停止迭代。 注意：与C、Java或JavaScript等其他语言不同，for语句的三个组件周围没有括号，并且必须要有大括号{}。 初始化语句和后置语句是可选的。如下：\npackage main import \u0026#34;fmt\u0026#34; func main() { sum := 1 for ; sum \u0026lt; 1000; { sum += sum } fmt.Println(sum) } 更进一步，还可以去掉分号：类似C语言中的的while那样，在Go中是用for实现的。如下：\npackage main import \u0026#34;fmt\u0026#34; func main() { sum := 1 for sum \u0026lt; 1000 { sum += sum } fmt.Println(sum) } 如果省略循环条件，它将永远循环，因此一个死循环就可以这样写：\npackage main func main() { for { // Do something forever } } If Go的if语句类似于它的for循环；表达式不需要用括号（）括起来，但必须要有大括号｛｝。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func sqrt(x float64) string { if x \u0026lt; 0 { return sqrt(-x) + \u0026#34;i\u0026#34; } return fmt.Sprint(math.Sqrt(x)) } func main() { fmt.Println(sqrt(2), sqrt(-4)) } 与for一样，if语句可以在条件之前以执行一个短语句。语句声明的变量只能在if结束之前使用。如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v \u0026lt; lim { return v } return lim } func main() { fmt.Println( pow(3, 2, 10), pow(3, 3, 20), ) } （请尝试在最后一个return(line 12)语句中使用v。）\nIf and else 在if短语句中声明的变量在任何else块中都可用。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func pow(x, n, lim float64) float64 { if v := math.Pow(x, n); v \u0026lt; lim { return v } else { fmt.Printf(\u0026#34;%g \u0026gt;= %g\\n\u0026#34;, v, lim) } // can\u0026#39;t use v here, though return lim } func main() { fmt.Println( pow(3, 2, 10), pow(3, 3, 20), ) } （在main中对fmt.Println的调用之前，会先对两个pow调用求值。）\n练习：循环和函数 为了练习函数和方法，让我们实现一个平方根函数： 给定一个数字x，找到z²最接近x的数字z。 计算机通常使用循环计算x的平方根。从一些可能的z开始，我们可以根据z²与x的接近程度来调整z，从而产生更好的结果：\nz -= (z*z - x) / (2*z) 重复这种调整会使结果变得越来越好，直到我们得出尽可能接近实际平方根的答案 在函数Sqrt中实现这一功能。z的一个不错的起始值是1，无论输入是什么。首先，重复计算10次，并在计算过程中打印每个z。看看你离x（1，2，3，…）的各种值的答案有多近，以及猜测改进的速度有多快。 提示：要声明和初始化浮点值，请定义为浮点类型或使用类型转换转换：\nz := 1.0 z := float64(1) 接下来，一旦值停止更改（或仅更改很小的量），就将循环条件更改为停止。看看这是多于还是少于10次迭代。尝试对z进行其他初始猜测，如x或x/2。您的函数的结果与标准库中的math.Sqrt有多接近？ （注意：如果你对算法的细节感兴趣，上面的z²−x是z²离它需要的位置（x）有多远，除以2z是z²的导数，通过z²的变化速度来衡量我们调整z的程度。这种通用方法被称为牛顿方法。它适用于许多函数，但特别适用于平方根。） 以下代码仅供参考\nimport ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func Sqrt(x float64) float64 { var z = 1.0 var old float64 for math.Abs(old-z) \u0026gt;= 0.000001 { old = z z -= (z*z - x) / (2 * z) } return z } func main() { fmt.Println(Sqrt(2), math.Sqrt(2)) fmt.Println(Sqrt(10), math.Sqrt(10)) } Switch switch语句是编写if-else的一种更简短的方法。它执行第一个满足条件的分支。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; ) func main() { fmt.Print(\u0026#34;Go runs on \u0026#34;) switch os := runtime.GOOS; os { case \u0026#34;darwin\u0026#34;: fmt.Println(\u0026#34;OS X.\u0026#34;) case \u0026#34;linux\u0026#34;: fmt.Println(\u0026#34;Linux.\u0026#34;) default: // freebsd, openbsd, // plan9, windows... fmt.Printf(\u0026#34;%s.\\n\u0026#34;, os) } } Go的switch结构与C、C++、Java、JavaScript和PHP中的开关类似，只是Go只运行第一个符合条件的分支，而不是随后的所有案例。实际上，在Go中在每个分支最后都加了break语句。另一个重要的区别是Go的switch的分支条件不一定是常数，所涉及的值也不需要是整数。\n执行顺序 switch 分支是从上到下进行判断的，当某一个分支成功时停止向下执行。例如：\nswitch i { case 0: case f(): } // 如果i = 0 f函数是不执行的 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { fmt.Println(\u0026#34;When\u0026#39;s Saturday?\u0026#34;) today := time.Now().Weekday() switch time.Saturday { case today + 0: fmt.Println(\u0026#34;Today.\u0026#34;) case today + 1: fmt.Println(\u0026#34;Tomorrow.\u0026#34;) case today + 2: fmt.Println(\u0026#34;In two days.\u0026#34;) default: fmt.Println(\u0026#34;Too far away.\u0026#34;) } } 无条件Switch 无条件Switch等同于 Switch true。这种构造可以用来编写长if-then-else链。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { t := time.Now() switch { case t.Hour() \u0026lt; 12: fmt.Println(\u0026#34;Good morning!\u0026#34;) case t.Hour() \u0026lt; 17: fmt.Println(\u0026#34;Good afternoon.\u0026#34;) default: fmt.Println(\u0026#34;Good evening.\u0026#34;) } } Defer defer语句将一个函数的执行延迟到锁住函数返回时。延迟调用的参数会立即求值，但在周围的函数返回之前不会执行函数调用。\npackage main import \u0026#34;fmt\u0026#34; func main() { defer fmt.Println(\u0026#34;world\u0026#34;) fmt.Println(\u0026#34;hello\u0026#34;) } defer的函数调用被推送到堆栈中。当函数返回时，其defer调用将按后进先出的顺序执行。\npackage main import \u0026#34;fmt\u0026#34; func main() { fmt.Println(\u0026#34;counting\u0026#34;) for i := 0; i \u0026lt; 10; i++ { defer fmt.Println(i) } fmt.Println(\u0026#34;done\u0026#34;) } "
},
{
	"uri": "http://blog.911015.com/go-zero/02.html",
	"title": "go-zero 单体应用实践（二）",
	"tags": null,
	"description": "单体应用实践",
	"content": "中间件使用 在go-zero中，中间件可以分为路由中间件和全局中间件，路由中间件是指某一些特定路由需要实现中间件逻辑，其和jwt类似，没有放在jwt:xxx下的路由不会使用中间件功能， 而全局中间件的服务范围则是整个服务。\n路由中间件 1、编辑 api 文件 userlogin/userlogin.api 生命接口需要添加的中间件，多个中间件用逗号分隔\n@server( middleware : Tagging,Version ) service userlogin-api { @handler Tags get /api/tags returns (TagResponse) } 2、goctl api 命令重新执行 生成middleware 文件\nuserlogin/internal/middleware/taggingmiddleware.go userlogin/internal/middleware/versionmiddleware.go 可以看到路由文件中userlogin/internal/handler/routes.go 新增了一下代码\nserver.AddRoutes( rest.WithMiddlewares( []rest.Middleware{serverCtx.Tagging, serverCtx.Version}, []rest.Route{ { Method: http.MethodGet, Path: \u0026#34;/api/tags\u0026#34;, Handler: TagsHandler(serverCtx), }, }..., ), ) 3、 文件中添加中间件依赖 userlogin/internal/svc/servicecontext.go\ntype ServiceContext struct { Config config.Config Tagging rest.Middleware Version rest.Middleware UserModel user.UserModel } func NewServiceContext(c config.Config) *ServiceContext { conn := sqlx.NewMysql(c.Mysql.DataSource) return \u0026amp;ServiceContext{ Config: c, UserModel: user.NewUserModel(conn, c.CacheRedis), Tagging: middleware.NewTaggingMiddleware().Handle, Version: middleware.NewVersionMiddleware().Handle, } } 4、启动测试\nhttp://127.0.0.1:8000/api/tags { \u0026ldquo;tag\u0026rdquo;: \u0026ldquo;tagV111\u0026ndash;v1.1.0\u0026rdquo; }\n全局中间件 userlogin/userlogin.go\nflag.Parse() var c config.Config conf.MustLoad(*configFile, \u0026amp;c) logx.MustSetup(c.LogConf) server := rest.MustNewServer(c.RestConf) defer server.Stop() // 全局中间件 server.Use(func(next http.HandlerFunc) http.HandlerFunc { return func(writer http.ResponseWriter, request *http.Request) { logx.Info(\u0026#34;global middleware\u0026#34;) next(writer, request) } }) ctx := svc.NewServiceContext(c) handler.RegisterHandlers(server, ctx) fmt.Printf(\u0026#34;Starting server at %s:%d...\\n\u0026#34;, c.Host, c.Port) server.Start() 链路追踪 go-zero 框架已实现了链路追踪，并且Jaeger， Zipkin 这两种链路追踪上报工具，只要简单配置就实现链路追踪。\n1、编辑配置文件 增加jaeger配置\nTelemetry: Name: user.api Endpoint: http://jaeger:14268/api/traces Sampler: 1.0 Batcher: jaeger 2、userlogin/internal/config/config.go 增加相应的映射\ntype Config struct { Telemetry trace.Config } 3、启动测试 访问 jaeger UI界面 http://127.0.0.1:5000/search 错误处理 在业务中还会定义一些业务性错误，常用做法都是通过 code、msg 两个字段来进行业务处理结果描述\n自定义错误 userlogin/common/errorx/baseerror.go package errorx const defaultCode = 1001 const DBErrorCode = 5001 type CodeError struct { Code int `json:\u0026#34;code\u0026#34;` Msg string `json:\u0026#34;msg\u0026#34;` } type CodeErrorResponse struct { Code int `json:\u0026#34;code\u0026#34;` Msg string `json:\u0026#34;msg\u0026#34;` } func NewCodeError(code int, msg string) error { return \u0026amp;CodeError{Code: code, Msg: msg} } func NewDefaultError(msg string) error { return NewCodeError(defaultCode, msg) } func (e *CodeError) Error() string { return e.Msg } func (e *CodeError) Data() *CodeErrorResponse { return \u0026amp;CodeErrorResponse{ Code: e.Code, Msg: e.Msg, } } 2、业务逻辑代码中替换为自定义错误 userlogin/internal/logic/loginlogic.go\nif err != nil { if err == user.ErrNotFound { return nil, errorx.NewDefaultError(\u0026#34;用户不存在\u0026#34;) } return nil, errorx.NewCodeError(errorx.DBErrorCode, err.Error()) } 3、开启自定义错误 userlogin/userlogin.go\nhttpx.SetErrorHandler(func(err error) (int, interface{}) { switch e := err.(type) { case *errorx.CodeError: return http.StatusOK, e.Data() default: return http.StatusInternalServerError, nil } }) 4、启动测试\n# curl -i -X POST http://127.0.0.1:8000/api/login -H \u0026#39;Content-Type: application/json\u0026#39; -d \u0026#39;{\u0026#34;email\u0026#34;:\u0026#34;notfound@gmail.com\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;****\u0026#34;}\u0026#39; HTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Traceparent: 00-d004fc85afc1bcb7f4cf6218de12e518-5eed79e06803e434-01 Date: Mon, 25 Jul 2022 14:07:02 GMT Content-Length: 37 {\u0026#34;code\u0026#34;:1001,\u0026#34;msg\u0026#34;:\u0026#34;用户不存在\u0026#34;} 自定义认证错误\ncurl -i -X GET \u0026lsquo;http://127.0.0.1:8000/api/userinfo\u0026rsquo;\nHTTP/1.1 401 Unauthorized Traceparent: 00-f1a3a6dee278d0aa8604c5eab2c276a3-f4a8de7774b93cf4-01 Date: Mon, 25 Jul 2022 14:11:32 GMT Content-Length: 0 修改代码 userlogin/userlogin.go\nunauthorized := rest.WithUnauthorizedCallback(func(w http.ResponseWriter, r *http.Request, err error) { httpx.WriteJson(w, http.StatusOK, errorx.NewCodeError(http.StatusUnauthorized, err.Error())) }) server := rest.MustNewServer(c.RestConf, unauthorized) 测试\nHTTP/1.1 200 OK Content-Type: application/json; charset=utf-8 Traceparent: 00-f136c8b772b717f394871d447c2ad0af-400e2c6cd45ab383-01 Date: Mon, 25 Jul 2022 14:09:46 GMT Content-Length: 48 {\u0026#34;code\u0026#34;:401,\u0026#34;msg\u0026#34;:\u0026#34;no token present in request\u0026#34;} "
},
{
	"uri": "http://blog.911015.com/grpc/",
	"title": "gRPC 快速体验",
	"tags": null,
	"description": "gRPC 是 Google 开发的一款高性能、开源的远程过程调用（RPC）框架。它使用 Protocol Buffers 作为接口定义语言（IDL），可以在多种编程语言和平台之间进行通信。",
	"content": "\rgRPC简介\rgRPC 是 Google 开发的一款高性能、开源的远程过程调用（RPC）框架。它使用 Protocol Buffers 作为接口定义语言（IDL），可以在多种编程语言和平台之间进行通信。\ngRPC 提供了强类型、高效、跨语言的服务定义和通信协议，并支持多种负载类型，包括 protobuf、JSON 和 XML。gRPC 可以使用 HTTP/2 协议进行双向流式传输，具有较低的网络延迟和带宽消耗，非常适合于分布式系统中的微服务架构。\ngRPC 支持四种服务模式：单项请求和响应、服务器流、客户端流和双向流，可以满足不同的业务需求。同时，gRPC 还提供了多种安全机制，包括基于 TLS 的身份验证和授权，以及基于 SSL/TLS 的连接加密和数据保护。\ngRPC 的优点包括：\n高效性：gRPC 使用二进制编码和压缩技术，比文本格式更高效。 可扩展性：gRPC 的 IDL 和多种 API 版本控制方式，使其易于维护和扩展。 跨语言性：gRPC 支持多种编程语言和平台之间的通信，包括 Java、Go、Python 等语言。 易用性：gRPC 可以与现有的工具和生态系统集成，如 Kubernetes、Prometheus、Jaeger 等。 一、Hello World 二、Streaming RPC 三、拦截器与Metadata 四、服务注册与发现 五、gRPC-Gateway 六、证书验证 "
},
{
	"uri": "http://blog.911015.com/grpc/02.html",
	"title": "二、Streaming RPC",
	"tags": null,
	"description": "gRPC 是 Google 开发的一款高性能、开源的远程过程调用（RPC）框架。它使用 Protocol Buffers 作为接口定义语言（IDL），可以在多种编程语言和平台之间进行通信。",
	"content": "gRPC调用方式 在gRPC中，一共包含四种调用方式。\nUnary RPC:一元RPC Server-side streaming RPC: 服务端流式RPC Client-side streaming RPC: 客户端流式RPC Bidirectional streaming RPC: 双向流式RPC Streaming RPC streaming RPC 适用于大数据包场景，可以进行实时交互；\n**服务端流式RPC **：客户端发起一次普通的RPC请求，服务端通过流式响应多次发送数据集，客户端Recv接收数据集 客户端流式RPC：客户端发起多次请求给服务端，而服务端仅响应客户端一次 双向流式RPC: 由客户端以流式请求服务端，服务端同样以流式响应客户端。\n代码实现 1、proto文件：创建proto文件定义三种流模式服务，执行protoc命令编译代码；\nsyntax = \u0026#34;proto3\u0026#34;; package pb; option go_package = \u0026#34;pb/;pb\u0026#34;; message Reply { string type = 1; string value = 2; } message Request { string type = 1; string value = 2; } service Streaming { rpc ServerStream (Request) returns (stream Reply); rpc ClientStream (stream Request) returns (Reply); rpc Bidirectional (stream Request) returns (stream Reply); } 2、server： 客户端流模式下 服务端手到 io._EOF时服务端需要通过 _stream.SendAndClose 向客户端返回；客户端 stream.CloseAndRecv 与之对应\nvar port string func init() { flag.StringVar(\u0026amp;port, \u0026#34;p\u0026#34;, \u0026#34;8000\u0026#34;, \u0026#34;启动端口号\u0026#34;) flag.Parse() } type StreamServer struct { pb.UnimplementedStreamingServer } func (ss StreamServer) ServerStream(in *pb.Request, stream pb.Streaming_ServerStreamServer) error { for i := 0; i \u0026lt; 20; i++ { err := stream.Send(\u0026amp;pb.Reply{Type: \u0026#34;Server-Side stream\u0026#34;, Value: fmt.Sprintf(\u0026#34;val:%d\u0026#34;, i)}) if err != nil { return err } } return nil } func (ss StreamServer) ClientStream(stream pb.Streaming_ClientStreamServer) error { for { recv, err := stream.Recv() if err == io.EOF { return stream.SendAndClose(\u0026amp;pb.Reply{ Type: \u0026#34;Client-Side stream\u0026#34;, Value: \u0026#34;close\u0026#34;, }) } if err != nil { return err } log.Printf(\u0026#34;%v\u0026#34;, recv) } } func (ss StreamServer) Bidirectional(stream pb.Streaming_BidirectionalServer) error { i := 0 for { _ = stream.Send(\u0026amp;pb.Reply{Type: \u0026#34;Bidirectional stream\u0026#34;, Value: fmt.Sprintf(\u0026#34;val:%d\u0026#34;, i)}) recv, err := stream.Recv() if err == io.EOF { return nil } if err != nil { return err } log.Printf(\u0026#34;%v\u0026#34;, recv) i++ } } func main() { server := grpc.NewServer() pb.RegisterStreamingServer(server, \u0026amp;StreamServer{}) reflection.Register(server) lis, _ := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:\u0026#34;+port) _ = server.Serve(lis) } 3、client ：未方便后面测试，通过参数 -m 启动不同流模式客户端；\nvar port string var method int func init() { flag.StringVar(\u0026amp;port, \u0026#34;p\u0026#34;, \u0026#34;8000\u0026#34;, \u0026#34;启动端口号\u0026#34;) flag.IntVar(\u0026amp;method, \u0026#34;m\u0026#34;, 1, \u0026#34;流模式\u0026#34;) flag.Parse() } func ServerStreamClient(client pb.StreamingClient, r *pb.Request) error { stream, err := client.ServerStream(context.Background(), r) if err != nil { return err } for { recv, err := stream.Recv() if err == io.EOF { break } if err != nil { return err } log.Printf(\u0026#34;response:%v\u0026#34;, recv) } return nil } func ClientStreamClient(client pb.StreamingClient) error { stream, err := client.ClientStream(context.Background()) if err != nil { return err } for i := 0; i \u0026lt; 10; i++ { _ = stream.Send(\u0026amp;pb.Request{Type: \u0026#34;ClientStreamClient\u0026#34;, Value: fmt.Sprintf(\u0026#34;val:%d\u0026#34;, i)}) } recv, err := stream.CloseAndRecv() log.Printf(\u0026#34;resp :%v\u0026#34;, recv) return err } func Bidirectional(client pb.StreamingClient) error { stream, err := client.Bidirectional(context.Background()) if err != nil { return err } for i := 0; i \u0026lt; 10; i++ { _ = stream.Send(\u0026amp;pb.Request{Type: \u0026#34;BidirectionalClient\u0026#34;, Value: fmt.Sprintf(\u0026#34;val:%d\u0026#34;, i)}) recv, err := stream.Recv() if err == io.EOF { break } if err != nil { log.Printf(\u0026#34;resp :%v\u0026#34;, err) return err } log.Printf(\u0026#34;resp :%v\u0026#34;, recv) } return stream.CloseSend() } func main() { conn, _ := grpc.Dial(\u0026#34;:\u0026#34;+port, grpc.WithTransportCredentials(insecure.NewCredentials())) defer conn.Close() log.Printf(\u0026#34;mothod %d\u0026#34;, method) client := pb.NewStreamingClient(conn) switch method { case 1: _ = ServerStreamClient(client, \u0026amp;pb.Request{Type: \u0026#34;ss client\u0026#34;, Value: \u0026#34;ok\u0026#34;}) case 2: _ = ClientStreamClient(client) case 3: _ = Bidirectional(client) default: log.Fatal(\u0026#34;error method\u0026#34;) } } 4、启动测试；\ngo run server.go go run client.go -m 1/2/3\n"
},
{
	"uri": "http://blog.911015.com/wx/2023052201.html",
	"title": "编程语言这么多怎么选？",
	"tags": null,
	"description": "编程语言这么多怎么选？Go、Java、PHP，Python还是C++？",
	"content": "Go Go是一种由Google开发的编程语言。其主要特点包括：\n静态类型：在编译时检查类型，可以提供更好的代码健壮性。 并发编程：支持Goroutines（轻量级线程）和Channels（通信机制），使并发编程变得简单。 内存管理：Go具有自动垃圾回收机制，可以减少内存泄漏问题。 Go的生态系统正在快速增长，有许多优秀的开源库和框架可供使用。它非常适合云原生应用的开发，如Docker等。较新的Web框架，例如Gin和Echo，也使Go在Web开发中越来越受欢迎。 在性能方面，Go比动态语言更快，但比C++等系统级语言稍慢。 Go的学习曲线较为平稳，对于具有其他编程经验的开发人员来说相对容易上手。\nPHP PHP是一种广泛用于Web开发的动态类型语言。其主要特点包括：\n动态类型：无需在编写代码时指定变量类型，使代码更加灵活。 便于Web开发：PHP具有许多与Web相关的函数和库，如文件上传、会话管理等。 面向对象编程：支持面向对象编程风格，使代码更加易于维护。 PHP生态系统非常丰富，包括许多流行的Web框架和CMS平台，例如Laravel和WordPress。这些工具可使Web开发更加高效。 在性能方面，PHP比静态语言慢，但可以通过各种缓存技术（如APC和OPcache）提高性能。 PHP学习曲线相对较低，因此非常适合初学者或那些想快速入门Web开发的人选择。\nJava Java是一种强类型的跨平台语言，并且具有以下特点：\n静态类型：在编译时检查类型，使代码更加健壮。 跨平台：Java字节码可以在任何支持Java的操作系统上运行。 面向对象编程：支持类和对象，使得代码更易于维护。 Java的生态系统非常丰富，涵盖了众多企业应用程序框架，例如Spring和Hibernate。这些框架可帮助开发人员快速构建稳健的企业级应用程序。 在性能方面，Java比动态语言快，但启动时间较长。 相对于其他语言，Java的学习曲线中等。因为它有一个强大的库和框架生态系统，需要一些时间来理解和掌握这些技术。\nPython Python是一种动态类型语言，用于各种用途，包括数据分析、机器学习、Web开发等。其主要特点包括：\n动态类型：无需在编写代码时指定变量类型，使代码更灵活。 简洁易读：Python具有清晰简单的语法，使得代码易于阅读和编写。 自然语言处理和数据科学：Python具有丰富的库和工具，如NumPy、pandas和scikit-learn等，使得数据科学工作变得更加容易。 Python生态系统非常丰富，包括许多科学计算库和Web框架，例如Django和Flask。Python也是自然语言处理领域的首选语言。 在性能方面，Python比静态语言慢，但对于普通计算任务而言，其代码实现更为容易。另外，Python可以通过JIT编译器（如PyPy）提高性能。 相对于其他语言，Python的学习曲线较浅，适合初学者或那些希望快速入门数据科学或Web开发的人选择。\nC++ C++是一种静态类型语言，常用于底层编程和高性能计算任务。其主要特点包括：\n静态类型：在编译时检查类型，可以提供更好的代码健壮性。 高性能：C++可以直接操作硬件，因此可以实现非常高效的代码。 底层编程：C++没有自动垃圾回收机制，使得程序员需要手动管理内存，并且可以进行指针操作等底层编程技术。 C++的生态系统虽然不如其他语言那么丰富，但它有许多优秀的基础设施库和跨平台工具，如Boost和Qt等。 在性能方面，C++是最快的语言之一，因为它可以直接操作硬件和内存。 相对于其他语言，C++的学习曲线较陡峭。它需要更多的时间和精力来掌握，因为它具有底层编程技术和复杂的内存管理要求。\n语言 语言特性 生态系统 性能 学习难度 Go 静态类型、并发编程、内存管理 快速增长的开源库和框架，适合云原生应用 比动态语言快，但比C++等系统级语言稍慢 中等 PHP 动态类型、便于Web开发、面向对象编程 丰富的Web生态系统，如WordPress 比静态语言慢，但可以通过各种缓存技术提高性能 简单 Java 静态类型、跨平台、面向对象编程 丰富的企业应用生态系统，如Spring、Hibernate等 比动态语言快，但启动时间较长 中等 Python 动态类型、简洁易读、自然语言处理、数据科学 丰富的科学计算生态系统，如NumPy、pandas、scikit-learn等 比静态语言慢，但普通计算任务易于实现 简单 C++ 静态类型、高性能、底层编程 丰富的基础设施生态系统，如Boost 最接近硬件的语言之一，性能最高 困难 总体而言，Go、Java和Python是比较流行的语言，它们都有丰富的生态系统，并且相对于C++来说学习难度较低。其中，Go具有出色的并发编程能力，适合云原生应用开发；Java是企业级开发的首选语言；Python则在数据科学和自然语言处理方面得到广泛应用。PHP则是一种简单易学的Web开发语言，而C++则适合底层编程和高性能计算任务。当然，选择哪种语言取决于具体的需求和项目要求。\n"
},
{
	"uri": "http://blog.911015.com/beginner/03.html",
	"title": "03-创建Go项目",
	"tags": null,
	"description": "",
	"content": "这是教程的第一部分，介绍了Go语言的一些基本功能。如果你刚开始使用Go语言，一定要看一下教程：Go入门，它介绍了Go命令、Go模块和非常简单的Go代码。 在本教程中，您将创建两个模块。第一种是用来被其他库或应用导入。第二个模块在程序中调用第一个模块的方法。 本教程包括七个小的部分：\n创建一个模块：编写一个小模块，其中包含可以从另一个模块调用的函数。 从另一个模块调用您的代码：导入并使用您的新模块。 返回并处理错误：添加简单的错误处理。 返回一个随机的问候语：处理切片（slices）中的数据（slices：Go的动态大小数组）。 为多个人返回问候语：将键/值对存储在映射（map）中。 添加测试：使用Go内置的单元测试功能来测试代码。 编译并安装应用程序：在本地编译并安装。 前期准备 一些编程经验。这里的代码非常简单，但了解函数、循环和数组会有所帮助。 用于编辑代码的工具。 一种命令终端。Go在Linux和Mac上以及Windows中的PowerShell或cmd上使用任何终端都能很好地工作。 开始创建模块 首先创建Go模块。我们通常会把一些包含同一类功能函数的包放在同一模块中，例如，您可以创建模块，模块的包具有进行财务分析的功能，以便其他编写财务应用程序的人可以使用您的代码。有关开发模块的更多信息，请参阅开发和发布模块.。 Go语言中 代码，包(package)，模块（module）之间的关系是:代码组成包，包组成模块。您开发的模块需要指定运行代码所需的依赖项，包括Go版本及其所需的其他模块。 当您在模块中添加或改进功能时，您将发布模块的新版本。编写调用这个模块的开发人员可以导入新版本模块，并在将其上线之前使用新版本进行测试。\n打开命令行，cd到home目录（或其他存放代码的目录） 新建目录 greetings 用来存放Go代码 使用 go mod init 命令初始化一个module 执行 go mod init 命令；本例中我们用 example.com/greetings；如果您发布模块，这必须是Go工具可以下载模块的路径，那就是本模块代码仓库的路径（例如：github.com/example）；\ngo mod init example.com/greetings # go: creating new go.mod: module example.com/greetings go mod init 命令创建一个go.mod文件来跟踪代码的依赖关系。到目前为止，该文件只包括模块的名称和代码支持的Go版本。但当你添加依赖项时，go.mod文件会列出你的代码所依赖的版本。这可以保持构建的可复制性，并让你直接控制要使用的模块版本。\n在编辑器中新建 greetings.go 文件 在greetings.go文件中写入一下代码并保存 package greetings import \u0026#34;fmt\u0026#34; // Hello returns a greeting for the named person. func Hello(name string) string { // Return a greeting that embeds the name in a message. message := fmt.Sprintf(\u0026#34;Hi, %v. Welcome!\u0026#34;, name) return message } 这是您的模块的第一个代码。它会向任何要求调用者返回问候语。下一步我们将调用此函数。 代码解读：\n声明greetings包存放相关的功能方法 实现Hello功能来返回问候语 此函数接受字符串类型的name参数。该函数返回一个字符串。在Go中，名称以大写字母开头的函数可以由不在同一个包中的函数调用。这在Go中被称为导出名称。 声明一个用于保存问候语的message变量 在Go中，:= 运算符是在一行中声明和初始化变量的快捷方式（Go使用右侧的值来确定变量的类型）。完整格式可以这样写：\nvar message string message = fmt.Sprintf(\u0026#34;Hi, %v. Welcome!\u0026#34;, name) 使用fmt包的Sprintf函数可以创建一条问候消息。第一个参数是一个格式字符串，Sprintf将name参数的值替换%v。插入name参数的值将完成问候语 将格式化的问候语文本返回给调用者 在下一步中，您将从另一个模块调用此函数。\n调用模块 在上一节中，您创建了一个greetings模块。在本节中，您将编写代码来调用刚刚编写的模块中的Hello函数。您将编写可执行的代码，并调用问候语模块中的代码。\n创建一个hello目录编写调用代码 创建此目录后，您应该在层次结构的同一级别同时拥有hello和greetings目录，如下所示：\n\u0026lt;home\u0026gt;/ |-- greetings/ |-- hello/ 为即将编写的代码启用依赖项跟踪。 go mod init example.com/hello 在文本编辑器的hello目录中，创建hello.go文件。 编写代码调用Hello函数，打印返回值。 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;example.com/greetings\u0026#34; ) func main() { // Get a greeting message and print it. message := greetings.Hello(\u0026#34;Gladys\u0026#34;) fmt.Println(message) } 代码解读：\n声明一个主程序包(main)。在Go中，作为应用程序执行的代码必须在主包中。 导入两个包：example.com/greetings和fmt包。这使您的代码可以访问这些包中的函数。导入example.com/greetings（包含在您之前创建的模块中的包）可以访问Hello函数。您还可以导入fmt，它具有处理输入和输出文本的功能（例如将文本打印到控制台）。 通过调用greetings包的Hello 方法来获得返回值。 编辑example.com/hello模块以使用本地example.com/hellos 在生产环境，Go工具可以从远程代码仓库中下载得到example.com/helles模块。目前，由于您尚未发布该模块，您需要调整example.com/hello模块的依赖关系，以便它可以在本地找到example.com/hellos代码。 用go mod edit命令编辑example.com/hello模块，将go工具从其模块路径（模块不在的地方）重定向到本地目录（模块所在的地方）。 a、在hello目录中的命令提示符下，运行以下命令\ngo mod edit -replace example.com/greetings=../greetings 该命令指定将依赖example.com/greetings应替换为/greetings。运行该命令后，hello目录中的go.mod文件应包含一个replace指令：\nmodule example.com/hello go 1.16 replace example.com/greetings =\u0026gt; ../greetings b、在hello目录中的命令提示符下，运行go mod tidy 命令来同步example.com/hello模块的依赖项，添加代码所需但尚未在模块中加载的依赖项。\n$ go mod tidy go: found example.com/greetings in example.com/greetings v0.0.0-00010101000000-000000000000 命令完成后，example.com/hello模块的go.mod文件应该如下所示：\nmodule example.com/hello go 1.16 replace example.com/greetings =\u0026gt; ../greetings require example.com/greetings v0.0.0-00010101000000-000000000000 该命令在greetings目录中找到了本地代码，然后添加了一个require指令，指定example.com/hello需要example.com/greetings。hello.go中导入greetings包时创建了此依赖项。 模块路径后面的数字是一个伪版本号,是自动生成的代替版本号的数字（模块实际还没有）。 要引用已发布的模块，go.mod文件通常会省略replace指令，并使用末尾带有标记版本号的require指令。\nrequire example.com/greetings v1.1.0 在hello目录中的命令提示符下，运行代码以确认它是否工作 $ go run . Hi, Gladys. Welcome! 恭喜！您已经编写了两个功能模块。在下节内容是错误处理。\n返回并处理错误 处理错误是健壮代码的一个基本特征。在本节中，您将添加一些代码，从greetings 模块返回一个错误，然后在调用者中进行处理。\n在 greetings/greetings.go 中添加代码: 如果你不知道该向谁打招呼，那么回电是没有意义的。如果name参数为空，则向调用方返回一个错误。\npackage greetings import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) // Hello returns a greeting for the named person. func Hello(name string) (string, error) { // If no name was given, return an error with a message. if name == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;empty name\u0026#34;) } // If a name was received, return a value that embeds the name // in a greeting message. message := fmt.Sprintf(\u0026#34;Hi, %v. Welcome!\u0026#34;, name) return message, nil } 代码解析：\n更改函数，使其返回两个值：一个string和一个error。调用者通过第二个返回值判断是否发生错误 (任何Go函数都可以返回多个值。有关更多信息，请参阅 Effective Go.) 导入Go标准库error包，使用 errors.New 函数。 添加if语句判断无效请求（name为空），如果请求无效则返回error。errors.New 函数返回一个错误，其中包含错误消息。 在成功返回中添加nil（表示没有错误）作为第二个返回值。这样，调用者就可以判断函数执行成功了。 在hello/hello.go文件中，处理hello函数返回的error以及非error值 将以下代码添加到hello.go。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;example.com/greetings\u0026#34; ) func main() { // Set properties of the predefined Logger, including // the log entry prefix and a flag to disable printing // the time, source file, and line number. log.SetPrefix(\u0026#34;greetings: \u0026#34;) log.SetFlags(0) // Request a greeting message. message, err := greetings.Hello(\u0026#34;\u0026#34;) // If an error was returned, print it to the console and // exit the program. if err != nil { log.Fatal(err) } // If no error was returned, print the returned message // to the console. fmt.Println(message) } 代码解析：\n将日志包配置为在其日志消息的开头打印命令名（“greetings：”），不带时间戳或源文件信息。 将两个Hello返回值（包括错误）分配给变量。 将Hello参数从Gladys的名称更改为空字符串，这样您就可以测试错误处理代码。判断 error 不等于 - nil，在这种情况下继续下去是没有意义。 使用标准库的log包中的函数来输出错误信息。如果出现错误，则使用日志包的Fatal函数打印错误并停止程序。 在hello目录的命令行中，运行hello.go以确认代码是否有效 $ go run . # greetings: empty name # exit status 1 这是Go中常见的错误处理：将错误作为值返回，以便调用方可以检查它。\n随机返回问候语 在本节中，您将更改代码，使其不再每次返回一个问候语，而是返回几个预定义的问候语消息中的一个。 为此，您将使用Go切片(slice)。切片就像一个数组，只是它的大小随着添加和删除项目而动态变化。切片是Go语言最有用的类型之一。 添加一个slice 存放三条问候消息，然后让代码随机返回其中一条消息。\n在问候语/问候语.go中，更改代码，如下 package greetings import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) // Hello returns a greeting for the named person. func Hello(name string) (string, error) { // If no name was given, return an error with a message. if name == \u0026#34;\u0026#34; { return name, errors.New(\u0026#34;empty name\u0026#34;) } // Create a message using a random format. message := fmt.Sprintf(randomFormat(), name) return message, nil } // init sets initial values for variables used in the function. func init() { rand.Seed(time.Now().UnixNano()) } // randomFormat returns one of a set of greeting messages. The returned // message is selected at random. func randomFormat() string { // A slice of message formats. formats := []string{ \u0026#34;Hi, %v. Welcome!\u0026#34;, \u0026#34;Great to see you, %v!\u0026#34;, \u0026#34;Hail, %v! Well met!\u0026#34;, } // Return a randomly selected message format by specifying // a random index for the slice of formats. return formats[rand.Intn(len(formats))] } 代码解析：\n添加一个randomFormat函数，该函数可为问候语返回随机选择的格式。请注意，randomFormat以小写字母开头，使其只能由自己包中的代码访问（换句话说，它不导出）。 在randomFormat中，用三种消息格式声明一个formats切片。在声明切片时，可以省略括号中的大小，如下所示：[]string。这告诉Go，片下面的数组大小可以动态更改。 使用math/rand包生成一个随机数，用于从切片(slice)中选择项目。 添加一个init函数，用当前时间为rand包设定种子。Go在初始化全局变量后，在程序启动时自动执行init函数。 在Hello中，调用randomFormat函数来获取要返回的消息的格式，然后将格式和名称值一起使用来创建消息。 像以前一样返回消息（或错误）。 在hello/hello.go中，更改代码，如下所示。 只将Gladys的名字（或者其他名字，如果您愿意的话）作为参数添加到Hello.go中的Hello函数调用中。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;example.com/greetings\u0026#34; ) func main() { // Set properties of the predefined Logger, including // the log entry prefix and a flag to disable printing // the time, source file, and line number. log.SetPrefix(\u0026#34;greetings: \u0026#34;) log.SetFlags(0) // Request a greeting message. message, err := greetings.Hello(\u0026#34;Gladys\u0026#34;) // If an error was returned, print it to the console and // exit the program. if err != nil { log.Fatal(err) } // If no error was returned, print the returned message // to the console. fmt.Println(message) } 在hello目录的命令行中，运行hello.go以确认代码是否有效。多次运行它，注意问候语变化。 $ go run . Great to see you, Gladys! $ go run . Hi, Gladys. Welcome! $ go run . Hail, Gladys! Well met! 为多人回复问候 在您将对模块代码进行的最后一次更改中，您将添加对在一个请求中获得多人问候的支持。换句话说，您将处理多值输入，然后将该输入中的值与多值输出配对。要做到这一点，您需要将一组名称传递给一个函数，该函数可以为每个名称返回一个问候语。 但有一个问题。将Hello函数的参数从单个名称更改为一组名称将更改函数的签名。如果您已经发布了example.com/greetings模块，并且用户已经编写了调用Hello的代码，那么这种更改将破坏他们的程序。 在这种情况下，更好的选择是用不同的名称编写一个新函数。新功能将采用多个参数。这保留了旧功能以实现向后兼容性。\n在greetings/greetings.go中，更改代如下所示。 package greetings import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;time\u0026#34; ) // Hello returns a greeting for the named person. func Hello(name string) (string, error) { // If no name was given, return an error with a message. if name == \u0026#34;\u0026#34; { return name, errors.New(\u0026#34;empty name\u0026#34;) } // Create a message using a random format. message := fmt.Sprintf(randomFormat(), name) return message, nil } // Hellos returns a map that associates each of the named people // with a greeting message. func Hellos(names []string) (map[string]string, error) { // A map to associate names with messages. messages := make(map[string]string) // Loop through the received slice of names, calling // the Hello function to get a message for each name. for _, name := range names { message, err := Hello(name) if err != nil { return nil, err } // In the map, associate the retrieved message with // the name. messages[name] = message } return messages, nil } // Init sets initial values for variables used in the function. func init() { rand.Seed(time.Now().UnixNano()) } // randomFormat returns one of a set of greeting messages. The returned // message is selected at random. func randomFormat() string { // A slice of message formats. formats := []string{ \u0026#34;Hi, %v. Welcome!\u0026#34;, \u0026#34;Great to see you, %v!\u0026#34;, \u0026#34;Hail, %v! Well met!\u0026#34;, } // Return one of the message formats selected at random. return formats[rand.Intn(len(formats))] } 代码解析:\n添加一个Hellos函数，该函数的参数是名称slice，而不是一个单独的名称。此外，您还可以将其返回类型从字符串更改为map，以便返回名称与问候语的映射。 让新的Hellos函数调用现有的Hello函数。这有助于减少重复，同时保留两个功能。 创建一个map 变量messages，将每个接收到的名称（作为key）与生成的消息（作为Value）关联起来。Go中可以使用以下语法初始化映射：make（map[key-type]value-type）。您可以使用Hellos函数将此映射返回给调用者。 循环查看函数接收到的names，检查每个name是否都有非空值，然后将消息与每个名称关联起来。在这个for循环中，range返回两个值：循环中当前项的索引和项值的副本。索引值用不到，用Go blank标识符（下划线）来忽略它。 在hello/hello.go调用代码中，传入names 切片，然后打印返回的name/message映射的内容。 在hello.go中，更改代码，如下所示。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;example.com/greetings\u0026#34; ) func main() { // Set properties of the predefined Logger, including // the log entry prefix and a flag to disable printing // the time, source file, and line number. log.SetPrefix(\u0026#34;greetings: \u0026#34;) log.SetFlags(0) // A slice of names. names := []string{\u0026#34;Gladys\u0026#34;, \u0026#34;Samantha\u0026#34;, \u0026#34;Darrin\u0026#34;} // Request greeting messages for the names. messages, err := greetings.Hellos(names) if err != nil { log.Fatal(err) } // If no error was returned, print the returned map of // messages to the console. fmt.Println(messages) } 代码解析:\n创建一个names 切片，包含三个name。 将names变量作为参数传递给Hellos函数。 在命令行中，切换到包含hello/hello.go的目录，然后使用go run确认代码是否有效。 输出应该是将name与message关联起来的map，如下所示：\n$ go run . map[Darrin:Hail, Darrin! Well met! Gladys:Hi, Gladys. Welcome! Samantha:Hail, Samantha! Well met!] 本主题介绍了用于表示名称/值对的映射。它还引入了通过为模块中的新功能或更改的功能实现新功能来保持向后兼容性的想法。\n添加测试 现在您已经将代码放到了一个固定的位置，添加一个测试。在开发过程中测试代码可能会暴露出在您进行更改时出现的错误。在本章节中，您将为 Hello 函数添加一个测试。 Go 内置的对单元测试的支持使得在进行测试时更容易。具体来说，使用命名约定、Go 的 testing 包和 Go test 命令，您可以快速编写和执行测试。\n在 greetings 目录中，创建一个名为 greetings_test.go 的文件。 以_test.go 结尾的文件名告诉 go test 命令此文件包含测试函数。\n在 greeting_test.go 中，添加以下代码并保存文件。 package greetings import ( \u0026#34;testing\u0026#34; \u0026#34;regexp\u0026#34; ) // TestHelloName calls greetings.Hello with a name, checking // for a valid return value. func TestHelloName(t *testing.T) { name := \u0026#34;Gladys\u0026#34; want := regexp.MustCompile(`\\b`+name+`\\b`) msg, err := Hello(\u0026#34;Gladys\u0026#34;) if !want.MatchString(msg) || err != nil { t.Fatalf(`Hello(\u0026#34;Gladys\u0026#34;) = %q, %v, want match for %#q, nil`, msg, err, want) } } // TestHelloEmpty calls greetings.Hello with an empty string, // checking for an error. func TestHelloEmpty(t *testing.T) { msg, err := Hello(\u0026#34;\u0026#34;) if msg != \u0026#34;\u0026#34; || err == nil { t.Fatalf(`Hello(\u0026#34;\u0026#34;) = %q, %v, want \u0026#34;\u0026#34;, error`, msg, err) } } 代码解析:\n在与您正在测试的代码相同的包中实现测试函数。 创建两个测试函数来测试 greetings.Hello 函数。测试函数名称的形式为 TestName，其中 Name 表示特定测试的内容。此外，测试函数将指向测试包的 testing.T 类型的指针作为参数。您可以使用此参数的方法从测试中进行报告和日志记录。 执行两次测试 TestHelloName 调用 Hello 函数，传递一个名称值，该函数应该能够使用该名称值返回有效的响应消息。如果调用返回错误或意外响应消息（其中不包括您传入的名称），则使用 t 参数的 Fatalf 方法将消息打印到控制台并结束执行。 TestHelloEmpty 使用一个空字符串调用 Hello 函数。此测试旨在确认您的错误处理是否有效。如果调用返回非空字符串或没有错误，则使用 t 参数的 Fatalf 方法将消息打印到控制台并结束执行。 在问候目录的命令行中，运行 go test 命令来执行测试。 go test 命令在测试文件（名称以\\test.go 结尾）中执行测试函数（名称以 test 开头）。您可以添加-v 标志来获得详细的输出，其中列出了所有测试及其结果。 $ go test PASS ok example.com/greetings 0.364s $ go test -v === RUN TestHelloName --- PASS: TestHelloName (0.00s) === RUN TestHelloEmpty --- PASS: TestHelloEmpty (0.00s) PASS ok example.com/greetings 0.372s 打断 greetings.Hello 函数用于查看未通过的测试。 TestHelloName 测试函数检查您指定为 Hello 函数参数的名称的返回值。要查看失败的测试结果，请更改 greetings.Hello 函数，使其不再包含名称。 在 greetings/greetings.go 中，粘贴以下代码来代替 Hello 函数。请注意，高亮显示的行会更改函数返回的值，就好像名称参数被意外删除了一样。 // Hello returns a greeting for the named person. func Hello(name string) (string, error) { // If no name was given, return an error with a message. if name == \u0026#34;\u0026#34; { return name, errors.New(\u0026#34;empty name\u0026#34;) } // Create a message using a random format. // message := fmt.Sprintf(randomFormat(), name) message := fmt.Sprint(randomFormat()) return message, nil } 在 greetings 目录的命令行中，运行 go test 来执行测试。 这一次，在没有-v 标志的情况下运行 go test。输出将只包括失败测试的结果，当您有很多测试时，这可能很有用。TestHelloName 测试应该失败—— TestHelloEmpty 仍然通过。 $ go test --- FAIL: TestHelloName (0.00s) greetings_test.go:15: Hello(\u0026#34;Gladys\u0026#34;) = \u0026#34;Hail, %v! Well met!\u0026#34;, \u0026lt;nil\u0026gt;, want match for `\\bGladys\\b`, nil FAIL exit status 1 FAIL example.com/greetings 0.182s 编译并安装应用 在最后一个主题中，您将学习几个新的 go 命令。虽然 go run 命令是在频繁更改时编译和运行程序的有用快捷方式，但它不会生成二进制可执行文件。\n本主题介绍了用于构建代码的两个附加命令:\ngo-build 命令编译包及其依赖项，但不安装结果。 go install 命令编译并安装程序包。 在 hello 目录的命令行中，运行 go build 命令将代码编译为可执行文件。 $ go build 在 hello 目录中的命令行中，运行新的 hello 可执行文件以确认代码是否有效。 请注意，您的结果可能会有所不同，这取决于您在测试后是否更改了 greetings.go 代码。 Linux or Mac: $ ./hello map[Darrin:Great to see you, Darrin! Gladys:Hail, Gladys! Well met! Samantha:Hail, Samantha! Well met!] On Windows: $ hello.exe map[Darrin:Great to see you, Darrin! Gladys:Hail, Gladys! Well met! Samantha:Hail, Samantha! Well met!] 您已将应用程序编译为可执行文件，以便运行它。但要当前运行它，您的提示需要位于可执行文件的目录中，或者指定可执行文件路径。 接下来，您将安装可执行文件，这样您就可以在不指定其路径的情况下运行它。\n查找 Go 安装路径，Go 命令将在其中安装当前软件包。 您可以通过运行 go list 命令来发现安装路径，如以下示例所示： $ go list -f \u0026#39;{{.Target}}\u0026#39; 例如，命令的输出可能会说/home/gopher/bin/hello，这意味着二进制文件被安装到/home/gopaher/bin。在下一步中，您将需要此安装目录。\n将 Go 安装目录添加到系统的 shell 路径 这样，您就可以运行程序的可执行文件，而无需指定可执行文件的位置。 在 Linux 或 Mac 上，运行以下命令:\n$ export PATH=$PATH:/path/to/your/install/directory 在 Windows, 运行以下命令:\n$ set PATH=%PATH%;C:\\path\\to\\your\\install\\directory 另一种选择是，如果您的 shell 路径中已经有一个类似$HOME/bin 的目录，并且您想在那里安装 Go 程序，则可以使用 Go-env 命令设置 GOBIN 变量来更改安装目标：\n$ go env -w GOBIN=/path/to/your/bin # or $ go env -w GOBIN=C:\\path\\to\\your\\bin 更新完 shell 路径后，运行 go install 命令来编译和安装包。 $ go install 只需输入应用程序的名称即可运行应用程序。为了让这变得有趣，打开一个新的命令提示符，并在其他目录中运行 hello 可执行文件名。 $ hello map[Darrin:Hail, Darrin! Well met! Gladys:Great to see you, Gladys! Samantha:Hail, Samantha! Well met!] "
},
{
	"uri": "http://blog.911015.com/tour/03.html",
	"title": "3、基础篇（三）：更多类型: struct, slices, 和 map",
	"tags": null,
	"description": "基础篇（三）：更多类型: struct, slices, 和 map",
	"content": "指针 Go提供了指针类型。指针保存的是一个值的内存地址。 类型*T是指向T值的指针。它的零值为nil。\nvar p *int \u0026amp;运算符生成指向其操作数的指针。\ni := 42 p = \u0026amp;i *运算符表示指针的基本值。\nfmt.Println(*p) // read i through the pointer p *p = 21 // set i through the pointer p 与C不同，Go没有指针运算。\npackage main import \u0026#34;fmt\u0026#34; func main() { i, j := 42, 2701 p := \u0026amp;i // point to i fmt.Println(*p) // read i through the pointer *p = 21 // set i through the pointer fmt.Println(i) // see the new value of i p = \u0026amp;j // point to j *p = *p / 37 // divide j through the pointer fmt.Println(j) // see the new value of j } 结构体（Structs） 结构体是字段的集合。使用点访问结构字段。\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { X int Y int } func main() { fmt.Println(Vertex{1, 2}) v := Vertex{1, 2} v.X = 4 fmt.Println(v.X) } 结构体指针 可以通过结构指针访问结构字段。\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { X int Y int } func main() { v := Vertex{1, 2} p := \u0026amp;v p.X = 1e9 fmt.Println(v) } 当我们通过结构指针p访问结构的字段X，可以这样写（*p）.X。然而，这种表示法很麻烦，所以Go语言允许我们只写p.X，而不显式解引用。\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { X, Y int } var ( v1 = Vertex{1, 2} // has type Vertex v2 = Vertex{X: 1} // Y:0 is implicit v3 = Vertex{} // X:0 and Y:0 p = \u0026amp;Vertex{1, 2} // has type *Vertex ) func main() { fmt.Println(v1, p, v2, v3) } 结构字面量通过设置其字段的值来表示新分配的结构值。您可以使用 Name: 语法设置部分字段的值。（命名字段的顺序无关紧要。） 特殊前缀\u0026amp;返回一个指向结构值的指针。\nArrays 类型[n]T是n个类型为T的值的数组。 表达式 ：\nvar a [10]int 将变量a声明为一个由十个整数组成的数组。 数组的长度是其类型的一部分，因此无法调整数组的大小。这似乎有局限性，但不要担心；Go提供了一种使用数组的方便方法。\npackage main import \u0026#34;fmt\u0026#34; func main() { var a [2]string a[0] = \u0026#34;Hello\u0026#34; a[1] = \u0026#34;World\u0026#34; fmt.Println(a[0], a[1]) fmt.Println(a) primes := [6]int{2, 3, 5, 7, 11, 13} fmt.Println(primes) } Slices 数组具有固定的大小。切片是动态数组。在实践中，切片比数组更常见。类型[]T是具有类型T的元素的slice 。切片是通过指定两个索引来形成的，一个是由冒号分隔的下界和上界：a[low : high] 这会截取一个包括第一个元素（low ）但不包括最后一个元素（high）的slice。 以下表达式创建一个切片，该切片包括的元素1到3：a[1:4]\npackage main import \u0026#34;fmt\u0026#34; func main() { primes := [6]int{2, 3, 5, 7, 11, 13} var s []int = primes[1:4] fmt.Println(s) } 切片类似于对数组的引用 切片不存储任何数据，它只描述底层数组的一部分。更改切片的元素会修改其底层数组的相应元素。共享相同底层阵列的其他切片将看到这些变化。\npackage main import \u0026#34;fmt\u0026#34; func main() { names := [4]string{ \u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;, \u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;, } fmt.Println(names) a := names[0:2] b := names[1:3] fmt.Println(a, b) b[0] = \u0026#34;XXX\u0026#34; fmt.Println(a, b) fmt.Println(names) } Slice字面量 切片就像一个没有长度的数组。 这是一个数组：\n[]bool{true, true, false} 这会创建与上面相同的数组，然后构建一个引用它的切片：\n[]bool{true, true, false} package main import \u0026#34;fmt\u0026#34; func main() { q := []int{2, 3, 5, 7, 11, 13} fmt.Println(q) r := []bool{true, false, true, true, false, true} fmt.Println(r) s := []struct { i int b bool }{ {2, true}, {3, false}, {5, true}, {7, true}, {11, false}, {13, true}, } fmt.Println(s) } Slice 默认值 使用切片时，可以省略上限或下限，而使用它们的默认值。对于下限，默认为零，对于上限，默认为切片长度。 对数组 var a [10]int，这些切片表达式是等效的：\na[0:10] a[:10] a[0:] a[:] package main import \u0026#34;fmt\u0026#34; func main() { s := []int{2, 3, 5, 7, 11, 13} s = s[1:4] fmt.Println(s) s = s[:2] fmt.Println(s) s = s[1:] fmt.Println(s) } slice长度和容量 切片既有长度也有容量。切片的长度是它包含的元素个数。片的容量是底层数组中的元素数，从切片中的第一个元素开始计数。切片的长度和容量s可以使用表达式len（s）和cap（s）来获得。\npackage main import \u0026#34;fmt\u0026#34; func main() { s := []int{2, 3, 5, 7, 11, 13} printSlice(s) // Slice the slice to give it zero length. s = s[:0] printSlice(s) // Extend its length. s = s[:4] printSlice(s) // Drop its first two values. s = s[2:] printSlice(s) } func printSlice(s []int) { fmt.Printf(\u0026#34;len=%d cap=%d %v\\n\u0026#34;, len(s), cap(s), s) } 您可以通过重新切片来延长切片的长度，前提是它有足够的容量。尝试更改示例程序中的一个切片操作，以将其扩展到其容量之外，然后看看会发生什么。\nSlice零值 切片的零值为nil。值位nil的切片长度和容量为0，并且没有底层数组。\npackage main import \u0026#34;fmt\u0026#34; func main() { var s []int fmt.Println(s, len(s), cap(s)) if s == nil { fmt.Println(\u0026#34;nil!\u0026#34;) } } 使用make创建切片 切片可以使用内置的make函数创建；这就是创建动态大小数组的方法。make函数分配一个空数组，并返回一个引用该数组的切片：\na := make([]int, 5) // len(a)=5 要指定容量，请传递make函数的第三个参数以：\nb := make([]int, 0, 5) // len(b)=0, cap(b)=5 b = b[:cap(b)] // len(b)=5, cap(b)=5 b = b[1:] // len(b)=4, cap(b)=4 package main import \u0026#34;fmt\u0026#34; func main() { a := make([]int, 5) printSlice(\u0026#34;a\u0026#34;, a) b := make([]int, 0, 5) printSlice(\u0026#34;b\u0026#34;, b) c := b[:2] printSlice(\u0026#34;c\u0026#34;, c) d := c[2:5] printSlice(\u0026#34;d\u0026#34;, d) } func printSlice(s string, x []int) { fmt.Printf(\u0026#34;%s len=%d cap=%d %v\\n\u0026#34;, s, len(x), cap(x), x) } 二维slice 切片可以包含任何类型，包括其他切片。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { // Create a tic-tac-toe board. board := [][]string{ []string{\u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;}, []string{\u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;}, []string{\u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;_\u0026#34;}, } // The players take turns. board[0][0] = \u0026#34;X\u0026#34; board[2][2] = \u0026#34;O\u0026#34; board[1][2] = \u0026#34;X\u0026#34; board[1][0] = \u0026#34;O\u0026#34; board[0][2] = \u0026#34;X\u0026#34; for i := 0; i \u0026lt; len(board); i++ { fmt.Printf(\u0026#34;%s\\n\u0026#34;, strings.Join(board[i], \u0026#34; \u0026#34;)) } } Append 将新元素附加到切片中是很常见的，因此Go提供了一个内置函数append 。\nfunc append(s []T, vs ...T) []T //append的第一个参数s是T类型的切片，其余的是要附加到切片的T值。 append的结果值是一个切片，包含原始切片的所有元素加上提供的值。 如果s的底层数组太小，无法容纳所有给定的值，则会分配一个更大的数组。返回的切片将指向新分配的数组。\npackage main import \u0026#34;fmt\u0026#34; func main() { var s []int printSlice(s) // append works on nil slices. s = append(s, 0) printSlice(s) // The slice grows as needed. s = append(s, 1) printSlice(s) // We can add more than one element at a time. s = append(s, 2, 3, 4) printSlice(s) } func printSlice(s []int) { fmt.Printf(\u0026#34;len=%d cap=%d %v\\n\u0026#34;, len(s), cap(s), s) } Range for循环的range形式在切片或映射上进行迭代。在切片上进行遍历时，每次迭代都会返回两个值。第一个是索引，第二个是该索引处元素的副本。\npackage main import \u0026#34;fmt\u0026#34; var pow = []int{1, 2, 4, 8, 16, 32, 64, 128} func main() { for i, v := range pow { fmt.Printf(\u0026#34;2**%d = %d\\n\u0026#34;, i, v) } } 您可以用 _ 来跳过索引或值。如果只需要索引，可以省略第二个变量。\nfor i, _ := range pow for _, value := range pow for i := range pow package main import \u0026#34;fmt\u0026#34; func main() { pow := make([]int, 10) for i := range pow { pow[i] = 1 \u0026lt;\u0026lt; uint(i) // == 2**i } for _, value := range pow { fmt.Printf(\u0026#34;%d\\n\u0026#34;, value) } } 练习：切片 实现 Pic函数.它应该返回一个长度为dy的切片，其中的每个元素都是dx 8位无符号整数的切片. 当你运行该程序时, 它将显示您的图片，将整数解释为灰度值. 图像的选择取决于您。有趣的函数包括（x+y）/2、x*y和x^y 您需要使用一个循环来分配[][]uint8中的每个[]uint8。 (使用uint8（intValue）在类型之间进行转换。)\n一下代码仅供参考\npackage main import \u0026#34;golang.org/x/tour/pic\u0026#34; func Pic(dx, dy int) [][]uint8 { total := make([]uint8, dx*dy) res := make([][]uint8, dx) for x := 0; x \u0026lt; dx; x++ { res[x], total = total[0:dy], total[dy:] for y := 0; y \u0026lt; dy; y++ { res[x][y] = uint8(x * y) } } return res } func main() { pic.Show(Pic) } Maps Map 是键值对的映射 map的零值为nil。nil map 没有key，也不能向其添加key。 make函数返回给定类型的map，该map已初始化并可以使用。\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { Lat, Long float64 } var m map[string]Vertex func main() { m = make(map[string]Vertex) m[\u0026#34;Bell Labs\u0026#34;] = Vertex{ 40.68433, -74.39967, } fmt.Println(m[\u0026#34;Bell Labs\u0026#34;]) } map 赋值与结构赋值类似，但key是必需的。\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { Lat, Long float64 } var m = map[string]Vertex{ \u0026#34;Bell Labs\u0026#34;: Vertex{ 40.68433, -74.39967, }, \u0026#34;Google\u0026#34;: Vertex{ 37.42202, -122.08408, }, } func main() { fmt.Println(m) } 如果顶级类型只是一个类型名称，则可以从赋值的元素中省略它。\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { Lat, Long float64 } var m = map[string]Vertex{ \u0026#34;Bell Labs\u0026#34;: {40.68433, -74.39967}, \u0026#34;Google\u0026#34;: {37.42202, -122.08408}, } func main() { fmt.Println(m) } 修改map package main import \u0026#34;fmt\u0026#34; func main() { m := make(map[string]int) m[\u0026#34;Answer\u0026#34;] = 42 fmt.Println(\u0026#34;The value:\u0026#34;, m[\u0026#34;Answer\u0026#34;]) m[\u0026#34;Answer\u0026#34;] = 48 fmt.Println(\u0026#34;The value:\u0026#34;, m[\u0026#34;Answer\u0026#34;]) delete(m, \u0026#34;Answer\u0026#34;) fmt.Println(\u0026#34;The value:\u0026#34;, m[\u0026#34;Answer\u0026#34;]) v, ok := m[\u0026#34;Answer\u0026#34;] fmt.Println(\u0026#34;The value:\u0026#34;, v, \u0026#34;Present?\u0026#34;, ok) } 在map m中插入或更新元素：\nm[key] = elem 查找元素：\nelem = m[key] 删除元素：\ndelete(m, key) 通过接收第二个参数测试是否存在对应的key：\nelem, ok = m[key] 若key在m中，则ok为true。否则ok为false。 若key不在map中，则elem是map元素类型的零值。 注意：如果尚未声明elem或ok，则可以使用简短的声明形式：\nelem, ok := m[key] 练习：map 实现WordCount。它应该返回字符串s中每个“单词”计数的map。wc.Test函数针对所提供的函数运行一个测试套件，并打印成功或失败。你可能会用到 strings.Fields。 一下代码仅供参考\npackage main import ( \u0026#34;strings\u0026#34; \u0026#34;golang.org/x/tour/wc\u0026#34; ) func WordCount(s string) map[string]int { res := make(map[string]int) words := strings.Fields(s) for _, word := range words { res[word]++ } return res } func main() { wc.Test(WordCount) } 函数类型 函数也是值。它们可以像其他值一样传递。函数值可以用作函数参数和返回值。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) func compute(fn func(float64, float64) float64) float64 { return fn(3, 4) } func main() { hypot := func(x, y float64) float64 { return math.Sqrt(x*x + y*y) } fmt.Println(hypot(5, 12)) fmt.Println(compute(hypot)) fmt.Println(compute(math.Pow)) } 函数闭包 Go函数可能是闭包。闭包是一个函数值，它引用来自其主体外部的变量。函数可以访问并分配给引用的变量；从这个意义上说，函数是“绑定”到变量的。例如，addr函数返回一个闭包。每个闭包都绑定到它自己的sum变量。\npackage main import \u0026#34;fmt\u0026#34; func adder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } func main() { pos, neg := adder(), adder() for i := 0; i \u0026lt; 10; i++ { fmt.Println( pos(i), neg(-2*i), ) } } 练习：斐波那契闭包 让我们玩一下function。 实现一个fibonacci函数，它返回一个函数（闭包），该函数返回连续的fibonacci数（0，1，1，2，3，5，…）。 一下代码仅供参考\npackage main import \u0026#34;fmt\u0026#34; // fibonacci is a function that returns // a function that returns an int. func fibonacci() func() int { var pre,cur = 0,0 return func()int{ temp := cur cur = pre+cur pre = temp if cur == 0 { cur = 1 return 0 } return temp } } func fibonacci1() func() int { var pre, cur, idx = 0, 1, -1 return func() int { idx++ if idx \u0026lt;= 1 { return idx } temp := cur cur = pre + cur pre = temp return cur } } func main() { f := fibonacci() for i := 0; i \u0026lt; 10; i++ { fmt.Println(f()) } } "
},
{
	"uri": "http://blog.911015.com/go-zero/03.html",
	"title": "go-zero 单体应用实践（三）",
	"tags": null,
	"description": "单体应用实践",
	"content": "列表数据分页 1、api 定义 Pager api 可以单独一个文件；此时 userlogin.api 需要 import \u0026ldquo;api/pager.api\u0026rdquo;\nPager { Page int `form:\u0026#34;page,default=1\u0026#34;` PageSize int `form:\u0026#34;page_size,default=10\u0026#34;` TotalSize int `form:\u0026#34;total_size,default=0\u0026#34;` } TagListRequest { Name string `form:\u0026#34;name,optional\u0026#34;` Pager } TagListResponse { List []TagResponse `json:\u0026#34;list\u0026#34;` Matedata Pager `json:\u0026#34;matedata\u0026#34;` } service userlogin-api { @handler Tags get /api/tag/list(TagListRequest) returns (TagListResponse) } 2、model 文件：BlogTagModel增加TageList方法；同时 customBlogTagModel.TagList 实现具体逻辑\nBlogTagModel interface { blogTagModel TagList(context.Context, *types.TagListRequest) (*types.TagListResponse, error) } func (c *customBlogTagModel) TagList(ctx context.Context, request *types.TagListRequest) (*types.TagListResponse, error) { result := \u0026amp;types.TagListResponse{} pager := request.Pager countSql := fmt.Sprintf(\u0026#34;select %s from %s where 1 \u0026#34;, \u0026#34;count(id) as total_size\u0026#34;, c.table) _ = c.QueryRowNoCacheCtx(ctx, \u0026amp;pager.TotalSize, countSql) result.Matedata = pager where := \u0026#34;1 \u0026#34; var err error if len(request.Name) \u0026gt; 0 { where += \u0026#34;AND name=? \u0026#34; sql := fmt.Sprintf(\u0026#34;select %s from %s where %s limit %d,%d\u0026#34;, blogTagRows, c.table, where, (pager.Page-1)*pager.PageSize, request.PageSize) err = c.QueryRowsNoCacheCtx(ctx, \u0026amp;result.List, sql, request.Name) } else { sql := fmt.Sprintf(\u0026#34;select %s from %s where %s limit %d,%d\u0026#34;, blogTagRows, c.table, where, (pager.Page-1)*pager.PageSize, request.PageSize) err = c.QueryRowsNoCacheCtx(ctx, \u0026amp;result.List, sql) } switch err { case nil: return result, nil case sqlc.ErrNotFound: return nil, ErrNotFound default: return nil, err } } 3、logic 文件编辑\nfunc (l *TagsLogic) Tags(req *types.TagListRequest) (resp *types.TagListResponse, err error) { return l.svcCtx.TagsModel.TagList(l.ctx, req) } 4、测试 http://127.0.0.1:8000/api/tag/list?page=2\u0026amp;page_size=5\n{ \u0026#34;list\u0026#34;: [ { \u0026#34;id\u0026#34;: 6, \u0026#34;name\u0026#34;: \u0026#34;python\u0026#34;, \u0026#34;state\u0026#34;: 1 }, { \u0026#34;id\u0026#34;: 7, \u0026#34;name\u0026#34;: \u0026#34;rust\u0026#34;, \u0026#34;state\u0026#34;: 1 }, { \u0026#34;id\u0026#34;: 8, \u0026#34;name\u0026#34;: \u0026#34;typescript\u0026#34;, \u0026#34;state\u0026#34;: 1 } ], \u0026#34;matedata\u0026#34;: { \u0026#34;Page\u0026#34;: 2, \u0026#34;PageSize\u0026#34;: 5, \u0026#34;TotalSize\u0026#34;: 8 } } "
},
{
	"uri": "http://blog.911015.com/go-zero/",
	"title": "go-zero应用实践",
	"tags": null,
	"description": "go-zero 是一个集成了各种工程实践的 web 和 rpc 框架",
	"content": "\r文档简介\rgo-zero 是一个集成了各种工程实践的 web 和 rpc 框架。通过弹性设计保障了大并发服务端的稳定性，经受了充分的实战检验。\ngo-zero 包含极简的 API 定义和生成工具 goctl，可以根据定义的 api 文件一键生成 Go, iOS, Android, Kotlin, Dart, TypeScript, JavaScript 代码，并可直接运行。\n使用 go-zero 的好处：\n轻松获得支撑千万日活服务的稳定性 内建级联超时控制、限流、自适应熔断、自适应降载等微服务治理能力，无需配置和额外代码 微服务治理中间件可无缝集成到其它现有框架使用 极简的 API 描述，一键生成各端代码 自动校验客户端请求参数合法性 大量微服务治理和并发工具包 如果内容有误请 与我联系\ngo-zero 单体应用实践（一） go-zero 单体应用实践（二） go-zero 单体应用实践（三） go-zero 微服务应用实践（一） go-zero 微服务应用实践（二） "
},
{
	"uri": "http://blog.911015.com/wx/20230523.html",
	"title": "Go语言数据结构： Array 和Slice",
	"tags": null,
	"description": "Go 语言中的数组和切片（slice）都是用于存储一系列数据的集合，但它们之间有几个重要的区别",
	"content": "Go语言数据结构： Array 和Slice Go 语言中的数组和切片（slice）都是用于存储一系列数据的集合，但它们之间有几个重要的区别。下面是它们的使用方法和区别：\n数组 数组是一个有固定大小的数据集合，定义时需要指定其长度。数组的长度是数组类型的一部分，因此不能改变数组的大小。数组可以包含相同类型的数据，这些数据在内存中是连续的。\n创建数组 var a [5]int // 定义一个长度为5，元素类型为int的数组 b := [3]string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;} // 定义一个长度为3，元素类型为string的数组，并初始化数组值 访问数组元素 a[0] = 1 // 给第1个元素赋值为1 x := a[2] // 获取第3个元素的值 遍历数组元素 for i, v := range a { fmt.Printf(\u0026#34;a[%d] = %d\\n\u0026#34;, i, v) } 切片 切片是一个动态的数组，长度不固定，可以根据实际情况进行扩展。切片本身并不存储任何数据，它只是底层数组的引用，因此对切片的修改会影响到底层数组的内容。\n创建切片 var s []int // 定义一个空的整型切片 s := []int{1, 2, 3} // 定义一个有3个元素的整型切片，并初始化数组值 访问切片元素 x := s[2] // 获取第3个元素的值 遍历切片元素 for i, v := range s { fmt.Printf(\u0026#34;s[%d] = %d\\n\u0026#34;, i, v) } 切片操作 可以使用 slice 函数和操作符对切片进行操作。\nslice 函数：用于获取某个数组的一部分作为切片。 a := [5]int{1, 2, 3, 4, 5} s := a[1:3] // 获取a数组中索引从1到3的切片（不包含3） 切片操作符：用于对切片进行扩展或缩小。 s := []int{1, 2, 3, 4, 5} s = append(s, 6) // 在s切片末尾添加一个新元素6 s = s[:len(s)-1] // 删除s切片末尾的一个元素 总之，数组和切片都是存储数据集合的方式，但它们在使用方法上存在一定的差别。数组长度是固定的，而切片长度可以根据实际情况动态调整；数组不能直接进行扩展或缩小，而切片则可以通过 slice 函数和操作符进行扩展或缩小。\n在使用 Go 语言中的切片（slice）时，需要注意以下几点： 创建切片时不要忘记 make 函数 在创建一个长度不为0的切片时，需要使用 make 函数来进行初始化。例如：\ns := make([]int, 5) 切片是引用类型 切片是对底层数组的引用，因此修改切片会影响到原始数组。例如：\na := [3]int{1, 2, 3} s := a[:] s[0] = 100 fmt.Println(a) // [100 2 3] 切片容量可以自动扩展 切片的容量可以在底层数组没有空间存储更多元素时自动扩展。例如：\ns := []int{1, 2, 3} s = append(s, 4, 5, 6) 切片可以共享底层数组 如果将一个切片赋值给另一个切片，两个切片将共享同一个底层数组。因此，修改其中一个切片的值将会影响到另一个切片。例如：\na := []int{1, 2, 3, 4, 5} s1 := a[1:3] s2 := a[2:4] s1[0] = 100 fmt.Println(s2) // [100 4] 切片可以作为参数传递 在函数调用时，切片可以作为参数传递。由于切片是引用类型，因此修改切片的值会影响到原始数组。例如：\nfunc updateSlice(slice []int) { slice[0] = 100 } a := []int{1, 2, 3} updateSlice(a) fmt.Println(a) // [100 2 3] 总之，在使用 Go 语言中的切片时，需要注意它是一个引用类型，有自动扩展容量的特性，并且可以共享底层数组。正确地使用切片可以提高代码的可读性和效率。\n"
},
{
	"uri": "http://blog.911015.com/grpc/03.html",
	"title": "三、拦截器与Metadata",
	"tags": null,
	"description": "gRPC 是 Google 开发的一款高性能、开源的远程过程调用（RPC）框架。它使用 Protocol Buffers 作为接口定义语言（IDL），可以在多种编程语言和平台之间进行通信。",
	"content": "拦截器 根据RPC调用类型可以将gRPC拦截器分为两种：\n一元拦 截器(Unary Interceptor) :拦截和处理一元RPC调用。 流拦截器(Stream Interceptor) :拦截和处理流式RPC调用。 1、服务端拦截器 服务端一元拦截器类型为 grpc.UnaryServerInterceptor；流拦截器类型为 StreamServerInterceptor; 下面实现一个服务端一元拦截器：在调用服务前后各打印一条日志\nfunc HelloInterceptor() grpc.UnaryServerInterceptor { return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) { log.Println(\u0026#34;Hello\u0026#34;) resp, err = handler(ctx, req) log.Println(\u0026#34;Bye bye\u0026#34;) return } } 在服务端代码中配置拦截器；\nopts := []grpc.ServerOption{ grpc.UnaryInterceptor(interceptors.HelloInterceptor()), } server := grpc.NewServer(opts...) 2、使用多个拦截器 gRPC 默认只支持设置单个拦截器，设置过个拦截器会painc\npanic: The unary server interceptor was already set and may not be reset.\n设置多个拦截器可以使用 grpc-ecosystem/go-grpc-middleware\ngo get -u github.com/grpc-ecosystem/go-grpc-middleware@latest\nopts := []grpc.ServerOption{ grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer( interceptors.HelloInterceptor(), interceptors.DurationInterceptor(), )), } 3、客户端拦截器 超时控制实现 超时拦截器\nfunc TimeoutInterceptor(second) grpc.UnaryClientInterceptor { return func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error { if _, ok := ctx.Deadline(); !ok { timeout := 3 * time.Second var cancel context.CancelFunc ctx, cancel = context.WithTimeout(ctx, timeout) defer cancel() } return invoker(ctx, method, req, reply, cc, opts...) } } 设置客户端拦截器\nopt := []grpc.DialOption{ grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithUnaryInterceptor(interceptors.TimeoutInterceptor(time.Second)), } conn, _ := grpc.Dial(\u0026#34;:\u0026#34;+port, opt...) 4、服务端超时拦截器 服务端拦截器可以参考 go-zero 中拦截器的实现代码：定义done, paincChan 两个channel；单独开一个goroutine执行 handler 逻辑并处理panic；之后通过select 语句阻塞监听 ctx.Done;done 和panicChan；\nfunc UnaryTimeoutInterceptor(timeout time.Duration) grpc.UnaryServerInterceptor { return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (interface{}, error) { var cancel context.CancelFunc if _, ok := ctx.Deadline(); !ok { ctx, cancel = context.WithTimeout(ctx, timeout) } if cancel != nil { defer cancel() } var resp interface{} var err error var lock sync.Mutex done := make(chan struct{}) // create channel with buffer size 1 to avoid goroutine leak panicChan := make(chan interface{}, 1) go func() { defer func() { if p := recover(); p != nil { // attach call stack to avoid missing in different goroutine panicChan \u0026lt;- fmt.Sprintf(\u0026#34;%+v\\n\\n%s\u0026#34;, p, strings.TrimSpace(string(debug.Stack()))) } }() lock.Lock() defer lock.Unlock() resp, err = handler(ctx, req) close(done) }() select { case p := \u0026lt;-panicChan: panic(p) case \u0026lt;-done: lock.Lock() defer lock.Unlock() return resp, err case \u0026lt;-ctx.Done(): err := ctx.Err() if err == context.Canceled { err = status.Error(codes.Canceled, err.Error()) } else if err == context.DeadlineExceeded { err = status.Error(codes.DeadlineExceeded, err.Error()) } return nil, err } } Metadata 在gRPC中，metadata实际上就是-一个 map结构:\ntype MD map [string][] string\n本质.上也可以通过Header来传递数据 1、设置metadata\nmd := metadata.New(map[string]string{ \u0026#34;auth\u0026#34;: \u0026#34;golang\u0026#34;, }) mdCtx := metadata.NewOutgoingContext(ctx, md) 2、读取metadata\nmd, b := metadata.FromIncomingContext(ctx) if b { log.Printf(\u0026#34;metadata:%v\u0026#34;, md) if auth, ok := md[\u0026#34;auth\u0026#34;]; ok { log.Printf(\u0026#34;auth:%v\u0026#34;, auth) } } "
},
{
	"uri": "http://blog.911015.com/wx/20230524.html",
	"title": " Go 语言数据结构：Maps",
	"tags": null,
	"description": "Golang中的Map是一种集合类型，它用于将一个键值对映射到另一个键值对。这些键值对可以是任何可比较的类型，包括内置类型和用户定义的类型，而且每个键只能在Map中出现一次。 具体来说，Map是由一组键值对组成的无序集合。每个键必须是唯一的，而不同的键可以关联到相同的值。",
	"content": "Golang中的Map是一种集合类型，它用于将一个键值对映射到另一个键值对。这些键值对可以是任何可比较的类型，包括内置类型和用户定义的类型，而且每个键只能在Map中出现一次。 具体来说，Map是由一组键值对组成的无序集合。每个键必须是唯一的，而不同的键可以关联到相同的值。Map通常用于需要快速查找特定键以获取相应值的场景，例如字典或计数器。\nMap 基本用法 以下是使用Map的一些基本用法：\n创建Map：使用make函数创建一个Map对象，同时指定键和值的类型。 myMap := make(map[string]int) 添加元素：通过键值对的方式添加元素到Map中。 myMap[\u0026#34;apple\u0026#34;] = 10 myMap[\u0026#34;orange\u0026#34;] = 5 访问元素：通过键访问Map中的元素值。 fmt.Println(myMap[\u0026#34;apple\u0026#34;]) // Output: 10 更新元素：通过键更新Map中的元素值。 myMap[\u0026#34;apple\u0026#34;] = 15 删除元素：通过键删除Map中的元素。 delete(myMap, \u0026#34;orange\u0026#34;) 遍历Map：使用for range语句遍历Map中的所有键值对,遍历是顺序是不确定的。 for key, value := range myMap { fmt.Println(key, value) } 应用场景 计数器：使用Map可以轻松实现计数器功能。例如，如果需要统计一个字符串中每个字符出现的次数，可以使用一个Map来保存每个字符及其出现次数。 str := \u0026#34;abracadabra\u0026#34; counts := make(map[rune]int) for _, c := range str { counts[c]++ } fmt.Println(counts) // Output: map[a:5 b:2 r:2 c:1 d:1] 缓存：Map也可以用作缓存，以加快应用程序的性能。例如，在Web应用程序中，可以将从数据库中检索到的数据存储在Map中，以避免重复查询相同的数据。 type User struct { ID int Name string } var cache = make(map[int]User) func getUserByID(id int) (User, error) { user, ok := cache[id] if !ok { // 从数据库中查询用户信息 user = User{ID: id, Name: \u0026#34;John Doe\u0026#34;} cache[id] = user } return user, nil } 实现集合（set）数据结构：在只关心key是否存在，而不关系值的情况下可以使用 map[T]struct{} 来实现集合的效果 keySet := map[string]struct{}{\u0026#34;golang\u0026#34;: {}, \u0026#34;java\u0026#34;: {}} if _, ok := keySet[\u0026#34;golang\u0026#34;]; ok { fmt.Println(\u0026#34;key golang exist\u0026#34;) } else { fmt.Println(\u0026#34;key golang not exist\u0026#34;) } //output key golang exist 练习：map 实现WordCount。它应该返回字符串s中每个“单词”计数的map。wc.Test函数针对所提供的函数运行一个测试套件，并打印成功或失败。你可能会用到 strings.Fields。 以下代码仅供参考\npackage main import ( \u0026#34;strings\u0026#34; \u0026#34;golang.org/x/tour/wc\u0026#34; ) func WordCount(s string) map[string]int { res := make(map[string]int) words := strings.Fields(s) for _, word := range words { res[word]++ } return res } func main() { wc.Test(WordCount) } 注意事项 在使用Map时，需要注意以下几点：\n并发访问：Map不是线程安全的，如果多个goroutine同时访问同一个Map，则可能会导致数据竞争和不确定结果。为了避免这种情况，可以使用sync.Mutex等方法进行加锁处理。 空指针：在声明Map时，如果没有进行初始化，则默认值为nil。如果尝试对nil map进行操作，将会产生panic。应该在声明时进行初始化或者先判断map是否为nil。 不稳定的迭代顺序：Map是无序的，因此不能保证迭代时元素的顺序。如果需要有序的集合，请使用Slice。 未初始化的值类型：当使用值类型作为Map的键时，必须确保该类型已经被初始化。例如，如果使用结构体作为键，则必须确保结构体内所有字段都被初始化。 Map长度计算：不能依赖len()函数来计算Map的长度。这是因为Map的长度是动态变化的。如果需要知道Map的长度，请自己统计元素数量。 Map内存泄漏：如果不再需要Map中的某个元素，请及时删除它。否则，它将占用内存，并可能导致内存泄漏。 Map键类型：Map的键可以是所有可比较的类型，包括基本类型、字符串和指针。但是，不建议使用浮点数作为键，因为在计算机内部表示时可能存在精度问题。 "
},
{
	"uri": "http://blog.911015.com/beginner/04.html",
	"title": "04-入门多模块工作区",
	"tags": null,
	"description": "",
	"content": "本教程介绍了 Go 中多模块工作区的基础知识。使用多模块工作区，您可以告诉 Go 命令您正在同时在多个模块中编写代码，并轻松地在这些模块中构建和运行代码。 在本教程中，您将在共享的多模块工作区中创建两个模块，对这些模块进行更改，并在构建中查看这些更改的结果。\n前期准备 安装 Go 1.18 或更高版本。 一个编辑代码的工具。 一个命令终端。 本教程需要** go1.18** 或更高版本。使用go.dev/dl中的链接确保您已在 Go 1.18 或更高版本中安装了 Go 。\n创建一个模块 首先，为您要编写的代码创建一个模块。 一、打开命令提示符并切换到您的主目录。\n# Linux 或 Mac： $ cd # Windows： C:\\\u0026gt; cd %HOMEPATH% 本教程的其余部分将显示 $ 作为提示符。您使用的命令也适用于 Windows。\n二、在命令提示符下，创建workspace目录。\n$ mkdir workspace $ cd workspace 三、初始化模块\n本示例将创建一个依赖 golang.org/x/example 模块的hello 模块。\n1、创建 hello 模块：\n$ mkdir hello $ cd hello $ go mod init example.com/hello go: creating new go.mod: module example.com/hello 2、使用 go get 添加 golang.org/x/example 依赖、。\n$ go get golang.org/x/example 3、在 hello 目录下创建 hello.go，内容如下：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;golang.org/x/example/stringutil\u0026#34; ) func main() { fmt.Println(stringutil.Reverse(\u0026#34;Hello\u0026#34;)) } 4、运行 hello 程序：\n$ go run example.com/hello olleH 创建工作区 在此步骤中，我们将创建一个go.work文件来指定模块的工作区。\n初始化工作区 在workspace目录中，运行：\n$ go work init ./hello 该go work init命令会生成go.work文件从而创建一个包含 ./hello 目录的工作空间\n该go命令生成一个go.work如下所示的文件：\ngo 1.18 use ./hello 该go.work文件的语法与go.mod 类似 第一行 go 1.18 告诉 Go 应使用哪个版本的 Go 编译文件，与go.mod文件go.mod 。 第二行 use ./hello 告诉 Go 在编译时 hello 目录的模块应该是主模块 所以在任何子目录下的workspace模块都会被激活。\n运行工作区目录下的程序 在workspace目录中，运行：\n$ go run example.com/hello olleH Go 命令包括工作区中的所有模块作为主模块。这允许我们引用模块中he模块外的包。在模块或工作区外运行该go run命令会报错，因为该go命令不知道要使用哪些模块。\n接下来，我们将模块的本地golang.org/x/example添加到工作区。然后我们将向stringutil包中添加一个新函数，我们可以使用它来代替Reverse.\n下载并修改golang.org/x/example模块 在此步骤中，我们将下载包含该模块的 Git 存储库的副本golang.org/x/example，将其添加到工作区，然后向其中添加我们将在 hello 程序中使用的新函数。 克隆存储库 1、在工作区目录中，运行git命令以克隆存储库：\n$ git clone https://go.googlesource.com/example Cloning into \u0026#39;example\u0026#39;... remote: Total 165 (delta 27), reused 165 (delta 27) Receiving objects: 100% (165/165), 434.18 KiB | 1022.00 KiB/s, done. Resolving deltas: 100% (27/27), done. 2、将模块添加到工作区\n$ go work use ./example 该go work use命令将一个新模块添加到 go.work 文件中。如下：\ngo 1.18 use ( ./hello ./example ) 该模块现在包括模块example.com/hello和golang.org/x/example模块。 我们将在本地stringutil模块中编写的新代码，而不是使用go get命令下载的模块版本。\n3、添加新功能。 添加一个将字符串转大写的新函数到golang.org/x/example/stringutil包中。 在 workspace/example/stringutil 目录中创建一个toupper.go；写入一下代码：\npackage stringutil import \u0026#34;unicode\u0026#34; // ToUpper uppercases all the runes in its argument string. func ToUpper(s string) string { r := []rune(s) for i := range r { r[i] = unicode.ToUpper(r[i]) } return string(r) } 4、修改 hello 程序以使用该函数。 修改内容为workspace/hello/hello.go包含以下内容：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;golang.org/x/example/stringutil\u0026#34; ) func main() { fmt.Println(stringutil.ToUpper(\u0026#34;Hello\u0026#34;)) } 在工作区运行代码 从工作区目录，运行\n$ go run example.com/hello HELLO Go命令在go.work文件指定的目录example.com/hello下查找命令行指定的模块 ，同样使用go.work文件解析导入golang.org/x/example go.work可以替换 replace 指令来跨多个模块工作。 由于这两个模块位于同一个工作区中，因此很容易在一个模块中进行更改并在另一个模块中使用它。\n更进一步 现在，要正确发布这些模块，我们需要发布模块golang.org/x/example ，例如在v0.1.0. 这通常是通过在模块的版本控制存储库上标记提交来完成的。 有关更多详细信息，请参阅 模块发布工作流程文档。发布完成后，我们可以在hello/go.mod中增加对 golang.org/x/example的依赖：\ncd hello go get golang.org/x/example@v0.1.0 这样，该go命令就可以正确解析工作区外的模块。\n了解有关工作区的更多信息 除了我们在本教程前面看到的go work init之外，该go命令还有几个用于处理工作区的子命令：\ngo work use [-r] [dir] ：如果文件存在，则为go.work文件添加一个use dir指令，如果参数目录不存在，则删除该目录。-r表示递归地检查子目录。 go work edit：编辑go.work文件类似于go mod edit go work sync：将工作区构建列表中的依赖项同步到每个工作区模块中。 "
},
{
	"uri": "http://blog.911015.com/tour/04.html",
	"title": "4、方法与接口",
	"tags": null,
	"description": "方法与接口;Go没有类。但是，您可以在类型上定义方法。",
	"content": "Methods Go没有类。但是，您可以在类型上定义方法。 方法是一个具有特殊接收器参数的函数。 接收器出现在自己的参数列表中，位于func关键字和方法名称之间。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.Println(v.Abs()) } 在这个例子中，Abs方法有一个名为v的Vertex类型的接收器。 请记住：方法只是一个带有接收器参数的函数。下面的Abs是作为一个普通函数编写的，函数本身没有变化。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Vertex struct { X, Y float64 } func Abs(v Vertex) float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.Println(Abs(v)) } 您也可以在非结构类型上声明一个方法。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type MyFloat float64 func (f MyFloat) Abs() float64 { if f \u0026lt; 0 { return float64(-f) } return float64(f) } func main() { f := MyFloat(-math.Sqrt2) fmt.Println(f.Abs()) } 在这个例子中，我们看到一个带有Abs方法的数字类型MyFloat。只能声明具有接收器的方法，该接收器的类型与该方法在同一个包中定义。不能使用类型在另一个包（包括int等内置类型）中定义的接收器来声明方法。\n指针接收器 可以使用指针接收器声明方法。这意味着接收器类型具有某些类型T的指针T。（此外，T本身不能是int之类的指针。） 例如，此处的“Scale”方法是在“*顶点”上定义的。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func (v *Vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f } func main() { v := Vertex{3, 4} v.Scale(10) fmt.Println(v.Abs()) } 带有指针接收器的方法可以修改接收器指向的值（就像Scale在这里所做的那样）。由于方法通常需要修改其接收器，因此指针接收器比值接收器更常见。 尝试从第16行Scale函数的声明中删除*，并观察程序的行为是如何变化的。 对于值接收器，“Scale”方法对原始“Vertex ”值的副本进行操作。（这与任何其他函数参数的行为相同。）Scale方法必须有一个指针接收器才能更改主函数中声明的Vertex值。\n指针和函数 在这里，我们看到Abs和Scale方法被重写为函数。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Vertex struct { X, Y float64 } func Abs(v Vertex) float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func Scale(v *Vertex, f float64) { v.X = v.X * f v.Y = v.Y * f } func main() { v := Vertex{3, 4} Scale(\u0026amp;v, 10) fmt.Println(Abs(v)) } 再次尝试从第16行删除*。你能看到为什么行为会改变吗？为了编译示例，您还需要更改哪些内容？\n方法和指针间接寻址 比较前两个程序，您可能会注意到带有指针参数的函数必须使用指针：\nvar v Vertex ScaleFunc(v, 5) // Compile error! ScaleFunc(\u0026amp;v, 5) // OK 而具有指针接收器的方法在被调用时采用值或指针作为接收器：\nvar v Vertex v.Scale(5) // OK p := \u0026amp;v p.Scale(10) // OK 对于v.Scale（5）语句，即使v是一个值而不是指针，也会自动调用带有指针接收器的方法。也就是说，为了方便起见，Go将语句v.Scale（5）解释为（\u0026amp;v）.Scale（5），因为Scale方法有一个指针接收器。\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { X, Y float64 } func (v *Vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f } func ScaleFunc(v *Vertex, f float64) { v.X = v.X * f v.Y = v.Y * f } func main() { v := Vertex{3, 4} v.Scale(2) ScaleFunc(\u0026amp;v, 10) p := \u0026amp;Vertex{4, 3} p.Scale(3) ScaleFunc(p, 8) fmt.Println(v, p) } 反过来，采用值参数的函数必须采用该特定类型的值：\nvar v Vertex fmt.Println(AbsFunc(v)) // OK fmt.Println(AbsFunc(\u0026amp;v)) // Compile error! 而具有值接收器的方法在被调用时可以采用值或指针作为接收器：\nvar v Vertex fmt.Println(v.Abs()) // OK p := \u0026amp;v fmt.Println(p.Abs()) // OK 在这种情况下，方法调用p.Abs（）被解释为（*p）.Abs（）。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func AbsFunc(v Vertex) float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.Println(v.Abs()) fmt.Println(AbsFunc(v)) p := \u0026amp;Vertex{4, 3} fmt.Println(p.Abs()) fmt.Println(AbsFunc(*p)) } 选择值或指针接收器 使用指针接收器有两个原因。第一个是使该方法可以修改其接收器指向的值。第二个是在方法调用时避免复制。如果接收器是一个大型结构体，这可能会更高效。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Vertex struct { X, Y float64 } func (v *Vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := \u0026amp;Vertex{3, 4} fmt.Printf(\u0026#34;Before scaling: %+v, Abs: %v\\n\u0026#34;, v, v.Abs()) v.Scale(5) fmt.Printf(\u0026#34;After scaling: %+v, Abs: %v\\n\u0026#34;, v, v.Abs()) } 在本例中，Scale和Abs都是接收器类型为*Vertex的方法，尽管Abs方法不需要修改其接收器。 通常，给定类型上的所有方法都应该具有值或指针接收器，但不能同时具有这两者。\nInterfaces 接口类型被定义为一组方法签名。 接口类型的值可以包含实现这些方法的任何值。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Abser interface { Abs() float64 } func main() { var a Abser f := MyFloat(-math.Sqrt2) v := Vertex{3, 4} a = f // a MyFloat implements Abser a = \u0026amp;v // a *Vertex implements Abser // In the following line, v is a Vertex (not *Vertex) // and does NOT implement Abser. a = v fmt.Println(a.Abs()) } type MyFloat float64 func (f MyFloat) Abs() float64 { if f \u0026lt; 0 { return float64(-f) } return float64(f) } type Vertex struct { X, Y float64 } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } 注意：第22行的示例代码中有一个错误。Vertex（值类型）不实现Abser，因为Abs方法仅在*Vertex（指针类型）上定义。\n接口是隐式实现的 类型通过实现其方法来实现接口。没有明确的意向声明，也没有“implements”关键字。隐式接口将接口的定义与其实现解耦，然后接口可以在没有预先安排的情况下出现在任何包中。\npackage main import \u0026#34;fmt\u0026#34; type I interface { M() } type T struct { S string } // This method means type T implements the interface I, // but we don\u0026#39;t need to explicitly declare that it does so. func (t T) M() { fmt.Println(t.S) } func main() { var i I = T{\u0026#34;hello\u0026#34;} i.M() } 接口值 接口值可以被认为是一个值和一个具体类型的元组 (value, type) 接口值包含特定基础具体类型的值。对接口值调用方法会在其基础类型上执行相同名称的方法。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type I interface { M() } type T struct { S string } func (t *T) M() { fmt.Println(t.S) } type F float64 func (f F) M() { fmt.Println(f) } func main() { var i I i = \u0026amp;T{\u0026#34;Hello\u0026#34;} describe(i) i.M() i = F(math.Pi) describe(i) i.M() } func describe(i I) { fmt.Printf(\u0026#34;(%v, %T)\\n\u0026#34;, i, i) } 基本值为nil的接口值 如果接口内部的具体值为nil，那么将使用nil接收器调用该方法。在某些语言中，这会触发null指针异常，但在Go中，通常会编写一些方法来优雅地处理使用nil接收器调用的情况（如本例中的方法M）\npackage main import \u0026#34;fmt\u0026#34; type I interface { M() } type T struct { S string } func (t *T) M() { if t == nil { fmt.Println(\u0026#34;\u0026lt;nil\u0026gt;\u0026#34;) return } fmt.Println(t.S) } func main() { var i I var t *T i = t describe(i) i.M() i = \u0026amp;T{\u0026#34;hello\u0026#34;} describe(i) i.M() } func describe(i I) { fmt.Printf(\u0026#34;(%v, %T)\\n\u0026#34;, i, i) } 请注意，持有nil具体值的接口值本身就是非nil。\nNil接口值 nil接口值既不包含值，也不包含具体类型。在nil接口上调用方法是一个运行时错误，因为接口元组中没有指示要调用哪个具体方法的类型。\npackage main import \u0026#34;fmt\u0026#34; type I interface { M() } func main() { var i I describe(i) i.M() } func describe(i I) { fmt.Printf(\u0026#34;(%v, %T)\\n\u0026#34;, i, i) } 空接口 指定零方法的接口类型称为空接口：interface{} 空接口可以包含任何类型的值。（每个类型至少实现零个方法。） 空接口在程序处理未知类型值的时候使用。例如，fmt.Print接受任意数量的接口｛｝类型的参数。\npackage main import \u0026#34;fmt\u0026#34; func main() { var i interface{} describe(i) i = 42 describe(i) i = \u0026#34;hello\u0026#34; describe(i) } func describe(i interface{}) { fmt.Printf(\u0026#34;(%v, %T)\\n\u0026#34;, i, i) } 类型断言 类型断言提供了访问接口值的底层具体值的方法。\nt := i.(T) 该语句断言接口值i包含具体类型T，并将底层T值分配给变量t。如果不是T类型，那么这个语句将引发panic。 为了测试接口值是否包含特定类型，类型断言可以返回两个值：基础值和报告断言是否成功的布尔值。\nt, ok := i.(T) 如果是T类型，那么t被赋值值，ok将为true 如果不是，ok将为false，t将是类型T的零值，并且不会发生panic。 注意这个语法和从map的语法之间的相似性。\npackage main import \u0026#34;fmt\u0026#34; func main() { var i interface{} = \u0026#34;hello\u0026#34; s := i.(string) fmt.Println(s) s, ok := i.(string) fmt.Println(s, ok) f, ok := i.(float64) fmt.Println(f, ok) f = i.(float64) // panic fmt.Println(f) } 类型转换 类型转换是一种允许多个类型断言串联的构造。 类型转换类似于常规switch语句，但类型转换中的case指定类型（而不是值），并将这些值与给定接口值所持有的值的类型进行比较。\nswitch v := i.(type) { case T: // here v has type T case S: // here v has type S default: // no match; here v has the same type as i } 类型转换中的声明与类型断言i具有相同的语法 i.(T)，但特定类型T被关键字 type 所取代。\npackage main import \u0026#34;fmt\u0026#34; func do(i interface{}) { switch v := i.(type) { case int: fmt.Printf(\u0026#34;Twice %v is %v\\n\u0026#34;, v, v*2) case string: fmt.Printf(\u0026#34;%q is %v bytes long\\n\u0026#34;, v, len(v)) default: fmt.Printf(\u0026#34;I don\u0026#39;t know about type %T!\\n\u0026#34;, v) } } func main() { do(21) do(\u0026#34;hello\u0026#34;) do(true) } 此switch语句测试接口值i是否持有T或S类型的值。在T和S的每种情况下，变量v将分别为T或S型，并持有i持有的值。默认情况下（不匹配），变量v与i具有相同的接口类型和值。\nStringer 接口 fmt包定义的Stringer是最普遍的接口之一。\ntype Stringer interface { String() string } Stringer是一种可以将自己描述为字符串的类型。fmt包（以及许多其他包）查找此接口以打印值。\npackage main import \u0026#34;fmt\u0026#34; type Person struct { Name string Age int } func (p Person) String() string { return fmt.Sprintf(\u0026#34;%v (%v years)\u0026#34;, p.Name, p.Age) } func main() { a := Person{\u0026#34;Arthur Dent\u0026#34;, 42} z := Person{\u0026#34;Zaphod Beeblebrox\u0026#34;, 9001} fmt.Println(a, z) } 练习：Stringer 使IPAddr类型实现fmt.Stringer，以将地址打印为点四元组。例如，IPAddr｛1，2，3，4｝应打印为“1.2.3.4”。 代码仅供参考\npackage main import \u0026#34;fmt\u0026#34; type IPAddr [4]byte // TODO: Add a \u0026#34;String() string\u0026#34; method to IPAddr. func (ip IPAddr) String() string { return fmt.Sprintf(\u0026#34;%d.%d.%d.%d\u0026#34;, ip[0], ip[1], ip[2], ip[3]) } func main() { hosts := map[string]IPAddr{ \u0026#34;loopback\u0026#34;: {127, 0, 0, 1}, \u0026#34;googleDNS\u0026#34;: {8, 8, 8, 8}, } for name, ip := range hosts { fmt.Printf(\u0026#34;%v: %v\\n\u0026#34;, name, ip) } } Errors 接口 Go程序用错误值表示错误状态。错误类型是一个类似于fmt.Stringer的内置接口。：\ntype error interface { Error() string } （与fmt.Stringer一样，fmt包在打印值时会查找error接口。） 函数通常返回一个错误值，调用代码应该通过测试错误是否等于零来处理错误。\ni, err := strconv.Atoi(\u0026#34;42\u0026#34;) if err != nil { fmt.Printf(\u0026#34;couldn\u0026#39;t convert number: %v\\n\u0026#34;, err) return } fmt.Println(\u0026#34;Converted integer:\u0026#34;, i) nil 表示成功；非 nil 表示失败。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) type MyError struct { When time.Time What string } func (e *MyError) Error() string { return fmt.Sprintf(\u0026#34;at %v, %s\u0026#34;, e.When, e.What) } func run() error { return \u0026amp;MyError{ time.Now(), \u0026#34;it didn\u0026#39;t work\u0026#34;, } } func main() { if err := run(); err != nil { fmt.Println(err) } } 练习：error 复制前面练习中的Sqrt函数，并对其进行修改以返回错误值。当给定负数时，Sqrt应该返回一个非零错误值，因为它不支持复数。创建新类型\ntype ErrNegativeSqrt float64 实现error 接口\nfunc (e ErrNegativeSqrt) Error() string 使得ErrNegativeSqrt（-2）.Error（）返回\u0026quot;cannot Sqrt negative number: -2\u0026quot;.。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type ErrNegativeSqrt float64 func (e ErrNegativeSqrt) Error() string { return fmt.Sprintf(\u0026#34;cannot Sqrt negative number: %v\u0026#34;, float64(e)) } func Sqrt(x float64) (float64, error) { if x \u0026lt; 0 { return 0, ErrNegativeSqrt(x) } var z = 1.0 var old float64 for math.Abs(old-z) \u0026gt;= 0.000001 { old = z z -= (z*z - x) / (2 * z) } return z, nil } func main() { fmt.Println(Sqrt(2)) fmt.Println(Sqrt(-2)) } Reader 接口 io包指定io.Reader接口，该接口表示数据流的读取端。Go标准库包含该接口的许多实现，包括文件、网络连接、压缩器、密码等。io.Reader接口有一个Read方法：\nfunc (T) Read(b []byte) (n int, err error) Read用数据填充给定的字节片，并返回填充的字节数和错误值。当流结束时，它返回一个io.EOF错误。 示例代码创建一个strings.Reader，并一次消耗其输出的8个字节。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;strings\u0026#34; ) func main() { r := strings.NewReader(\u0026#34;Hello, Reader!\u0026#34;) b := make([]byte, 8) for { n, err := r.Read(b) fmt.Printf(\u0026#34;n = %v err = %v b = %v\\n\u0026#34;, n, err, b) fmt.Printf(\u0026#34;b[:n] = %q\\n\u0026#34;, b[:n]) if err == io.EOF { break } } } 练习：Reader 实现一个Reader类型，该类型发出ASCII字符“a”的无限流。 参考\npackage main import \u0026#34;golang.org/x/tour/reader\u0026#34; type MyReader struct{} // TODO: Add a Read([]byte) (int, error) method to MyReader. func (mr MyReader) Read(b []byte) (int, error) { for i := range b { b[i] = \u0026#39;A\u0026#39; } return len(b), nil } func main() { reader.Validate(MyReader{}) } 练习：rot13Reader 一种常见的模式是一个io.Reader，它包装另一个io.Leader，以某种方式修改流。例如，gzip.NewReader函数接受一个io.Reader（压缩数据流），并返回一个*gzip.Reader，该函数还实现了io.Readers（解压缩数据流）。实现一个rot13Reader，它实现io.Reader并从io.Readers读取，通过将rot13替换密码应用于所有字母字符来修改流。rot13Reader类型是为您提供的。通过实现它的Read方法，使它成为一个io.Reader。\npackage main import ( \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) type rot13Reader struct { r io.Reader } func (rr *rot13Reader) Read(p []byte) (n int, err error) { for { b := make([]byte, 1024, 2048) read, err1 := rr.r.Read(b) if err1 == io.EOF { break } for i, b2 := range b[:read] { p[i] = rot13byte(b2) } n += read } return n, nil } func rot13byte(b byte) byte { s := rune(b) if s \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s \u0026lt;= \u0026#39;m\u0026#39; || s \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; s \u0026lt;= \u0026#39;M\u0026#39; { b += 13 } if s \u0026gt;= \u0026#39;n\u0026#39; \u0026amp;\u0026amp; s \u0026lt;= \u0026#39;z\u0026#39; || s \u0026gt;= \u0026#39;N\u0026#39; \u0026amp;\u0026amp; s \u0026lt;= \u0026#39;Z\u0026#39; { b -= 13 } return b } func main() { s := strings.NewReader(\u0026#34;Lbh penpxrq gur pbqr!\u0026#34;) r := rot13Reader{s} io.Copy(os.Stdout, \u0026amp;r) } Images image 包定义 image 接口：\npackage image type Image interface { ColorModel() color.Model Bounds() Rectangle At(x, y int) color.Color } 注意：Bounds方法的Rectangle返回值实际上是一个图像。Rectangle，因为声明在包图像中。color.color和color.Model类型也是接口，但我们将通过使用预定义的实现color.RGBA和color.RGBAModel来忽略这一点。这些接口和类型由 image/color 包指定\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;image\u0026#34; ) func main() { m := image.NewRGBA(image.Rect(0, 0, 100, 100)) fmt.Println(m.Bounds()) fmt.Println(m.At(0, 0).RGBA()) } 练习：image 还记得你之前写的图片生成器吗？让我们再写一个，但这次它将返回image.image的实现，而不是数据切片。 定义您自己的图像类型，实现必要的方法，然后调用pic.ShowImage。 Bounds应该返回一个 image.Rectangle，类似于图像。矩形（0，0，w，h）。 ColorModel应返回color.RGBAModel。 At应该返回一种颜色；最后一个图片生成器中的值v对应于颜色。RGBA{v，v，255，255}。\npackage main import ( \u0026#34;image\u0026#34; \u0026#34;image/color\u0026#34; \u0026#34;golang.org/x/tour/pic\u0026#34; ) type Image struct{} func (i Image) ColorModel() color.Model { return color.RGBAModel } func (i Image) Bounds() image.Rectangle { return image.Rect(0, 0, 200, 200) } func (i Image) At(x, y int) color.Color { return color.RGBA{uint8(x % 255), uint8(y % 255), 255, 255} } func main() { m := Image{} pic.ShowImage(m) } "
},
{
	"uri": "http://blog.911015.com/go-zero/04.html",
	"title": "go-zero 微服务应用实践（一）",
	"tags": null,
	"description": "单体应用实践",
	"content": "简介 go-zero 是一个集成了各种工程实践的 web 和 rpc 框架。通过弹性设计保障了大并发服务端的稳定性，经受了充分的实战检验。\n本节将用go-zero 开发一个用户服务；主要包括注册、登录、用户信息查询功能\n初始化项目 //创建目录 madir project \u0026amp;\u0026amp; cd project //初始化项目 go mod init project 用户服务 0、环境准备 protoc \u0026amp; protoc-gen-go安装\nprotoc是一款用C++编写的工具，其可以将proto文件翻译为指定语言的代码。在go-zero的微服务中，我们采用grpc进行服务间的通信，而grpc的编写就需要用到protoc和翻译成go语言rpc stub代码的插件protoc-gen-go。\n1、创建proto 文件 user/rpc/user.proto\nsyntax = \u0026#34;proto3\u0026#34;; package user; option go_package = \u0026#34;./user\u0026#34;; message RegisterRequest { string Name = 1; int64 Gender = 2; string Email = 3; string Password = 4; } message RegisterResponse { int64 Id = 1; string Name = 2; int64 Gender = 3; string Email = 4; } message LoginRequest { string Email = 1; string Password = 2; } message LoginResponse { int64 Id = 1; string Name = 2; int64 Gender = 3; string Email = 4; } message UserInfoRequest { int64 Id = 1; } message UserInfoResponse { int64 Id = 1; string Name = 2; int64 Gender = 3; string Email = 4; } service User { rpc Register(RegisterRequest) returns(RegisterResponse); rpc Login(LoginRequest) returns(LoginResponse); rpc UserInfo(UserInfoRequest) returns(UserInfoResponse); } 2、创建 user/generate.go 为了方便快速执行 goctl 相关命令，创建generate.go 文件 写入生成命令\npackage user //Rpc //go:generate goctl rpc protoc ./rpc/user.proto --go_out=./rpc/types --go-grpc_out=./rpc/types --zrpc_out=./rpc/ //go:generate goctl model mysql ddl -src ./model/user.sql -dir ./model -c //go:generate goctl api go -api ./api/user.api -dir ./api 执行 goctl rpc protoc 命令生成代码；代码目录如下\n──rpc ├─etc ├─internal │ ├─config │ ├─logic │ ├─server │ └─svc ├─types │ └─user └─user 3、创建model/user.sql 并执行 命令\ngoctl model mysql ddl -src ./model/user.sql -dir ./model -c\nCREATE TABLE `user` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT, `name` varchar(255) NOT NULL DEFAULT \u0026#39;\u0026#39; COMMENT \u0026#39;用户姓名\u0026#39;, `gender` tinyint(3) unsigned NOT NULL DEFAULT \u0026#39;0\u0026#39; COMMENT \u0026#39;用户性别\u0026#39;, `email` varchar(255) NOT NULL DEFAULT \u0026#39;\u0026#39; COMMENT \u0026#39;用户邮箱\u0026#39;, `password` varchar(255) NOT NULL DEFAULT \u0026#39;\u0026#39; COMMENT \u0026#39;用户密码\u0026#39;, `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP, `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`), UNIQUE KEY `idx_email_unique` (`email`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 4、注册逻辑开发 user/rpc/internal/logic/registerlogic.go\nfunc (l *RegisterLogic) Register(in *user.RegisterRequest) (*user.RegisterResponse, error) { _, err := l.svcCtx.UserModel.FindOneByEmail(l.ctx, in.Email) if err == nil { return nil, status.Error(100, \u0026#34;该邮箱被已注册\u0026#34;) } if err != model.ErrNotFound { return nil, status.Error(500, err.Error()) } newUser := model.User{ Name: in.Name, Gender: in.Gender, Email: in.Email, Password: cryptx.PasswordEncrypt(l.svcCtx.Config.Salt, in.Password), } res, err := l.svcCtx.UserModel.Insert(l.ctx, \u0026amp;newUser) if err != nil { return nil, status.Error(500, err.Error()) } newUser.Id, err = res.LastInsertId() if err != nil { return nil, status.Error(500, err.Error()) } return \u0026amp;user.RegisterResponse{ Id: newUser.Id, Name: newUser.Name, Gender: newUser.Gender, Email: newUser.Email, }, nil } 其中密码需要加密存储，加密方法实现：user/common/cryptx/crypt.go\nfunc PasswordEncrypt(salt, password string) string { dk, _ := scrypt.Key([]byte(password), []byte(salt), 32768, 8, 1, 32) return fmt.Sprintf(\u0026#34;%x\u0026#34;, string(dk)) } 5、登录逻辑开发：user/rpc/internal/logic/loginlogic.go\nfunc (l *LoginLogic) Login(in *user.LoginRequest) (*user.LoginResponse, error) { res, err := l.svcCtx.UserModel.FindOneByEmail(l.ctx, in.Email) if err != nil { if err == model.ErrNotFound { return nil, status.Error(100, \u0026#34;用户不存在\u0026#34;) } return nil, status.Error(500, err.Error()) } password := cryptx.PasswordEncrypt(l.svcCtx.Config.Salt, in.Password) if password != res.Password { return nil, status.Error(100, \u0026#34;密码错误\u0026#34;) } return \u0026amp;user.LoginResponse{ Id: res.Id, Name: res.Name, Gender: res.Gender, Email: res.Email, }, nil } 6、查询用户信息：user/rpc/internal/logic/userinfologic.go\nfunc (l *UserInfoLogic) UserInfo(in *user.UserInfoRequest) (*user.UserInfoResponse, error) { // 查询用户是否存在 res, err := l.svcCtx.UserModel.FindOne(l.ctx, in.Id) if err != nil { if err == model.ErrNotFound { return nil, status.Error(100, \u0026#34;用户不存在\u0026#34;) } return nil, status.Error(500, err.Error()) } return \u0026amp;user.UserInfoResponse{ Id: res.Id, Name: res.Name, Gender: res.Gender, Email: res.Email, }, nil } 7。启动测试 go run user.go -f etc/user.yaml\n\u0026gt; grpcurl -plaintext 127.0.0.1:8080 list grpc.health.v1.Health grpc.reflection.v1alpha.ServerReflection user.User \u0026gt; grpcurl -plaintext 127.0.0.1:8080 list user.User user.User.Login user.User.Register user.User.UserInfo grpcurl -plaintext -d \u0026#39;{\u0026#34;Name\u0026#34;:\u0026#34;gopher\u0026#34;,\u0026#34;Gender\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;Email\u0026#34;:\u0026#34;123@qq.com\u0026#34;,\u0026#34;Password\u0026#34;:\u0026#34;Password\u0026#34;}\u0026#39; \\ 127.0.0.1:8080 user.User/Register 测试用到了grpcurl 需要配置 Mode: dev 或test 可以看到user.go 中Mode为dev或test是增加了注册反射服务代码\ns := zrpc.MustNewServer(c.RpcServerConf, func(grpcServer *grpc.Server) { user.RegisterUserServer(grpcServer, svr) if c.Mode == service.DevMode || c.Mode == service.TestMode { reflection.Register(grpcServer) } }) "
},
{
	"uri": "http://blog.911015.com/grpc/04.html",
	"title": "四、服务注册与发现",
	"tags": null,
	"description": "gRPC 是 Google 开发的一款高性能、开源的远程过程调用（RPC）框架。它使用 Protocol Buffers 作为接口定义语言（IDL），可以在多种编程语言和平台之间进行通信。",
	"content": "环境依赖 安装并且启动etcd 按照etcd SDK go get go.etcd.io/etcd/client/v3@v3.5.4 go get google.golang.org/grpc@v1.48.0\n旧版本grpc与etcd可能存在不兼容问题，建议使用最新兼容版本\n服务注册与发现 实现思路：服务端启动服务时将自己的服务信息如IP、端口、版本等信息注册到注册中心（此处为ETCD），客户端在进行服务调用时会以约定好的服务名到注册中心查询，发现具体可以调用的服务。 服务端实现：\nfunc init() { flag.StringVar(\u0026amp;port, \u0026#34;p\u0026#34;, \u0026#34;8000\u0026#34;, \u0026#34;启动端口号\u0026#34;) flag.Parse() } func main() { server := grpc.NewServer() discover.RegisterDiscoverDemoServer(server, \u0026amp;DiscoverDemo{}) reflection.Register(server) taget := fmt.Sprintf(\u0026#34;grpc-demo/grpc/%s\u0026#34;, types.SERVER_NAME) client, err := etcd3.New(etcd3.Config{ Endpoints: []string{\u0026#34;http://127.0.0.1:2379\u0026#34;}, }) if err != nil { panic(err) } addr := \u0026#34;127.0.0.1:\u0026#34;+port err = register.EtcdAdd(client, taget,addr) if err != nil { return } lis, _ := net.Listen(\u0026#34;tcp\u0026#34;, addr) server.Serve(lis) } register.EtcdAdd 方法实现\nfunc EtcdAdd(c *clientv3.Client, service, addr string) error { em, _ := endpoints.NewManager(c, service) list, _ := em.List(c.Ctx()) fmt.Println(list) return em.AddEndpoint(c.Ctx(), service+\u0026#34;/\u0026#34;+addr, endpoints.Endpoint{Addr: addr}) } 此时启动服务\ngo run server.go -p 8001 go run server.go -p 8002\n可以通过 etcdctl 命令查看到注册信息： 客户端实现：\nfunc main() { cli, _ := clientv3.NewFromURL(\u0026#34;http://127.0.0.1:2379\u0026#34;) taget := \u0026#34;grpc-demo/grpc/discover-demo\u0026#34; n := 0 for { conn, err := register.EtcdDial(cli, taget) if err != nil { panic(err) } defer conn.Close() client := discover.NewDiscoverDemoClient(conn) reply, err := client.Discover(context.Background(), \u0026amp;discover.Request{Name: \u0026#34;DDDD\u0026#34;}) if err != nil { panic(err) } fmt.Printf(\u0026#34;%d: %v \\n\u0026#34;, n, reply) n++ time.Sleep(time.Second) } } //register.EtcdDial func EtcdDial(c *clientv3.Client, service string) (*grpc.ClientConn, error) { etcdResolver, err := resolver.NewBuilder(c) if err != nil { return nil, err } opts := []grpc.DialOption{ grpc.WithTransportCredentials(insecure.NewCredentials()), grpc.WithResolvers(etcdResolver), } return grpc.Dial(\u0026#34;etcd:///\u0026#34;+service, opts...) } 启动客户端\n0: content:\u0026ldquo;request content from8001 =\u0026gt; DDDD\u0026rdquo; 1: content:\u0026ldquo;request content from8001 =\u0026gt; DDDD\u0026rdquo; 2: content:\u0026ldquo;request content from8001 =\u0026gt; DDDD\u0026rdquo; 3: content:\u0026ldquo;request content from8001 =\u0026gt; DDDD\u0026rdquo; 4: content:\u0026ldquo;request content from8002 =\u0026gt; DDDD\u0026rdquo; 5: content:\u0026ldquo;request content from8001 =\u0026gt; DDDD\u0026rdquo;\n至此我们实现了服务端的注册，但停掉服务后会发现etcd中的注册信息并没有注销；实际服务端还应该实现服务的定期检测以及主动下线功能； 服务停止是主动下线：\n// server.go go server.Serve(lis) quit := make(chan os.Signal) signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM) \u0026lt;-quit log.Println(\u0026#34;Shotdown Server ...\u0026#34;) _ = register.EtcdDelete(client, taget, addr) //register.EtcdDelete func EtcdDelete(c *clientv3.Client, service, addr string) error { em, _ := endpoints.NewManager(c, service) return em.DeleteEndpoint(c.Ctx(), service+\u0026#34;/\u0026#34;+addr) } 同时可以通过ETCD设置租期，和定时更新实现定时检查和异常自动下线\nfunc EtcdKeepAlive(c *clientv3.Client, service, addr string, ttl int64) error { target := service + \u0026#34;/\u0026#34; + addr go func() { ticker := time.NewTicker(time.Second * 10) for { grant, err := c.Grant(c.Ctx(), ttl) if err != nil { log.Println(err) } em, _ := endpoints.NewManager(c, service) update := endpoints.NewAddUpdateOpts(target, endpoints.Endpoint{Addr: addr}, clientv3.WithLease(grant.ID)) err = em.Update(c.Ctx(), []*endpoints.UpdateWithOpts{update}) if err != nil { log.Println(err) } log.Println(\u0026#34;update\u0026#34;) select { case \u0026lt;-stopSignal: return case \u0026lt;-ticker.C: } } }() return nil } func EtcdDelete(c *clientv3.Client, service, addr string) error { close(stopSignal) em, _ := endpoints.NewManager(c, service) return em.DeleteEndpoint(c.Ctx(), service+\u0026#34;/\u0026#34;+addr) } Reference grpc-load-balancing\n"
},
{
	"uri": "http://blog.911015.com/wx/20230525.html",
	"title": " Go 语言数据结构：结构体",
	"tags": null,
	"description": "Go语言中，结构体是一种用户自定义的数据类型，用于存储不同数据类型的集合",
	"content": "指针 Go提供了指针类型。指针保存的是一个值的内存地址。但是Go没有指针运算。 类型*T是指向T值的指针。它的零值为nil。\nvar p *int *\u0026amp; 运算符生成指向其操作数的指针。 **运算符表示指针的基本值。\ni := 42 p = \u0026amp;i fmt.Println(*p) // read i through the pointer p *p = 21 // set i through the pointer p 结构体（Structs） Go语言中，结构体是一种用户自定义的数据类型，用于存储不同数据类型的集合 。 使用点(.)访问结构字段。 在结构体中，字段首字母的大小写决定了该字段的可见性。 定义结构体 一个结构体包含0到N个字段（Field），每个字段由字段名和类型构成；定义一个结构体的一般方式如下，\ntype T struct { field1 type1 field2 type2 ... } 如果个字段类型相同也可以简写成 :\ntype T struct {X,Y int} 创建结构体 假设我们已经定义了这样一个结构体：\ntype Vertex struct { X int Y int } 如何使用这个结构体呢？创建一个结构体变量常用的方法有：\n定义结构体类型变量 var v1 Vertex v1.X = 1 v1.Y = 2 fmt.Println(v1) // 输出 {1 2} 定义变量并赋值 （可以只指定部分字段的值，未指定的字段默认为该字段类型的零值） v1 := Vertex{X:1,Y:2} v2 := Vertex{3,4} // 也可以不显示字段名，按字段的顺序进行赋值 fmt.Println(v1,v2,v3) // 输出 {1 2} {3 4} 也可以不显示字段名，直接按字段的顺序进行赋值（如v2）。但这种方式可读性会差一些；\n结构体指针 可以通过结构指针访问结构字段。（\u0026amp;返回一个指向结构值的指针）\nv := Vertex{1, 2} p := \u0026amp;v p.X = 1e9 fmt.Println(v) //output {1000000000 2} 当我们通过结构指针p访问结构的字段X，可以这样写（*p）.X。然而，这种表示法很麻烦，所以Go语言允许只写p.X，而不显式解引用。\nStructs 等于 Class 吗？ Go语言中没有类的概念，而是提供了结构体,结构体中可以添加方法；这一点与类颇为相似；但是Go中的结构体没有继承的概念；以至于有人问：Is Go an object-oriented language?（Go是一种面向对象的语言吗） 我们看一下官方的回答： 可以说是，也可以说不是。虽然 Go 有类型和方法，支持面向对象的编程风格，但却没有类型的层次结构。Go 中的“接口”概念提供了一种与众不同的方式，我们认为这种方式更易于使用，也更为通用。Go 也可以将结构体嵌套使用，这与子类化（Subclassing）类似，但并不完全相同。此外，Go 提供的特性比 C++ 或 Java 更为通用：子类可以由任何类型的数据来定义，甚至是内建类型（如简单的“未装箱的”整型）。这在结构体（类）中没有受到限制。 此外，由于缺乏类型层次结构，Go中的“对象”感觉比C++或Java等语言中的“对象”轻量得多。\n因此在使用Go语言的结构体时需要用Go的思维方式去编写；比如下面的例子：\ntype Vertex struct { X int Y int } var v1 Vertex fmt.Println(v1) // 输出 {0 0} 如果某类型的零值不可用，需要程序员来隐藏该类型，避免从其他包直接访问。并且提供一个New 函数让调用者按照要求初始化，例如：\ntype vertex struct { x int y int } func New(x,y int) vertex { return vertex{x:x,y:y} } func(v vertex) Mul() int { return v.x*v.y } 调用者需要这样使用：\nv := New(10,10) m := v.Mul() fmt.Println(m) 欢迎关注\n"
},
{
	"uri": "http://blog.911015.com/tour/05.html",
	"title": "5、泛型",
	"tags": null,
	"description": "Go支持使用类型参数进行泛型编程。本课展示了在代码中使用泛型的一些示例。",
	"content": " Go支持使用类型参数进行泛型编程。本课展示了在代码中使用泛型的一些示例。\n类型参数 Go函数可以使用类型参数让函数支持多个类型。函数的类型参数用中括号包裹，位于函数的参数之前。\nfunc Index[T comparable](s []T, x T) int 这个声明意味着s是任何类型T的一个切片，它满足comparable内置约束。x也是相同类型的值。 compatible是一个有用的约束，可以使用==和！=类型值上的运算符。在本例中，我们使用它将一个值与所有切片元素进行比较，直到找到匹配。此Index函数适用于任何支持比较的类型。\npackage main import \u0026#34;fmt\u0026#34; // Index returns the index of x in s, or -1 if not found. func Index[T comparable](s []T, x T) int { for i, v := range s { // v and x are type T, which has the comparable // constraint, so we can use == here. if v == x { return i } } return -1 } func main() { // Index works on a slice of ints si := []int{10, 20, 15, -10} fmt.Println(Index(si, 15)) // Index also works on a slice of strings ss := []string{\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;} fmt.Println(Index(ss, \u0026#34;hello\u0026#34;)) } 泛型类型 除了泛型函数外，Go还支持泛型类型。可以使用类型参数对类型进行参数化，这对于实现泛型数据结构非常有用。\npackage main // List represents a singly-linked list that holds // values of any type. type List[T any] struct { next *List[T] val T } func main() { } 此示例演示了一个简单的类型声明，用于包含任何类型值的单链列表。\n"
},
{
	"uri": "http://blog.911015.com/tour/",
	"title": "Go 编程语言之旅",
	"tags": null,
	"description": "欢迎来到Go 编程语言之旅。",
	"content": "欢迎来到Go 编程语言之旅。 欢迎来到 Go 之旅;官方地址：A Tour of Go 1、基础篇（一）：包、变量和方法 2、基础篇（二）：Go语言流程控制 3、基础篇（三）：更多类型: struct, slices, 和 map 4、方法与接口 5、泛型 6、并发 基础篇 学习语言的所有基础知识。 声明变量、调用函数以及学习下一课之前需要了解的所有内容。\r包、变量和函数。\r了解任何 Go 程序的基本组件。\r流程控制语句：for、if、else、switch 和 defer\r了解如何使用条件、循环、开关和延迟来控制代码流。\r更多类型：结构、切片和映射。\r了解如何根据现有类型定义类型：本课程涵盖结构、数组、切片和映射。\r方法和接口 了解如何定义类型的方法、如何声明接口以及如何将所有内容组合在一起。\r方法和接口\r本课涵盖方法和接口、定义对象及其行为的结构。\r泛型 了解如何在 Go 函数和结构中使用类型参数。\r泛型\rGo 支持使用类型参数的泛型编程。本课展示了一些在代码中使用泛型的示例。\r并发 Go 提供并发功能作为核心语言的一部分。该模块介绍了 goroutines 和通道，以及如何使用它们来实现不同的并发模式。\r并发\rGo 提供并发结构作为核心语言的一部分。本课将介绍它们并给出一些有关如何使用它们的示例。\r"
},
{
	"uri": "http://blog.911015.com/go-zero/05.html",
	"title": "go-zero 微服务应用实践（二）",
	"tags": null,
	"description": "单体应用实践",
	"content": "服务调用 完成rpc访问功能后，还需要进行客户端调用，会用到goctl 的api功能；创建api目录编写api文件；api相关语法可以参考官方文档：api语法介绍\n1、API文件编写 其中 登录注册增加了参数验证，使用 validator 包进行验证详细使用方法可以到 github.com/go-playground/validator 查看\nsyntax = \u0026#34;v1\u0026#34; type ( LoginRequest { Email string `json:\u0026#34;Email\u0026#34; validate:\u0026#34;required,email\u0026#34;` Password string `json:\u0026#34;password\u0026#34; validate:\u0026#34;required,gte=8\u0026#34;` } LoginResponse { AccessToken string `json:\u0026#34;accessToken\u0026#34;` AccessExpire int64 `json:\u0026#34;accessExpire\u0026#34;` } RegisterRequest { Name string `json:\u0026#34;name\u0026#34; validate:\u0026#34;required,gte=2,lte=20\u0026#34;` Gender int64 `json:\u0026#34;gender\u0026#34; validate:\u0026#34;oneof=1 2\u0026#34;` Email string `json:\u0026#34;Email\u0026#34; validate:\u0026#34;required,email\u0026#34;` Password string `json:\u0026#34;password\u0026#34; validate:\u0026#34;required,gte=8\u0026#34;` } RegisterResponse { Id int64 `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Gender int64 `json:\u0026#34;gender\u0026#34;` Email string `json:\u0026#34;Email\u0026#34;` } UserInfoRequest { } UserInfoResponse { Id int64 `json:\u0026#34;id\u0026#34;` Name string `json:\u0026#34;name\u0026#34;` Gender int64 `json:\u0026#34;gender\u0026#34;` Email string `json:\u0026#34;Email\u0026#34;` } ) service User { @handler Login post /api/user/login(LoginRequest) returns (LoginResponse) @handler Register post /api/user/register(RegisterRequest) returns (RegisterResponse) } @server( jwt: Auth ) service User { @handler UserInfo post /api/user/userinfo(UserInfoRequest) returns (UserInfoResponse) } 2、执行goctl命令 goctl api go -api ./api/user.api -dir ./api\n执行后生成目录如下\napi ├─etc └─internal ├─config ├─handler ├─logic ├─svc └─types 3、Service 层增加 UserRpc package svc import ( \u0026#34;github.com/zeromicro/go-zero/zrpc\u0026#34; \u0026#34;slowdown/user/api/internal/config\u0026#34; \u0026#34;slowdown/user/rpc/user\u0026#34; ) type ServiceContext struct { Config config.Config UserRpc user.User } func NewServiceContext(c config.Config) *ServiceContext { return \u0026amp;ServiceContext{ Config: c, UserRpc: user.NewUser(zrpc.MustNewClient(c.UserRpc)), } } 4、logic 业务逻辑层 注册逻辑\nfunc (l *RegisterLogic) Register(req *types.RegisterRequest) (resp *types.RegisterResponse, err error) { validate := validator.New() err = validate.Struct(req) if err != nil { return nil, err } res, err := l.svcCtx.UserRpc.Register(l.ctx, \u0026amp;user.RegisterRequest{ Name: req.Name, Email: req.Email, Gender: req.Gender, Password: req.Password, }) if err != nil { return nil, err } return \u0026amp;types.RegisterResponse{ Id: res.Id, Name: res.Name, Gender: res.Gender, Email: res.Email, }, nil } 登录逻辑\nfunc (l *LoginLogic) Login(req *types.LoginRequest) (resp *types.LoginResponse, err error) { res, err := l.svcCtx.UserRpc.Login(l.ctx, \u0026amp;user.LoginRequest{ Email: req.Email, Password: req.Password, }) if err != nil { return nil, err } now := time.Now().Unix() accessToken, err := jwtx.GetToken(l.svcCtx.Config.Auth.AccessSecret, now, l.svcCtx.Config.Auth.AccessExpire, res.Id) if err != nil { return nil, err } return \u0026amp;types.LoginResponse{ AccessExpire: l.svcCtx.Config.Auth.AccessExpire, AccessToken: accessToken, }, nil } 获取用户信息\nfunc (l *UserInfoLogic) UserInfo() (resp *types.UserInfoResponse, err error) { uid, _ := l.ctx.Value(\u0026#34;uid\u0026#34;).(json.Number).Int64() res, err := l.svcCtx.UserRpc.UserInfo(l.ctx, \u0026amp;user.UserInfoRequest{ Id: uid, }) if err != nil { return nil, err } return \u0026amp;types.UserInfoResponse{ Id: res.Id, Name: res.Name, Gender: res.Gender, Email: res.Email, }, nil } 5、启动服务测试 使用apifox进行测试 "
},
{
	"uri": "http://blog.911015.com/grpc/05.html",
	"title": "五、gRPC-Gateway",
	"tags": null,
	"description": "gRPC 是 Google 开发的一款高性能、开源的远程过程调用（RPC）框架。它使用 Protocol Buffers 作为接口定义语言（IDL），可以在多种编程语言和平台之间进行通信。",
	"content": "简介 gRPC-Gateway是protoc的一个插件。它读取gRPC服务定义并生成反向代理服务器，该服务器将RESTful JSON API转换为gRPC。此服务器根据gRPC定义中的自定义选项生成。\ngrpc-gateway文档 安装依赖 go get github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway\nproto 文件 gateway/pb/gateway.proto 文件；其中 需要 import google/api/annotations.proto；可以将 github.com\\grpc-ecosystem\\grpc-gateway 下的 third_party\\googleapis\\google\\api 文件拷贝到项目目录下；执行protoc命令\nprotoc -I=./gateway/pb/ -I=./third_party/ \u0026ndash;go_out=./gateway/ \u0026ndash;go-grpc_out=./gateway/ -grpc-gateway_out=./gateway/ ./gateway/pb/gateway.proto\nsyntax = \u0026#34;proto3\u0026#34;; package stream; option go_package = \u0026#34;pb/;gateway\u0026#34;; import \u0026#34;google/api/annotations.proto\u0026#34;; message Request { string name = 1; } message Reply { string content = 1; } service GatewayDemo { rpc Gate(Request) returns (Reply) { option (google.api.http) = { get: \u0026#34;/v1/gate/{name}\u0026#34; }; } } Server端 server端与正常gRPC服务没什么差别；\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;net\u0026#34; gateway \u0026#34;github.com/grpc-demo/gateway/pb\u0026#34; \u0026#34;google.golang.org/grpc\u0026#34; \u0026#34;google.golang.org/grpc/reflection\u0026#34; ) type Gate struct { gateway.UnimplementedGatewayDemoServer } func (g Gate) Gate(ctx context.Context, req *gateway.Request) (*gateway.Reply, error) { return \u0026amp;gateway.Reply{ Content: fmt.Sprintf(\u0026#34;name:%s;\u0026#34;, req.Name), }, nil } func main() { server := grpc.NewServer() gateway.RegisterGatewayDemoServer(server, \u0026amp;Gate{}) reflection.Register(server) lis, _ := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:9000\u0026#34;) _ = server.Serve(lis) } Http服务端 通过 gateway.RegisterGatewayDemoHandlerFromEndpoint 将http请求代理到给RPC服务；\npackage main import ( \u0026#34;context\u0026#34; \u0026#34;net/http\u0026#34; gateway \u0026#34;github.com/grpc-demo/gateway/pb\u0026#34; \u0026#34;github.com/grpc-ecosystem/grpc-gateway/runtime\u0026#34; \u0026#34;google.golang.org/grpc\u0026#34; \u0026#34;google.golang.org/grpc/credentials/insecure\u0026#34; ) const ( // gRPC服务地址 ServerAddr = \u0026#34;127.0.0.1:9000\u0026#34; ClientAddr = \u0026#34;127.0.0.1:8000\u0026#34; ) func main() { ctx, cancelFunc := context.WithCancel(context.Background()) defer cancelFunc() mux := runtime.NewServeMux() opts := []grpc.DialOption{grpc.WithTransportCredentials(insecure.NewCredentials())} err := gateway.RegisterGatewayDemoHandlerFromEndpoint(ctx, mux, ServerAddr, opts) if err != nil { panic(err) } err = http.ListenAndServe(ClientAddr, mux) if err != nil { panic(err) } } 启动测试 go run server.go\n访问 127.0.0.1:8000/v1/gate/grpc 同时也可以通过grpcurl 测试服务端\ngrpcurl -plaintext -d \u0026lsquo;{\u0026ldquo;name\u0026rdquo;:\u0026ldquo;grpc\u0026rdquo;}\u0026rsquo; localhost:9000 stream.GatewayDemo/Gate\n"
},
{
	"uri": "http://blog.911015.com/wx/20230526.html",
	"title": " Go 语言入门：方法",
	"tags": null,
	"description": "Go没有类。但是，您可以在类型上定义方法。 方法是一个具有特殊接收器参数的函数。 接收器出现在自己的参数列表中，位于func关键字和方法名称之间",
	"content": "方法 Methods Go没有类。但是，您可以在类型上定义方法。 方法是一个具有特殊接收器参数的函数。 接收器出现在自己的参数列表中，位于func关键字和方法名称之间。语法如下\nfunc (t 类型) 方法名(参数名 参数类型 ...) [返回值类型]{ } 一下代码为官网示例；定义了一个 Vertex 类列；包含X Y 两个字段；定义了一个Abs 方法；计算坐标点到原点的距离。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.Println(v.Abs()) } 在这个例子中，Abs方法有一个名为v的Vertex类型的接收器。 请记住：方法只是一个带有接收器参数的函数。下面的Abs是作为一个普通函数编写的，函数本身没有变化。\nfunc Abs(v Vertex) float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.Println(Abs(v)) } 您也可以在非结构类型上声明一个方法。\ntype MyFloat float64 func (f MyFloat) Abs() float64 { if f \u0026lt; 0 { return float64(-f) } return float64(f) } 在这个例子中，我们看到一个带有Abs方法的数字类型MyFloat。只能声明具有接收器的方法，该接收器的类型与该方法在同一个包中定义。不能使用类型在另一个包（包括int等内置类型）中定义的接收器来声明方法。\n指针接收器 上面的定义方法例子中我们使用的都是值接收器，还可以使用指针接收器声明方法。这意味着接收器类型是类型T的指针T。（此外，T本身不能是int之类的指针。） 例如，此处的“Scale”方法是在“*Vertex”上定义的。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func (v *Vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f } func main() { v := Vertex{3, 4} v.Scale(10) fmt.Println(v.Abs()) } 带有指针接收器的方法可以修改接收器指向的值（就像Scale在这里所做的那样）。由于方法通常需要修改其接收器，因此指针接收器比值接收器更常见。可以试一下将 Scale 方法改为 值接收器方法看一下是否能起到相同的作用。 对于值接收器，“Scale”方法对原始“Vertex ”值的副本进行操作。（这与任何其他函数参数的行为相同。）Scale方法必须有一个指针接收器才能更改主函数中声明的Vertex值。因此：\n如果方法内部需要修改结构的字段值，并且对调用方可加则需要用指针接收器。 另外如果结构体有很多的字段，使用值接收器时会发生结构体的整体拷贝，为了减少拷贝可以使用指针接收器 其他情况，值接收器都可以被使用 给定类型上的所有方法都应该具有值或指针接收器，但不能同时具有这两者 指针和函数 下面，我们把Abs和Scale方法被重写为函数应该是怎样的呢？代码如下：\nfunc Abs(v Vertex) float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func Scale(v *Vertex, f float64) { v.X = v.X * f v.Y = v.Y * f } 可以看到 Abs 函数使用的是值类型参数，Scale 使用的是指针类型参数，因为Scale需要对 参数的值进行修改；如果不使用指针类型参数 Scale 需要通过返回值的形式给调用者返回一个新的结构体；\n方法和指针间接寻址 比较前两个程序，您可能会注意到带有指针参数的函数必须使用指针\npackage main import \u0026#34;fmt\u0026#34; type Vertex struct { X, Y float64 } func (v *Vertex) Scale(f float64) { v.X = v.X * f v.Y = v.Y * f } func ScaleFunc(v *Vertex, f float64) { v.X = v.X * f v.Y = v.Y * f } func main() { v := Vertex{3, 4} v.Scale(2) ScaleFunc(\u0026amp;v, 10) p := \u0026amp;Vertex{4, 3} p.Scale(3) ScaleFunc(p, 8) fmt.Println(v, p) } 而具有指针接收器的方法在被调用时采用值或指针作为接收器：\nvar v Vertex v.Scale(5) // OK p := \u0026amp;v p.Scale(10) // OK 对于v.Scale（5）语句，即使v是一个值而不是指针，也会自动调用带有指针接收器的方法。也就是说，为了方便起见，Go将语句v.Scale（5）解释为（\u0026amp;v）.Scale（5），因为Scale方法有一个指针接收器。 反过来，采用值参数的函数必须采用该特定类型的值：\nvar v Vertex fmt.Println(AbsFunc(v)) // OK fmt.Println(AbsFunc(\u0026amp;v)) // Compile error! 而具有值接收器的方法在被调用时可以采用值或指针作为接收器：\nvar v Vertex fmt.Println(v.Abs()) // OK p := \u0026amp;v fmt.Println(p.Abs()) // OK 在这种情况下，方法调用p.Abs（）被解释为（*p）.Abs（）。运行一下下面的代码更好的理解一下函数与方法的异同。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func AbsFunc(v Vertex) float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.Println(v.Abs()) fmt.Println(AbsFunc(v)) p := \u0026amp;Vertex{4, 3} fmt.Println(p.Abs()) fmt.Println(AbsFunc(*p)) } "
},
{
	"uri": "http://blog.911015.com/tour/06.html",
	"title": "6、并发",
	"tags": null,
	"description": "Go提供的并发功能是核心语言的一部分",
	"content": "Go提供的并发功能是核心语言的一部分。\nGoroutines goroutine是一个由Go运行时管理的轻量级线程。\ngo f(x, y, z) 开始运行新的goroutine f(x, y, z) f、x、y和z的求值发生在当前goroutine中，f的执行发生在新goroutine。 Goroutines在相同的地址空间中运行，因此对共享内存的访问必须同步。sync包提供了有用的并发原语，尽管Go中并不需要它们，因为还有其他基元。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func say(s string) { for i := 0; i \u0026lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(\u0026#34;world\u0026#34;) say(\u0026#34;hello\u0026#34;) } Channels Channel是一种类型化的管道，通过它可以使用通道操作符\u0026lt;-发送和接收值。\nch \u0026lt;- v // Send v to channel ch. v := \u0026lt;-ch // Receive from ch, and // assign value to v. 数据沿箭头方向流动。 与map和slice一样， channel必须在使用前初始化：\nch := make(chan int) 默认情况下，发送和接收块，直到对方准备好为止。这允许goroutine在没有显式锁或条件变量的情况下进行同步。\npackage main import \u0026#34;fmt\u0026#34; func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c \u0026lt;- sum // send sum to c } func main() { s := []int{7, 2, 8, -9, 4, 0} c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := \u0026lt;-c, \u0026lt;-c // receive from c fmt.Println(x, y, x+y) } 示例代码对一个切片中的数字求和，将工作分配到两个goroutine之间。一旦两个goroutine都完成了计算，它就会计算出最终结果。\nBuffered Channels 通道可以进行缓冲。提供缓冲区长度作为初始化缓冲通道的第二个参数：\nch := make(chan int, 100) 仅当缓冲区已满时发送到缓冲通道阻塞。缓冲区为空时接收阻塞。 修改示例以使缓冲区溢出，然后看看会发生什么。\npackage main import \u0026#34;fmt\u0026#34; func main() { ch := make(chan int, 2) ch \u0026lt;- 1 ch \u0026lt;- 2 fmt.Println(\u0026lt;-ch) fmt.Println(\u0026lt;-ch) } Range and Close 发送方可以关闭一个通道，以指示不再发送任何值。接收器可以通过为接收表达式分配第二个参数来测试通道是否已关闭：如下\nv, ok := \u0026lt;-ch 如果没有更多的值可接收并且通道已关闭，则ok为false。 还可以通过 i：=range c 的循环重复接收来自通道的值，直到通道关闭，循环退出。\npackage main import ( \u0026#34;fmt\u0026#34; ) func fibonacci(n int, c chan int) { x, y := 0, 1 for i := 0; i \u0026lt; n; i++ { c \u0026lt;- x x, y = y, x+y } close(c) } func main() { c := make(chan int, 10) go fibonacci(cap(c), c) for i := range c { fmt.Println(i) } } 注意：\n只有发送方应该关闭频道，而不是接收方。在关闭的频道上发送会引起panic。 channel不像文件；通常不需要关闭它们。只有当接收器必须被告知没有更多的值到来时，例如终止range循环时，才需要关闭。 Select select语句允许goroutine等待多个通信操作。 一个select阻塞，直到它的一个case可以运行，然后它执行那个case。如果多个case准备好了，它会随机选择一个。\npackage main import \u0026#34;fmt\u0026#34; func fibonacci(c, quit chan int) { x, y := 0, 1 for { select { case c \u0026lt;- x: x, y = y, x+y case \u0026lt;-quit: fmt.Println(\u0026#34;quit\u0026#34;) return } } } func main() { c := make(chan int) quit := make(chan int) go func() { for i := 0; i \u0026lt; 10; i++ { fmt.Println(\u0026lt;-c) } quit \u0026lt;- 0 }() fibonacci(c, quit) } 如果没有其他案例准备就绪，则选择中的默认案例将运行。使用默认情况尝试在不阻止的情况下发送或接收：\nselect { case i := \u0026lt;-c: // use i default: // receiving from c would block } package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { tick := time.Tick(100 * time.Millisecond) boom := time.After(500 * time.Millisecond) for { select { case \u0026lt;-tick: fmt.Println(\u0026#34;tick.\u0026#34;) case \u0026lt;-boom: fmt.Println(\u0026#34;BOOM!\u0026#34;) return default: fmt.Println(\u0026#34; .\u0026#34;) time.Sleep(50 * time.Millisecond) } } } Exercise: Equivalent Binary Trees 练习：等价二叉树 代码已同步仅供参考 github\nsync.Mutex 我们已经看到了channel对于goroutines之间的交流是多么的好。 但如果我们不需要通讯呢？如果我们只想确保一次只有一个goroutine可以访问一个变量以避免冲突，该怎么办？ 这个概念被称为互斥，提供互斥的数据结构的传统名称是_mutex_。 Go的标准库通过sync.Mutex及其两种方法提供互斥：\nLock Unlock 我们可以定义一个要在互斥中执行的代码块，方法是用Inc方法中所示的Lock和Unlock调用包围它。 我们还可以使用defer来确保互斥对象将像Value方法中那样被解锁。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) // SafeCounter is safe to use concurrently. type SafeCounter struct { mu sync.Mutex v map[string]int } // Inc increments the counter for the given key. func (c *SafeCounter) Inc(key string) { c.mu.Lock() // Lock so only one goroutine at a time can access the map c.v. c.v[key]++ c.mu.Unlock() } // Value returns the current value of the counter for the given key. func (c *SafeCounter) Value(key string) int { c.mu.Lock() // Lock so only one goroutine at a time can access the map c.v. defer c.mu.Unlock() return c.v[key] } func main() { c := SafeCounter{v: make(map[string]int)} for i := 0; i \u0026lt; 1000; i++ { go c.Inc(\u0026#34;somekey\u0026#34;) } time.Sleep(time.Second) fmt.Println(c.Value(\u0026#34;somekey\u0026#34;)) } Exercise: Web Crawler（网络爬虫） 代码已同步仅供参考 Github\n"
},
{
	"uri": "http://blog.911015.com/grpc/06.html",
	"title": "六、证书验证",
	"tags": null,
	"description": "gRPC 是 Google 开发的一款高性能、开源的远程过程调用（RPC）框架。它使用 Protocol Buffers 作为接口定义语言（IDL），可以在多种编程语言和平台之间进行通信。",
	"content": " 还记得前面章节中gRPC的服务中客户端在链接服务器中通过 grpc.WithInsecure() 选项跳过了对服务器证书的验证吗？为了保障gRPC通信不被第三方监听篡改或伪造，我们试一下对服务器启动TLS加密特性。\n一、生成证书 通过一个安全可靠的根证书分别对服务器和客户端的证书进行签名。这样客户端或服务器在收到对方的证书后可以通过根证书进行验证证书的有效性。\n1、CA证书 创建 ca.conf\n[ req ] default_bits = 4096 distinguished_name = req_distinguished_name [ req_distinguished_name ] countryName = Country Name (2 letter code) countryName_default = CN stateOrProvinceName = State or Province Name (full name) stateOrProvinceName_default = Beiging localityName = Locality Name (eg, city) localityName_default = Beijing organizationName = Organization Name (eg, company) organizationName_default = company commonName = Common Name (e.g. server FQDN or YOUR name) commonName_max = 64 commonName_default = Ted CA Test 生成ca根证书\nSERVER_CN=localhost CLIENT_CN=localhost openssl genrsa -passout pass:1111 -des3 -out ca.key 4096 # Generates ca.crt openssl req -passin pass:1111 -new -x509 -days 365 -key ca.key -out ca.crt -subj \u0026#34;/CN=${SERVER_CN}\u0026#34; -config ./ca.conf 2、服务端证书 注意：go 1.15 版本开始废弃 CommonName，因此推荐使用 SAN 证书\n编辑server.conf 文件 其中 alt_names 配置中的内容 后面客户端请求会用到 [ req ] default_bits = 2048 distinguished_name = req_distinguished_name req_extensions = req_ext [ req_distinguished_name ] countryName = Country Name (2 letter code) countryName_default = CN stateOrProvinceName = State or Province Name (full name) stateOrProvinceName_default = JiangSu localityName = Locality Name (eg, city) localityName_default = NanJing organizationName = Organization Name (eg, company) organizationName_default = your_company commonName = Common Name (e.g. server FQDN or YOUR name) commonName_max = 64 commonName_default = www.eline.com [ req_ext ] subjectAltName = @alt_names [alt_names] DNS.1 = localhost DNS.2 = www.test.com 生成server 端证书文件 # Generate server key: openssl genrsa -passout pass:1111 -des3 -out server.key 4096 openssl req -passin pass:1111 -new -key server.key -out server.csr -subj \u0026#34;/CN=${SERVER_CN}\u0026#34; -config ./server.conf # Generates server.crt openssl x509 -req -passin pass:1111 -days 365 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt -extfile ./server.conf -extensions req_ext # Remove passphrase from server key openssl rsa -passin pass:1111 -in server.key -out server.key 3、客户端证书\n# Generate client key openssl genrsa -passout pass:1111 -des3 -out client.key 4096 openssl req -passin pass:1111 -new -key client.key -out client.csr -subj \u0026#34;/CN=${CLIENT_CN}\u0026#34; -config ./server.conf # Generates client.crt openssl x509 -passin pass:1111 -req -days 365 -in client.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out client.crt -extfile ./server.conf -extensions req_ext # Remove passphrase from client key: openssl rsa -passin pass:1111 -in client.key -out client.key 注意：1、命令中的 ${CLIENT_CN} ${SERVER_CN} 都是最开始定义好的shell变量；2、如果是win系统需要单独安装openssl：下载OpenSSL；\n二、服务端 服务器端用credentials.NewTLS函数生成证书，通过ClientCAs选择CA根证书，并通过ClientAuth选项启用对客户端进行验证。\ntype SafetyServer struct { pb.UnsafeSafetyDemoServer } func (s SafetyServer) Secret(ctx context.Context, in *pb.Request) (*pb.Reply, error) { return \u0026amp;pb.Reply{ Content: \u0026#34;Secret Content： \u0026#34; + in.Name, }, nil } func main() { certificate, err := tls.LoadX509KeyPair(\u0026#34;keys/server.crt\u0026#34;, \u0026#34;keys/server.key\u0026#34;) if err != nil { log.Fatal(err) } certPool := x509.NewCertPool() ca, err := ioutil.ReadFile(\u0026#34;keys/ca.crt\u0026#34;) if err != nil { log.Fatal(err) } if ok := certPool.AppendCertsFromPEM(ca); !ok { log.Fatal(\u0026#34; failed to append certs \u0026#34;) } creds := credentials.NewTLS(\u0026amp;tls.Config{ Certificates: []tls.Certificate{certificate}, ClientAuth: tls.RequireAndVerifyClientCert, ClientCAs: certPool, }) server := grpc.NewServer(grpc.Creds(creds)) pb.RegisterSafetyDemoServer(server, \u0026amp;SafetyServer{}) reflection.Register(server) lis, _ := net.Listen(\u0026#34;tcp\u0026#34;, \u0026#34;:9090\u0026#34;) server.Serve(lis) } 三、客户端 客户端通过 credentials.NewTLS函数调用，引入一个CA根证书和服务器（ServerName ）的名字来实现对服务器进行验证。客户端在链接服务器时会首先请求服务器的证书，然后使用CA根证书对收到的服务器端证书进行验证。\nfunc main() { certificate, err := tls.LoadX509KeyPair(\u0026#34;keys/client.crt\u0026#34;, \u0026#34;keys/client.key\u0026#34;) if err != nil { log.Fatal(err) } certPool := x509.NewCertPool() ca, err := ioutil.ReadFile(\u0026#34;keys/ca.crt\u0026#34;) if err != nil { log.Fatal(err) } if ok := certPool.AppendCertsFromPEM(ca); !ok { log.Fatal(\u0026#34; failed to append certs \u0026#34;) } creds := credentials.NewTLS(\u0026amp;tls.Config{ Certificates: []tls.Certificate{certificate}, ServerName: \u0026#34;www.test.com\u0026#34;, // NOTE: 需要与生成证书的配置匹配 RootCAs: certPool, }) opt := []grpc.DialOption{ grpc.WithTransportCredentials(creds), } conn, _ := grpc.Dial(\u0026#34;:9090\u0026#34;, opt...) defer conn.Close() client := pb.NewSafetyDemoClient(conn) speak, err := client.Secret(context.Background(), \u0026amp;pb.Request{Name: \u0026#34;golang\u0026#34;}) if err != nil { log.Println(\u0026#34;error\u0026#34;) log.Fatal(err) return } log.Println(speak) } ServerName 需要与生成证书的配置匹配;比匹配是会返回错误：\nrpc error: code = Unavailable desc = connection error: desc = \u0026ldquo;transport: authentication handshake failed: x509: certificate is valid for localhost, www.test.com, not www.test.com1\u0026rdquo;\n获取代码：链接\n"
},
{
	"uri": "http://blog.911015.com/wx/20230527.html",
	"title": " Go 语言中的接口：Interface",
	"tags": null,
	"description": "接口类型被定义为一组方法签名。 接口类型的值可以包含实现这些方法的任何值。",
	"content": "Interfaces 接口类型被定义为一组方法签名。 接口类型的值可以包含实现这些方法的任何值。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type Abser interface { Abs() float64 } func main() { var a Abser f := MyFloat(-math.Sqrt2) v := Vertex{3, 4} a = f // a MyFloat implements Abser a = \u0026amp;v // a *Vertex implements Abser // In the following line, v is a Vertex (not *Vertex) // and does NOT implement Abser. a = v fmt.Println(a.Abs()) } type MyFloat float64 func (f MyFloat) Abs() float64 { if f \u0026lt; 0 { return float64(-f) } return float64(f) } type Vertex struct { X, Y float64 } func (v *Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } 注意：第22行的示例代码中有一个错误。Vertex（值类型）不实现Abser，因为Abs方法仅在*Vertex（指针类型）上定义。\n接口是隐式实现的 类型通过实现其方法来实现接口。没有明确的意向声明，也没有“implements”关键字。隐式接口将接口的定义与其实现解耦，然后接口可以在没有预先安排的情况下出现在任何包中。\npackage main import \u0026#34;fmt\u0026#34; type I interface { M() } type T struct { S string } // This method means type T implements the interface I, // but we don\u0026#39;t need to explicitly declare that it does so. func (t T) M() { fmt.Println(t.S) } func main() { var i I = T{\u0026#34;hello\u0026#34;} i.M() } 接口值 接口值可以被认为是一个值和一个具体类型的元组 (value, type) 接口值包含特定基础具体类型的值。对接口值调用方法会在其基础类型上执行相同名称的方法。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type I interface { M() } type T struct { S string } func (t *T) M() { fmt.Println(t.S) } type F float64 func (f F) M() { fmt.Println(f) } func main() { var i I i = \u0026amp;T{\u0026#34;Hello\u0026#34;} describe(i) i.M() i = F(math.Pi) describe(i) i.M() } func describe(i I) { fmt.Printf(\u0026#34;(%v, %T)\\n\u0026#34;, i, i) } 基本值为nil的接口值 如果接口内部的具体值为nil，那么将使用nil接收器调用该方法。在某些语言中，这会触发null指针异常，但在Go中，通常会编写一些方法来优雅地处理使用nil接收器调用的情况（如本例中的方法M）\npackage main import \u0026#34;fmt\u0026#34; type I interface { M() } type T struct { S string } func (t *T) M() { if t == nil { fmt.Println(\u0026#34;\u0026lt;nil\u0026gt;\u0026#34;) return } fmt.Println(t.S) } func main() { var i I var t *T i = t describe(i) i.M() i = \u0026amp;T{\u0026#34;hello\u0026#34;} describe(i) i.M() } func describe(i I) { fmt.Printf(\u0026#34;(%v, %T)\\n\u0026#34;, i, i) } 请注意，持有nil具体值的接口值本身就是非nil。\nNil接口值 nil接口值既不包含值，也不包含具体类型。在nil接口上调用方法是一个运行时错误，因为接口元组中没有指示要调用哪个具体方法的类型。\npackage main import \u0026#34;fmt\u0026#34; type I interface { M() } func main() { var i I describe(i) i.M() } func describe(i I) { fmt.Printf(\u0026#34;(%v, %T)\\n\u0026#34;, i, i) } 空接口 指定零方法的接口类型称为空接口：interface{} 空接口可以包含任何类型的值。（每个类型至少实现零个方法。） 空接口在程序处理未知类型值的时候使用。例如，fmt.Print接受任意数量的接口｛｝类型的参数。\npackage main import \u0026#34;fmt\u0026#34; func main() { var i interface{} describe(i) i = 42 describe(i) i = \u0026#34;hello\u0026#34; describe(i) } func describe(i interface{}) { fmt.Printf(\u0026#34;(%v, %T)\\n\u0026#34;, i, i) } 类型断言 类型断言提供了访问接口值的底层具体值的方法。\nt := i.(T) 该语句断言接口值i包含具体类型T，并将底层T值分配给变量t。如果不是T类型，那么这个语句将引发panic。 为了测试接口值是否包含特定类型，类型断言可以返回两个值：基础值和报告断言是否成功的布尔值。\nt, ok := i.(T) 如果是T类型，那么t被赋值值，ok将为true 如果不是，ok将为false，t将是类型T的零值，并且不会发生panic。 注意这个语法和从map的语法之间的相似性。\npackage main import \u0026#34;fmt\u0026#34; func main() { var i interface{} = \u0026#34;hello\u0026#34; s := i.(string) fmt.Println(s) s, ok := i.(string) fmt.Println(s, ok) f, ok := i.(float64) fmt.Println(f, ok) f = i.(float64) // panic fmt.Println(f) } 类型转换 类型转换是一种允许多个类型断言串联的构造。 类型转换类似于常规switch语句，但类型转换中的case指定类型（而不是值），并将这些值与给定接口值所持有的值的类型进行比较。\nswitch v := i.(type) { case T: // here v has type T case S: // here v has type S default: // no match; here v has the same type as i } 类型转换中的声明与类型断言i具有相同的语法 i.(T)，但特定类型T被关键字 type 所取代。\npackage main import \u0026#34;fmt\u0026#34; func do(i interface{}) { switch v := i.(type) { case int: fmt.Printf(\u0026#34;Twice %v is %v\\n\u0026#34;, v, v*2) case string: fmt.Printf(\u0026#34;%q is %v bytes long\\n\u0026#34;, v, len(v)) default: fmt.Printf(\u0026#34;I don\u0026#39;t know about type %T!\\n\u0026#34;, v) } } func main() { do(21) do(\u0026#34;hello\u0026#34;) do(true) } 此switch语句测试接口值i是否持有T或S类型的值。在T和S的每种情况下，变量v将分别为T或S型，并持有i持有的值。默认情况下（不匹配），变量v与i具有相同的接口类型和值。\nStringer 接口 fmt包定义的Stringer是最普遍的接口之一。\ntype Stringer interface { String() string } Stringer是一种可以将自己描述为字符串的类型。fmt包（以及许多其他包）查找此接口以打印值。\npackage main import \u0026#34;fmt\u0026#34; type Person struct { Name string Age int } func (p Person) String() string { return fmt.Sprintf(\u0026#34;%v (%v years)\u0026#34;, p.Name, p.Age) } func main() { a := Person{\u0026#34;Arthur Dent\u0026#34;, 42} z := Person{\u0026#34;Zaphod Beeblebrox\u0026#34;, 9001} fmt.Println(a, z) } 练习：Stringer 使IPAddr类型实现fmt.Stringer，以将地址打印为点四元组。例如，IPAddr｛1，2，3，4｝应打印为“1.2.3.4”。 代码仅供参考\npackage main import \u0026#34;fmt\u0026#34; type IPAddr [4]byte // TODO: Add a \u0026#34;String() string\u0026#34; method to IPAddr. func (ip IPAddr) String() string { return fmt.Sprintf(\u0026#34;%d.%d.%d.%d\u0026#34;, ip[0], ip[1], ip[2], ip[3]) } func main() { hosts := map[string]IPAddr{ \u0026#34;loopback\u0026#34;: {127, 0, 0, 1}, \u0026#34;googleDNS\u0026#34;: {8, 8, 8, 8}, } for name, ip := range hosts { fmt.Printf(\u0026#34;%v: %v\\n\u0026#34;, name, ip) } } Errors 接口 Go程序用错误值表示错误状态。错误类型是一个类似于fmt.Stringer的内置接口。：\ntype error interface { Error() string } （与fmt.Stringer一样，fmt包在打印值时会查找error接口。） 函数通常返回一个错误值，调用代码应该通过测试错误是否等于零来处理错误。\ni, err := strconv.Atoi(\u0026#34;42\u0026#34;) if err != nil { fmt.Printf(\u0026#34;couldn\u0026#39;t convert number: %v\\n\u0026#34;, err) return } fmt.Println(\u0026#34;Converted integer:\u0026#34;, i) nil 表示成功；非 nil 表示失败。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) type MyError struct { When time.Time What string } func (e *MyError) Error() string { return fmt.Sprintf(\u0026#34;at %v, %s\u0026#34;, e.When, e.What) } func run() error { return \u0026amp;MyError{ time.Now(), \u0026#34;it didn\u0026#39;t work\u0026#34;, } } func main() { if err := run(); err != nil { fmt.Println(err) } } 练习：error 复制前面练习中的Sqrt函数，并对其进行修改以返回错误值。当给定负数时，Sqrt应该返回一个非零错误值，因为它不支持复数。创建新类型\ntype ErrNegativeSqrt float64 实现error 接口\nfunc (e ErrNegativeSqrt) Error() string 使得ErrNegativeSqrt（-2）.Error（）返回\u0026quot;cannot Sqrt negative number: -2\u0026quot;.。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;math\u0026#34; ) type ErrNegativeSqrt float64 func (e ErrNegativeSqrt) Error() string { return fmt.Sprintf(\u0026#34;cannot Sqrt negative number: %v\u0026#34;, float64(e)) } func Sqrt(x float64) (float64, error) { if x \u0026lt; 0 { return 0, ErrNegativeSqrt(x) } var z = 1.0 var old float64 for math.Abs(old-z) \u0026gt;= 0.000001 { old = z z -= (z*z - x) / (2 * z) } return z, nil } func main() { fmt.Println(Sqrt(2)) fmt.Println(Sqrt(-2)) } Reader 接口 io包指定io.Reader接口，该接口表示数据流的读取端。Go标准库包含该接口的许多实现，包括文件、网络连接、压缩器、密码等。io.Reader接口有一个Read方法：\nfunc (T) Read(b []byte) (n int, err error) Read用数据填充给定的字节片，并返回填充的字节数和错误值。当流结束时，它返回一个io.EOF错误。 示例代码创建一个strings.Reader，并一次消耗其输出的8个字节。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;strings\u0026#34; ) func main() { r := strings.NewReader(\u0026#34;Hello, Reader!\u0026#34;) b := make([]byte, 8) for { n, err := r.Read(b) fmt.Printf(\u0026#34;n = %v err = %v b = %v\\n\u0026#34;, n, err, b) fmt.Printf(\u0026#34;b[:n] = %q\\n\u0026#34;, b[:n]) if err == io.EOF { break } } } 练习：Reader 实现一个Reader类型，该类型发出ASCII字符“a”的无限流。 参考\npackage main import \u0026#34;golang.org/x/tour/reader\u0026#34; type MyReader struct{} // TODO: Add a Read([]byte) (int, error) method to MyReader. func (mr MyReader) Read(b []byte) (int, error) { for i := range b { b[i] = \u0026#39;A\u0026#39; } return len(b), nil } func main() { reader.Validate(MyReader{}) } 练习：rot13Reader 一种常见的模式是一个io.Reader，它包装另一个io.Leader，以某种方式修改流。例如，gzip.NewReader函数接受一个io.Reader（压缩数据流），并返回一个*gzip.Reader，该函数还实现了io.Readers（解压缩数据流）。实现一个rot13Reader，它实现io.Reader并从io.Readers读取，通过将rot13替换密码应用于所有字母字符来修改流。rot13Reader类型是为您提供的。通过实现它的Read方法，使它成为一个io.Reader。\npackage main import ( \u0026#34;io\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) type rot13Reader struct { r io.Reader } func (rr *rot13Reader) Read(p []byte) (n int, err error) { for { b := make([]byte, 1024, 2048) read, err1 := rr.r.Read(b) if err1 == io.EOF { break } for i, b2 := range b[:read] { p[i] = rot13byte(b2) } n += read } return n, nil } func rot13byte(b byte) byte { s := rune(b) if s \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s \u0026lt;= \u0026#39;m\u0026#39; || s \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; s \u0026lt;= \u0026#39;M\u0026#39; { b += 13 } if s \u0026gt;= \u0026#39;n\u0026#39; \u0026amp;\u0026amp; s \u0026lt;= \u0026#39;z\u0026#39; || s \u0026gt;= \u0026#39;N\u0026#39; \u0026amp;\u0026amp; s \u0026lt;= \u0026#39;Z\u0026#39; { b -= 13 } return b } func main() { s := strings.NewReader(\u0026#34;Lbh penpxrq gur pbqr!\u0026#34;) r := rot13Reader{s} io.Copy(os.Stdout, \u0026amp;r) } Images image 包定义 image 接口：\npackage image type Image interface { ColorModel() color.Model Bounds() Rectangle At(x, y int) color.Color } 注意：Bounds方法的Rectangle返回值实际上是一个图像。Rectangle，因为声明在包图像中。color.color和color.Model类型也是接口，但我们将通过使用预定义的实现color.RGBA和color.RGBAModel来忽略这一点。这些接口和类型由 image/color 包指定\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;image\u0026#34; ) func main() { m := image.NewRGBA(image.Rect(0, 0, 100, 100)) fmt.Println(m.Bounds()) fmt.Println(m.At(0, 0).RGBA()) } 练习：image 还记得你之前写的图片生成器吗？让我们再写一个，但这次它将返回image.image的实现，而不是数据切片。 定义您自己的图像类型，实现必要的方法，然后调用pic.ShowImage。 Bounds应该返回一个 image.Rectangle，类似于图像。矩形（0，0，w，h）。 ColorModel应返回color.RGBAModel。 At应该返回一种颜色；最后一个图片生成器中的值v对应于颜色。RGBA{v，v，255，255}。\npackage main import ( \u0026#34;image\u0026#34; \u0026#34;image/color\u0026#34; \u0026#34;golang.org/x/tour/pic\u0026#34; ) type Image struct{} func (i Image) ColorModel() color.Model { return color.RGBAModel } func (i Image) Bounds() image.Rectangle { return image.Rect(0, 0, 200, 200) } func (i Image) At(x, y int) color.Color { return color.RGBA{uint8(x % 255), uint8(y % 255), 255, 255} } func main() { m := Image{} pic.ShowImage(m) } "
},
{
	"uri": "http://blog.911015.com/wx/20230528.html",
	"title": " Go语言泛型入门",
	"tags": null,
	"description": "Go语言在 1.18中引入了对使用参数化类型的泛型代码的新支持。泛型是一种编写代码的方式，与所使用的特定类型无关。",
	"content": "Go语言泛型入门 Go语言在 1.18中引入了对使用参数化类型的泛型代码的新支持。泛型是一种编写代码的方式，与所使用的特定类型无关。函数和类型现在可以被编写为使用一组类型中的任何一个。本课展示了在代码中使用泛型的一些示例。\n类型参数泛型 Go函数可以使用类型参数让函数支持多个类型。函数的类型参数用中括号包裹，位于函数的参数之前。\nfunc Index[T comparable](s []T, x T) int 这个声明意味着s是任何类型T的一个切片，它满足comparable内置约束。x也是相同类型的值。 compatible是一个有用的约束，可以使用==和!=类型值上的运算符。在本例中，我们使用它将一个值与所有切片元素进行比较，直到找到匹配。此Index函数适用于任何支持比较的类型。\npackage main import \u0026#34;fmt\u0026#34; // Index returns the index of x in s, or -1 if not found. func Index[T comparable](s []T, x T) int { for i, v := range s { // v and x are type T, which has the comparable // constraint, so we can use == here. if v == x { return i } } return -1 } func main() { // Index works on a slice of ints si := []int{10, 20, 15, -10} fmt.Println(Index(si, 15)) // Index also works on a slice of strings ss := []string{\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;} fmt.Println(Index(ss, \u0026#34;hello\u0026#34;)) } 泛型类型 除了泛型函数外，Go还支持泛型类型。可以使用类型参数对类型进行参数化，这对于实现泛型数据结构非常有用。此示例演示了一个简单的类型\npackage main // List represents a singly-linked list that holds // values of any type. type List[T any] struct { next *List[T] val T } func main() { } 声明类型约束 我们可以将类型约束声明为接口。约束允许实现接口的任何类型。，以下代码声明类型约束：\ntype Number interface { int64 | float64 } 这样，类型参数约束为int64或float64时，可以使用此Number类型约束，而不是写出int64|float64。下面使用Number类型参数实现一个SumNumber函数\nfunc SumNumbers[K comparable, V Number](m map[K]V) V { var s V for _, v := range m { s += v } return s } 练习 实现一个泛型版求较小值的函数Min()，要求支持 int int8 int32 int64四种类型； 参考代码见Github\n"
},
{
	"uri": "http://blog.911015.com/wx/20230529.html",
	"title": " Go语言并发入门",
	"tags": null,
	"description": "Go提供的并发功能是核心语言的一部分。goroutine是一个由Go运行时管理的轻量级线程。",
	"content": "并发入门 Go提供的并发功能是核心语言的一部分。\nGoroutines goroutine是一个由Go运行时管理的轻量级线程。\ngo f(x, y, z) 开始运行新的goroutine f(x, y, z) f、x、y和z的求值发生在当前goroutine中，f的执行发生在新goroutine。 Goroutines在相同的地址空间中运行，因此对共享内存的访问必须同步。sync包提供了有用的并发原语，尽管Go中并不需要它们，因为还有其他基元。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func say(s string) { for i := 0; i \u0026lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(\u0026#34;world\u0026#34;) say(\u0026#34;hello\u0026#34;) } Channels Channel是一种类型化的管道，通过它可以使用通道操作符\u0026lt;-发送和接收值。\nch \u0026lt;- v // Send v to channel ch. v := \u0026lt;-ch // Receive from ch, and // assign value to v. 数据沿箭头方向流动。 与map和slice一样， channel必须在使用前初始化：\nch := make(chan int) 默认情况下，发送和接收块，直到对方准备好为止。这允许goroutine在没有显式锁或条件变量的情况下进行同步。\npackage main import \u0026#34;fmt\u0026#34; func sum(s []int, c chan int) { sum := 0 for _, v := range s { sum += v } c \u0026lt;- sum // send sum to c } func main() { s := []int{7, 2, 8, -9, 4, 0} c := make(chan int) go sum(s[:len(s)/2], c) go sum(s[len(s)/2:], c) x, y := \u0026lt;-c, \u0026lt;-c // receive from c fmt.Println(x, y, x+y) } 示例代码对一个切片中的数字求和，将工作分配到两个goroutine之间。一旦两个goroutine都完成了计算，它就会计算出最终结果。\nBuffered Channels 通道可以进行缓冲。提供缓冲区长度作为初始化缓冲通道的第二个参数：\nch := make(chan int, 100) 仅当缓冲区已满时发送到缓冲通道阻塞。缓冲区为空时接收阻塞。 修改示例以使缓冲区溢出，然后看看会发生什么。\npackage main import \u0026#34;fmt\u0026#34; func main() { ch := make(chan int, 2) ch \u0026lt;- 1 ch \u0026lt;- 2 fmt.Println(\u0026lt;-ch) fmt.Println(\u0026lt;-ch) } Range and Close 发送方可以关闭一个通道，以指示不再发送任何值。接收器可以通过为接收表达式分配第二个参数来测试通道是否已关闭：如下\nv, ok := \u0026lt;-ch 如果没有更多的值可接收并且通道已关闭，则ok为false。 还可以通过 i：=range c 的循环重复接收来自通道的值，直到通道关闭，循环退出。\npackage main import ( \u0026#34;fmt\u0026#34; ) func fibonacci(n int, c chan int) { x, y := 0, 1 for i := 0; i \u0026lt; n; i++ { c \u0026lt;- x x, y = y, x+y } close(c) } func main() { c := make(chan int, 10) go fibonacci(cap(c), c) for i := range c { fmt.Println(i) } } 注意：\n只有发送方应该关闭频道，而不是接收方。在关闭的频道上发送会引起panic。 channel不像文件；通常不需要关闭它们。只有当接收器必须被告知没有更多的值到来时，例如终止range循环时，才需要关闭。 Select select语句允许goroutine等待多个通信操作。 一个select阻塞，直到它的一个case可以运行，然后它执行那个case。如果多个case准备好了，它会随机选择一个。\npackage main import \u0026#34;fmt\u0026#34; func fibonacci(c, quit chan int) { x, y := 0, 1 for { select { case c \u0026lt;- x: x, y = y, x+y case \u0026lt;-quit: fmt.Println(\u0026#34;quit\u0026#34;) return } } } func main() { c := make(chan int) quit := make(chan int) go func() { for i := 0; i \u0026lt; 10; i++ { fmt.Println(\u0026lt;-c) } quit \u0026lt;- 0 }() fibonacci(c, quit) } 如果没有其他案例准备就绪，则选择中的默认案例将运行。使用默认情况尝试在不阻止的情况下发送或接收：\nselect { case i := \u0026lt;-c: // use i default: // receiving from c would block } package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { tick := time.Tick(100 * time.Millisecond) boom := time.After(500 * time.Millisecond) for { select { case \u0026lt;-tick: fmt.Println(\u0026#34;tick.\u0026#34;) case \u0026lt;-boom: fmt.Println(\u0026#34;BOOM!\u0026#34;) return default: fmt.Println(\u0026#34; .\u0026#34;) time.Sleep(50 * time.Millisecond) } } } Exercise: Equivalent Binary Trees 练习：等价二叉树 代码已同步仅供参考 github\nsync.Mutex 我们已经看到了channel对于goroutines之间的交流是多么的好。 但如果我们不需要通讯呢？如果我们只想确保一次只有一个goroutine可以访问一个变量以避免冲突，该怎么办？ 这个概念被称为互斥，提供互斥的数据结构的传统名称是_mutex_。 Go的标准库通过sync.Mutex及其两种方法提供互斥：\nLock Unlock 我们可以定义一个要在互斥中执行的代码块，方法是用Inc方法中所示的Lock和Unlock调用包围它。 我们还可以使用defer来确保互斥对象将像Value方法中那样被解锁。\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) // SafeCounter is safe to use concurrently. type SafeCounter struct { mu sync.Mutex v map[string]int } // Inc increments the counter for the given key. func (c *SafeCounter) Inc(key string) { c.mu.Lock() // Lock so only one goroutine at a time can access the map c.v. c.v[key]++ c.mu.Unlock() } // Value returns the current value of the counter for the given key. func (c *SafeCounter) Value(key string) int { c.mu.Lock() // Lock so only one goroutine at a time can access the map c.v. defer c.mu.Unlock() return c.v[key] } func main() { c := SafeCounter{v: make(map[string]int)} for i := 0; i \u0026lt; 1000; i++ { go c.Inc(\u0026#34;somekey\u0026#34;) } time.Sleep(time.Second) fmt.Println(c.Value(\u0026#34;somekey\u0026#34;)) } Exercise: Web Crawler（网络爬虫） 代码已同步仅供参考 Github\n"
},
{
	"uri": "http://blog.911015.com/contact.html",
	"title": "与我联系",
	"tags": null,
	"description": "联系方式",
	"content": "\rEmail：\rcreate98715@duck.com\rQQ：\r3336449889\r关注公众号领取Go学习资料\n关注公众号领取Go学习资料\n"
},
{
	"uri": "http://blog.911015.com/wx/",
	"title": "公众号文章",
	"tags": null,
	"description": "Go语言入门之路公众号文章",
	"content": "\rGo语言流程控制:Defer 编程语言这么多怎么选？ Go语言数据结构： Array 和Slice Go 语言数据结构：Maps Go 语言数据结构：结构体 Go 语言入门：方法 Go 语言中的接口：Interface Go语言泛型入门 Go语言并发入门 "
},
{
	"uri": "http://blog.911015.com/categories/",
	"title": "Categories",
	"tags": null,
	"description": "",
	"content": ""
},
{
	"uri": "http://blog.911015.com/tags/",
	"title": "Tags",
	"tags": null,
	"description": "",
	"content": ""
}]
