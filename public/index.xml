<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go语言入门</title>
    <link>http://blog.911015.com/</link>
    <description>Recent content on Go语言入门</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://blog.911015.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>01-Golang安装与体验</title>
      <link>http://blog.911015.com/beginner/01.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/beginner/01.html</guid>
      <description> 下载并安装按照一下步骤快速进行。 有关安装的其他内容，您可能对以下内容感兴趣：
Go多版本安装管理 &amp;ndash;如何安装多版本并卸载。 Go 源码安装 &amp;ndash; 如何下载源码并在自己的机器上编译安装Go。 下载地址在这里 go.dev/dl/ 各系统版本都有，下载一个与自己系统匹配的版本，可以选最新版本进行安装学习。
安装Go 选择下面对应的计算机操作系统，然后按照其安装说明进行操作。
Linux 删除/usr/local/Go文件夹（如果存在），删除以前的Go安装，然后将刚下载的存档提取到/usr/local中，在/usr/local/go: Copyrm -rf /usr/local/go &amp;amp;&amp;amp; tar -C /usr/local -xzf go1.20.4.linux-amd64.tar.gz （您可能需要以root用户身份或通过sudo运行该命令）。不要将归档文件解压缩到现有的/usr/local/go目录中。这会导致Go安装失败
将/usr/local/go/bin添加到PATH环境变量中 您可以通过将以内容添加到$HOME/.profile或/etc/profile（全局安装）来完成此操作：
Copyexport PATH=$PATH:/usr/local/go/bin **注意**：对配置文件所做的更改可能要等到下次登录计算机时才能应用。要立即应用更改，只需直接运行shell命令，或者使用`source $HOME/.profile` 等命令从概要文件中执行这些命令。3. 通过打开命令提示符并输入以下命令来验证是否已安装GoCopy$ go version 4. 确认该命令打印已安装的Go版本。Mac 打开下载的软件包文件，并按照提示安装Go 该软件包将Go安装到/usr/local/go。该包应该将/usr/local/go/bin目录放在PATH环境变量中。可能需要重新启动任何打开的终端会话才能使更改生效。
通过打开命令提示符并键入以下命令来验证是否已安装Go go version
确认该命令打印已安装的Go版本。 Window 1、打开您下载的MSI文件，并按照提示安装Go。 默认情况下，安装程序将安装Go到 Program Files或Program Files（x86）。您可以根据需要更改位置。安装后，您需要关闭并重新打开任何打开的命令提示符，以便在命令提示符下反映安装程序对环境所做的更改。
2、验证您是否已安装Go；
在Windows中，单击“开始”菜单。 在菜单的搜索框中，键入cmd，然后按Enter键。 在出现的“命令提示符”窗口中，键入以下命令： go version 确认该命令打印已安装的Go版本。 Reference Installing Go </description>
    </item>
    
    <item>
      <title>1、基础篇（一）：包、变量和方法</title>
      <link>http://blog.911015.com/tour/01.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/tour/01.html</guid>
      <description>包（ package） 每个Go项目都是由程序包组成的。 程序在main包中运行。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math/rand&amp;#34; ) func main() { fmt.Println(&amp;#34;My favorite number is&amp;#34;, rand.Intn(10)) } 此程序使用导入的“fmt”和“math/rand”包。 按照惯例，包名称为导入路径的最后一个元素。例如，“math/rand”包含以rand为包名的文件。
import 此代码将导入分组到一个带括号的的import语句中。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math&amp;#34; ) func main() { fmt.Printf(&amp;#34;Now you have %g problems.\n&amp;#34;, math.Sqrt(7)) } 您还可以编写多个import语句，如：
import &amp;#34;fmt&amp;#34; import &amp;#34;math&amp;#34; 但是，建议使用带括号的import语句。
导出名称 在 Go 中，如果名称以大写字母开头，则会导出该名称。例如，Pizza，Pi 是是从math包中导出的名称。 pizza并且pi不要以大写字母开头，因此它们不会被导出。 导入包时，您只能引用其导出的名称。任何“未导出”的名称都无法从包外部访问。 运行代码。请注意错误消息。 要修复错误，请重命名math.pi为math.Pi并重试。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math&amp;#34; ) func main() { fmt.Println(math.pi) } 函数/方法 (Functions) Functions 函数可以接受零个或多个参数。 在本例中，add接收两个int类型的参数。</description>
    </item>
    
    <item>
      <title>go-zero 单体应用实践（一）</title>
      <link>http://blog.911015.com/go-zero/01.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/go-zero/01.html</guid>
      <description>环境搭建 官方文档
Golang 环境安装 👉 golang Go Module设置 go env -w GO111MODULE=&amp;quot;on&amp;quot; goctl安装 👉 goctl protoc &amp;amp; protoc-gen-go安装 goctl env check -i -f --verbose etcd，redis，mysql 等开发工具可以通过Docker 快速搭建；可参考👉 gonivinck
创建单体应用 1、创建目录 mkdir user-login cd user-login go mod init user-login 2、编辑api文件 userlogin.api api语法介绍
type ( RegisterRequest { Name string `json:&amp;#34;name&amp;#34;` Email string `json:&amp;#34;email&amp;#34;` Password string `json:&amp;#34;password&amp;#34;` } RegisterResponse { ID int `json:&amp;#34;id&amp;#34;` Name string `json:&amp;#34;name&amp;#34;` Email string `json:&amp;#34;email&amp;#34;` } LoginRequest { Email string `json:&amp;#34;email&amp;#34;` Password string `json:&amp;#34;password&amp;#34;` } LoginResponse { Token string `json:&amp;#34;token&amp;#34;` Expire int64 `json:&amp;#34;expire&amp;#34;` } ) service userlogin-api { @handler RegisterHandler post /api/register(RegisterRequest) returns (RegisterResponse); @handler LoginHandler post /api/login(LoginRequest) returns (LoginResponse); } 3、执行生成代码命令 goctl api go -api userlogin.</description>
    </item>
    
    <item>
      <title>Go语言流程控制:Defer</title>
      <link>http://blog.911015.com/wx/2023052202.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/wx/2023052202.html</guid>
      <description>在 Golang 中，defer 是一个关键字，用于定义延迟执行函数。它可以将一个函数推迟到当前函数返回之后执行，即使该函数出现异常或错误也不会影响 defer 定义的代码块。
常见用例 以下是 defer 的一些常见用例： 1、关闭文件资源 使用 defer 关闭文件资源是一种非常常见的方法，可以确保无论代码中发生了什么，文件都能够被关闭。
f, err := os.Open(&amp;#34;/path/to/file&amp;#34;) if err != nil { log.Fatal(err) } defer f.Close() 2、记录耗时 我们可以在开始处理某个请求前调用 time.Now() 函数来记录起始时间，然后在退出函数时计算经过的时间并打印出来。
func processRequest(req *http.Request) { start := time.Now() defer logTime(start) // 处理请求 } func logTime(start time.Time) { log.Printf(&amp;#34;request took %v&amp;#34;, time.Since(start)) } 3、锁的释放 当我们在使用互斥锁时，必须确保每次获取锁后都要及时释放锁，否则会导致死锁的情况。使用 defer 语句可以确保在任何情况下都会释放锁。
var mu sync.Mutex func someFunc() { mu.Lock() defer mu.Unlock() // 执行一些需要锁定的操作 } 注意事项 在使用 defer 时，需要注意以下几个问题：</description>
    </item>
    
    <item>
      <title>02-新手入门</title>
      <link>http://blog.911015.com/beginner/02.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/beginner/02.html</guid>
      <description>在本教程中，您将获得Go编程的简要介绍
安装Go . 写一些简单的 &amp;ldquo;Hello, world&amp;rdquo; . 使用go命令运行代码. 使用Go程序包发现工具查找可以在自己的代码中使用的程序包. 调用外部模块的功能. 前期准备 一些编程经验。 这里的代码非常简单，但了解一些函数相关的知识会有所帮助。. 用于编辑代码的工具。** ** 任何文本编辑器都可以。大多数文本编辑器都很好地支持Go。最受欢迎的是VSCode（免费）、GoLand（付费）和Vim（免费）。 一个命令终端. Go在Linux和Mac上以及Windows中的PowerShell或cmd上使用任何终端都能很好地工作。 Hello World 按一下步骤写一段 “Hello World”代码
1、打开一个命令提示符并cd到您的主目录。 Linux/Mac 系统执行 : cd Window系统执行： cd %HOMEPATH%
2、为您的第一个Go源代码创建一个hello目录 可以使用一下命令：
mkdir hello cd hello 3、为代码启用依赖管理
当您的代码导入其他项目中的包（package）时，您可以通过自己的代码来管理这些模块的依赖关系。该模块由go.mod文件定义，通过该文件追踪提供包的这些模块。该go.mod文件与您的代码一起保存，包括在您的源代码存储库中。要通过创建go.mod文件为代码启用依赖管理，请运行go mod init+模块的名称 命令。该名称是模块的模块路径。在实际开发中，模块路径通常是保存源代码的存储仓库位置。例如，模块路径可能是github.com/mymodule。如果您计划发布您的模块供他人使用，则模块路径必须是Go工具可以下载您的模块的位置。对于本教程，只需使用example/hello。
go mod init example/hello go: creating new go.mod: module example/hello 4、在编辑器中，创建一个文件hello.go，在其中编写代码。 5、将以下代码粘贴到hello.go文件中并保存该文件。
package main import ( &amp;#34;fmt&amp;#34; ) func main() { fmt.Println(&amp;#34;Hello World（^-^）&amp;#34;) } 接下来看一下这段代码的内容：</description>
    </item>
    
    <item>
      <title>2、基础篇（二）：Go语言流程控制</title>
      <link>http://blog.911015.com/tour/02.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/tour/02.html</guid>
      <description>For Go只有一个循环结构，即for循环。
package main import &amp;#34;fmt&amp;#34; func main() { sum := 0 for i := 0; i &amp;lt; 10; i++ { sum += i } fmt.Println(sum) } 基本的for循环有三个用分号分隔的部分：
初始化语句：在第一次迭代之前执行 条件表达式：在每次迭代之前求值 后置语句：在每次循环结束时执行 初始化语句通常是一个简短的变量声明，在那里声明的变量只在for语句的范围内可见。 一旦条件表达式的计算结果为false，循环将停止迭代。 注意：与C、Java或JavaScript等其他语言不同，for语句的三个组件周围没有括号，并且必须要有大括号{}。 初始化语句和后置语句是可选的。如下：
package main import &amp;#34;fmt&amp;#34; func main() { sum := 1 for ; sum &amp;lt; 1000; { sum += sum } fmt.Println(sum) } 更进一步，还可以去掉分号：类似C语言中的的while那样，在Go中是用for实现的。如下：
package main import &amp;#34;fmt&amp;#34; func main() { sum := 1 for sum &amp;lt; 1000 { sum += sum } fmt.</description>
    </item>
    
    <item>
      <title>go-zero 单体应用实践（二）</title>
      <link>http://blog.911015.com/go-zero/02.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/go-zero/02.html</guid>
      <description>中间件使用 在go-zero中，中间件可以分为路由中间件和全局中间件，路由中间件是指某一些特定路由需要实现中间件逻辑，其和jwt类似，没有放在jwt:xxx下的路由不会使用中间件功能， 而全局中间件的服务范围则是整个服务。
路由中间件 1、编辑 api 文件 userlogin/userlogin.api 生命接口需要添加的中间件，多个中间件用逗号分隔
@server( middleware : Tagging,Version ) service userlogin-api { @handler Tags get /api/tags returns (TagResponse) } 2、goctl api 命令重新执行 生成middleware 文件
userlogin/internal/middleware/taggingmiddleware.go userlogin/internal/middleware/versionmiddleware.go 可以看到路由文件中userlogin/internal/handler/routes.go 新增了一下代码
server.AddRoutes( rest.WithMiddlewares( []rest.Middleware{serverCtx.Tagging, serverCtx.Version}, []rest.Route{ { Method: http.MethodGet, Path: &amp;#34;/api/tags&amp;#34;, Handler: TagsHandler(serverCtx), }, }..., ), ) 3、 文件中添加中间件依赖 userlogin/internal/svc/servicecontext.go
type ServiceContext struct { Config config.Config Tagging rest.Middleware Version rest.Middleware UserModel user.UserModel } func NewServiceContext(c config.Config) *ServiceContext { conn := sqlx.</description>
    </item>
    
    <item>
      <title>编程语言这么多怎么选？</title>
      <link>http://blog.911015.com/wx/2023052201.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/wx/2023052201.html</guid>
      <description>Go Go是一种由Google开发的编程语言。其主要特点包括：
静态类型：在编译时检查类型，可以提供更好的代码健壮性。 并发编程：支持Goroutines（轻量级线程）和Channels（通信机制），使并发编程变得简单。 内存管理：Go具有自动垃圾回收机制，可以减少内存泄漏问题。 Go的生态系统正在快速增长，有许多优秀的开源库和框架可供使用。它非常适合云原生应用的开发，如Docker等。较新的Web框架，例如Gin和Echo，也使Go在Web开发中越来越受欢迎。 在性能方面，Go比动态语言更快，但比C++等系统级语言稍慢。 Go的学习曲线较为平稳，对于具有其他编程经验的开发人员来说相对容易上手。
PHP PHP是一种广泛用于Web开发的动态类型语言。其主要特点包括：
动态类型：无需在编写代码时指定变量类型，使代码更加灵活。 便于Web开发：PHP具有许多与Web相关的函数和库，如文件上传、会话管理等。 面向对象编程：支持面向对象编程风格，使代码更加易于维护。 PHP生态系统非常丰富，包括许多流行的Web框架和CMS平台，例如Laravel和WordPress。这些工具可使Web开发更加高效。 在性能方面，PHP比静态语言慢，但可以通过各种缓存技术（如APC和OPcache）提高性能。 PHP学习曲线相对较低，因此非常适合初学者或那些想快速入门Web开发的人选择。
Java Java是一种强类型的跨平台语言，并且具有以下特点：
静态类型：在编译时检查类型，使代码更加健壮。 跨平台：Java字节码可以在任何支持Java的操作系统上运行。 面向对象编程：支持类和对象，使得代码更易于维护。 Java的生态系统非常丰富，涵盖了众多企业应用程序框架，例如Spring和Hibernate。这些框架可帮助开发人员快速构建稳健的企业级应用程序。 在性能方面，Java比动态语言快，但启动时间较长。 相对于其他语言，Java的学习曲线中等。因为它有一个强大的库和框架生态系统，需要一些时间来理解和掌握这些技术。
Python Python是一种动态类型语言，用于各种用途，包括数据分析、机器学习、Web开发等。其主要特点包括：
动态类型：无需在编写代码时指定变量类型，使代码更灵活。 简洁易读：Python具有清晰简单的语法，使得代码易于阅读和编写。 自然语言处理和数据科学：Python具有丰富的库和工具，如NumPy、pandas和scikit-learn等，使得数据科学工作变得更加容易。 Python生态系统非常丰富，包括许多科学计算库和Web框架，例如Django和Flask。Python也是自然语言处理领域的首选语言。 在性能方面，Python比静态语言慢，但对于普通计算任务而言，其代码实现更为容易。另外，Python可以通过JIT编译器（如PyPy）提高性能。 相对于其他语言，Python的学习曲线较浅，适合初学者或那些希望快速入门数据科学或Web开发的人选择。
C++ C++是一种静态类型语言，常用于底层编程和高性能计算任务。其主要特点包括：
静态类型：在编译时检查类型，可以提供更好的代码健壮性。 高性能：C++可以直接操作硬件，因此可以实现非常高效的代码。 底层编程：C++没有自动垃圾回收机制，使得程序员需要手动管理内存，并且可以进行指针操作等底层编程技术。 C++的生态系统虽然不如其他语言那么丰富，但它有许多优秀的基础设施库和跨平台工具，如Boost和Qt等。 在性能方面，C++是最快的语言之一，因为它可以直接操作硬件和内存。 相对于其他语言，C++的学习曲线较陡峭。它需要更多的时间和精力来掌握，因为它具有底层编程技术和复杂的内存管理要求。
语言 语言特性 生态系统 性能 学习难度 Go 静态类型、并发编程、内存管理 快速增长的开源库和框架，适合云原生应用 比动态语言快，但比C++等系统级语言稍慢 中等 PHP 动态类型、便于Web开发、面向对象编程 丰富的Web生态系统，如WordPress 比静态语言慢，但可以通过各种缓存技术提高性能 简单 Java 静态类型、跨平台、面向对象编程 丰富的企业应用生态系统，如Spring、Hibernate等 比动态语言快，但启动时间较长 中等 Python 动态类型、简洁易读、自然语言处理、数据科学 丰富的科学计算生态系统，如NumPy、pandas、scikit-learn等 比静态语言慢，但普通计算任务易于实现 简单 C++ 静态类型、高性能、底层编程 丰富的基础设施生态系统，如Boost 最接近硬件的语言之一，性能最高 困难 总体而言，Go、Java和Python是比较流行的语言，它们都有丰富的生态系统，并且相对于C++来说学习难度较低。其中，Go具有出色的并发编程能力，适合云原生应用开发；Java是企业级开发的首选语言；Python则在数据科学和自然语言处理方面得到广泛应用。PHP则是一种简单易学的Web开发语言，而C++则适合底层编程和高性能计算任务。当然，选择哪种语言取决于具体的需求和项目要求。</description>
    </item>
    
    <item>
      <title>03-创建Go项目</title>
      <link>http://blog.911015.com/beginner/03.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/beginner/03.html</guid>
      <description>这是教程的第一部分，介绍了Go语言的一些基本功能。如果你刚开始使用Go语言，一定要看一下教程：Go入门，它介绍了Go命令、Go模块和非常简单的Go代码。 在本教程中，您将创建两个模块。第一种是用来被其他库或应用导入。第二个模块在程序中调用第一个模块的方法。 本教程包括七个小的部分：
创建一个模块：编写一个小模块，其中包含可以从另一个模块调用的函数。 从另一个模块调用您的代码：导入并使用您的新模块。 返回并处理错误：添加简单的错误处理。 返回一个随机的问候语：处理切片（slices）中的数据（slices：Go的动态大小数组）。 为多个人返回问候语：将键/值对存储在映射（map）中。 添加测试：使用Go内置的单元测试功能来测试代码。 编译并安装应用程序：在本地编译并安装。 前期准备 一些编程经验。这里的代码非常简单，但了解函数、循环和数组会有所帮助。 用于编辑代码的工具。 一种命令终端。Go在Linux和Mac上以及Windows中的PowerShell或cmd上使用任何终端都能很好地工作。 开始创建模块 首先创建Go模块。我们通常会把一些包含同一类功能函数的包放在同一模块中，例如，您可以创建模块，模块的包具有进行财务分析的功能，以便其他编写财务应用程序的人可以使用您的代码。有关开发模块的更多信息，请参阅开发和发布模块.。 Go语言中 代码，包(package)，模块（module）之间的关系是:代码组成包，包组成模块。您开发的模块需要指定运行代码所需的依赖项，包括Go版本及其所需的其他模块。 当您在模块中添加或改进功能时，您将发布模块的新版本。编写调用这个模块的开发人员可以导入新版本模块，并在将其上线之前使用新版本进行测试。
打开命令行，cd到home目录（或其他存放代码的目录） 新建目录 greetings 用来存放Go代码 使用 go mod init 命令初始化一个module 执行 go mod init 命令；本例中我们用 example.com/greetings；如果您发布模块，这必须是Go工具可以下载模块的路径，那就是本模块代码仓库的路径（例如：github.com/example）；
go mod init example.com/greetings # go: creating new go.mod: module example.com/greetings go mod init 命令创建一个go.mod文件来跟踪代码的依赖关系。到目前为止，该文件只包括模块的名称和代码支持的Go版本。但当你添加依赖项时，go.mod文件会列出你的代码所依赖的版本。这可以保持构建的可复制性，并让你直接控制要使用的模块版本。
在编辑器中新建 greetings.go 文件 在greetings.go文件中写入一下代码并保存 package greetings import &amp;#34;fmt&amp;#34; // Hello returns a greeting for the named person. func Hello(name string) string { // Return a greeting that embeds the name in a message.</description>
    </item>
    
    <item>
      <title>3、基础篇（三）：更多类型: struct, slices, 和 map</title>
      <link>http://blog.911015.com/tour/03.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/tour/03.html</guid>
      <description>指针 Go提供了指针类型。指针保存的是一个值的内存地址。 类型*T是指向T值的指针。它的零值为nil。
var p *int &amp;amp;运算符生成指向其操作数的指针。
i := 42 p = &amp;amp;i *运算符表示指针的基本值。
fmt.Println(*p) // read i through the pointer p *p = 21 // set i through the pointer p 与C不同，Go没有指针运算。
package main import &amp;#34;fmt&amp;#34; func main() { i, j := 42, 2701 p := &amp;amp;i // point to i fmt.Println(*p) // read i through the pointer *p = 21 // set i through the pointer fmt.Println(i) // see the new value of i p = &amp;amp;j // point to j *p = *p / 37 // divide j through the pointer fmt.</description>
    </item>
    
    <item>
      <title>go-zero 单体应用实践（三）</title>
      <link>http://blog.911015.com/go-zero/03.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/go-zero/03.html</guid>
      <description>列表数据分页 1、api 定义 Pager api 可以单独一个文件；此时 userlogin.api 需要 import &amp;ldquo;api/pager.api&amp;rdquo;
Pager { Page int `form:&amp;#34;page,default=1&amp;#34;` PageSize int `form:&amp;#34;page_size,default=10&amp;#34;` TotalSize int `form:&amp;#34;total_size,default=0&amp;#34;` } TagListRequest { Name string `form:&amp;#34;name,optional&amp;#34;` Pager } TagListResponse { List []TagResponse `json:&amp;#34;list&amp;#34;` Matedata Pager `json:&amp;#34;matedata&amp;#34;` } service userlogin-api { @handler Tags get /api/tag/list(TagListRequest) returns (TagListResponse) } 2、model 文件：BlogTagModel增加TageList方法；同时 customBlogTagModel.TagList 实现具体逻辑
BlogTagModel interface { blogTagModel TagList(context.Context, *types.TagListRequest) (*types.TagListResponse, error) } func (c *customBlogTagModel) TagList(ctx context.Context, request *types.TagListRequest) (*types.TagListResponse, error) { result := &amp;amp;types.</description>
    </item>
    
    <item>
      <title>04-入门多模块工作区</title>
      <link>http://blog.911015.com/beginner/04.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/beginner/04.html</guid>
      <description>本教程介绍了 Go 中多模块工作区的基础知识。使用多模块工作区，您可以告诉 Go 命令您正在同时在多个模块中编写代码，并轻松地在这些模块中构建和运行代码。 在本教程中，您将在共享的多模块工作区中创建两个模块，对这些模块进行更改，并在构建中查看这些更改的结果。
前期准备 安装 Go 1.18 或更高版本。 一个编辑代码的工具。 一个命令终端。 本教程需要** go1.18** 或更高版本。使用go.dev/dl中的链接确保您已在 Go 1.18 或更高版本中安装了 Go 。
创建一个模块 首先，为您要编写的代码创建一个模块。 一、打开命令提示符并切换到您的主目录。
# Linux 或 Mac： $ cd # Windows： C:\&amp;gt; cd %HOMEPATH% 本教程的其余部分将显示 $ 作为提示符。您使用的命令也适用于 Windows。
二、在命令提示符下，创建workspace目录。
$ mkdir workspace $ cd workspace 三、初始化模块
本示例将创建一个依赖 golang.org/x/example 模块的hello 模块。
1、创建 hello 模块：
$ mkdir hello $ cd hello $ go mod init example.com/hello go: creating new go.mod: module example.</description>
    </item>
    
    <item>
      <title>4、方法与接口</title>
      <link>http://blog.911015.com/tour/04.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/tour/04.html</guid>
      <description>Methods Go没有类。但是，您可以在类型上定义方法。 方法是一个具有特殊接收器参数的函数。 接收器出现在自己的参数列表中，位于func关键字和方法名称之间。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math&amp;#34; ) type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.Println(v.Abs()) } 在这个例子中，Abs方法有一个名为v的Vertex类型的接收器。 请记住：方法只是一个带有接收器参数的函数。下面的Abs是作为一个普通函数编写的，函数本身没有变化。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math&amp;#34; ) type Vertex struct { X, Y float64 } func Abs(v Vertex) float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.</description>
    </item>
    
    <item>
      <title>go-zero 微服务应用实践（一）</title>
      <link>http://blog.911015.com/go-zero/04.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/go-zero/04.html</guid>
      <description>简介 go-zero 是一个集成了各种工程实践的 web 和 rpc 框架。通过弹性设计保障了大并发服务端的稳定性，经受了充分的实战检验。
本节将用go-zero 开发一个用户服务；主要包括注册、登录、用户信息查询功能
初始化项目 //创建目录 madir project &amp;amp;&amp;amp; cd project //初始化项目 go mod init project 用户服务 0、环境准备 protoc &amp;amp; protoc-gen-go安装
protoc是一款用C++编写的工具，其可以将proto文件翻译为指定语言的代码。在go-zero的微服务中，我们采用grpc进行服务间的通信，而grpc的编写就需要用到protoc和翻译成go语言rpc stub代码的插件protoc-gen-go。
1、创建proto 文件 user/rpc/user.proto
syntax = &amp;#34;proto3&amp;#34;; package user; option go_package = &amp;#34;./user&amp;#34;; message RegisterRequest { string Name = 1; int64 Gender = 2; string Email = 3; string Password = 4; } message RegisterResponse { int64 Id = 1; string Name = 2; int64 Gender = 3; string Email = 4; } message LoginRequest { string Email = 1; string Password = 2; } message LoginResponse { int64 Id = 1; string Name = 2; int64 Gender = 3; string Email = 4; } message UserInfoRequest { int64 Id = 1; } message UserInfoResponse { int64 Id = 1; string Name = 2; int64 Gender = 3; string Email = 4; } service User { rpc Register(RegisterRequest) returns(RegisterResponse); rpc Login(LoginRequest) returns(LoginResponse); rpc UserInfo(UserInfoRequest) returns(UserInfoResponse); } 2、创建 user/generate.</description>
    </item>
    
    <item>
      <title>5、泛型</title>
      <link>http://blog.911015.com/tour/05.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/tour/05.html</guid>
      <description>Go支持使用类型参数进行泛型编程。本课展示了在代码中使用泛型的一些示例。
类型参数 Go函数可以使用类型参数让函数支持多个类型。函数的类型参数用中括号包裹，位于函数的参数之前。
func Index[T comparable](s []T, x T) int 这个声明意味着s是任何类型T的一个切片，它满足comparable内置约束。x也是相同类型的值。 compatible是一个有用的约束，可以使用==和！=类型值上的运算符。在本例中，我们使用它将一个值与所有切片元素进行比较，直到找到匹配。此Index函数适用于任何支持比较的类型。
package main import &amp;#34;fmt&amp;#34; // Index returns the index of x in s, or -1 if not found. func Index[T comparable](s []T, x T) int { for i, v := range s { // v and x are type T, which has the comparable // constraint, so we can use == here. if v == x { return i } } return -1 } func main() { // Index works on a slice of ints si := []int{10, 20, 15, -10} fmt.</description>
    </item>
    
    <item>
      <title>go-zero 微服务应用实践（二）</title>
      <link>http://blog.911015.com/go-zero/05.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/go-zero/05.html</guid>
      <description>服务调用 完成rpc访问功能后，还需要进行客户端调用，会用到goctl 的api功能；创建api目录编写api文件；api相关语法可以参考官方文档：api语法介绍
1、API文件编写 其中 登录注册增加了参数验证，使用 validator 包进行验证详细使用方法可以到 github.com/go-playground/validator 查看
syntax = &amp;#34;v1&amp;#34; type ( LoginRequest { Email string `json:&amp;#34;Email&amp;#34; validate:&amp;#34;required,email&amp;#34;` Password string `json:&amp;#34;password&amp;#34; validate:&amp;#34;required,gte=8&amp;#34;` } LoginResponse { AccessToken string `json:&amp;#34;accessToken&amp;#34;` AccessExpire int64 `json:&amp;#34;accessExpire&amp;#34;` } RegisterRequest { Name string `json:&amp;#34;name&amp;#34; validate:&amp;#34;required,gte=2,lte=20&amp;#34;` Gender int64 `json:&amp;#34;gender&amp;#34; validate:&amp;#34;oneof=1 2&amp;#34;` Email string `json:&amp;#34;Email&amp;#34; validate:&amp;#34;required,email&amp;#34;` Password string `json:&amp;#34;password&amp;#34; validate:&amp;#34;required,gte=8&amp;#34;` } RegisterResponse { Id int64 `json:&amp;#34;id&amp;#34;` Name string `json:&amp;#34;name&amp;#34;` Gender int64 `json:&amp;#34;gender&amp;#34;` Email string `json:&amp;#34;Email&amp;#34;` } UserInfoRequest { } UserInfoResponse { Id int64 `json:&amp;#34;id&amp;#34;` Name string `json:&amp;#34;name&amp;#34;` Gender int64 `json:&amp;#34;gender&amp;#34;` Email string `json:&amp;#34;Email&amp;#34;` } ) service User { @handler Login post /api/user/login(LoginRequest) returns (LoginResponse) @handler Register post /api/user/register(RegisterRequest) returns (RegisterResponse) } @server( jwt: Auth ) service User { @handler UserInfo post /api/user/userinfo(UserInfoRequest) returns (UserInfoResponse) } 2、执行goctl命令 goctl api go -api .</description>
    </item>
    
    <item>
      <title>6、并发</title>
      <link>http://blog.911015.com/tour/06.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/tour/06.html</guid>
      <description>Go提供的并发功能是核心语言的一部分。
Goroutines goroutine是一个由Go运行时管理的轻量级线程。
go f(x, y, z) 开始运行新的goroutine f(x, y, z) f、x、y和z的求值发生在当前goroutine中，f的执行发生在新goroutine。 Goroutines在相同的地址空间中运行，因此对共享内存的访问必须同步。sync包提供了有用的并发原语，尽管Go中并不需要它们，因为还有其他基元。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func say(s string) { for i := 0; i &amp;lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(&amp;#34;world&amp;#34;) say(&amp;#34;hello&amp;#34;) } Channels Channel是一种类型化的管道，通过它可以使用通道操作符&amp;lt;-发送和接收值。
ch &amp;lt;- v // Send v to channel ch. v := &amp;lt;-ch // Receive from ch, and // assign value to v. 数据沿箭头方向流动。 与map和slice一样， channel必须在使用前初始化：</description>
    </item>
    
    <item>
      <title>与我联系</title>
      <link>http://blog.911015.com/contact.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/contact.html</guid>
      <description>Email： create98715@duck.com QQ： 3336449889 关注公众号领取Go学习资料
关注公众号领取Go学习资料</description>
    </item>
    
  </channel>
</rss>
