<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go语言入门</title>
    <link>http://blog.911015.com/</link>
    <description>Recent content on Go语言入门</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://blog.911015.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>01-Golang安装与体验</title>
      <link>http://blog.911015.com/beginner/01.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/beginner/01.html</guid>
      <description> 下载并安装按照一下步骤快速进行。 有关安装的其他内容，您可能对以下内容感兴趣：
Go多版本安装管理 &amp;ndash;如何安装多版本并卸载。 Go 源码安装 &amp;ndash; 如何下载源码并在自己的机器上编译安装Go。 下载地址在这里 go.dev/dl/ 各系统版本都有，下载一个与自己系统匹配的版本，可以选最新版本进行安装学习。
安装Go 选择下面对应的计算机操作系统，然后按照其安装说明进行操作。
Linux 删除/usr/local/Go文件夹（如果存在），删除以前的Go安装，然后将刚下载的存档提取到/usr/local中，在/usr/local/go: Copyrm -rf /usr/local/go &amp;amp;&amp;amp; tar -C /usr/local -xzf go1.20.4.linux-amd64.tar.gz （您可能需要以root用户身份或通过sudo运行该命令）。不要将归档文件解压缩到现有的/usr/local/go目录中。这会导致Go安装失败
将/usr/local/go/bin添加到PATH环境变量中 您可以通过将以内容添加到$HOME/.profile或/etc/profile（全局安装）来完成此操作：
Copyexport PATH=$PATH:/usr/local/go/bin **注意**：对配置文件所做的更改可能要等到下次登录计算机时才能应用。要立即应用更改，只需直接运行shell命令，或者使用`source $HOME/.profile` 等命令从概要文件中执行这些命令。3. 通过打开命令提示符并输入以下命令来验证是否已安装GoCopy$ go version 4. 确认该命令打印已安装的Go版本。Mac 打开下载的软件包文件，并按照提示安装Go 该软件包将Go安装到/usr/local/go。该包应该将/usr/local/go/bin目录放在PATH环境变量中。可能需要重新启动任何打开的终端会话才能使更改生效。
通过打开命令提示符并键入以下命令来验证是否已安装Go go version
确认该命令打印已安装的Go版本。 Window 1、打开您下载的MSI文件，并按照提示安装Go。 默认情况下，安装程序将安装Go到 Program Files或Program Files（x86）。您可以根据需要更改位置。安装后，您需要关闭并重新打开任何打开的命令提示符，以便在命令提示符下反映安装程序对环境所做的更改。
2、验证您是否已安装Go；
在Windows中，单击“开始”菜单。 在菜单的搜索框中，键入cmd，然后按Enter键。 在出现的“命令提示符”窗口中，键入以下命令： go version 确认该命令打印已安装的Go版本。 Reference Installing Go </description>
    </item>
    
    <item>
      <title>1、基础篇（一）：包、变量和方法</title>
      <link>http://blog.911015.com/tour/01.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/tour/01.html</guid>
      <description>包（ package） 每个Go项目都是由程序包组成的。 程序在main包中运行。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math/rand&amp;#34; ) func main() { fmt.Println(&amp;#34;My favorite number is&amp;#34;, rand.Intn(10)) } 此程序使用导入的“fmt”和“math/rand”包。 按照惯例，包名称为导入路径的最后一个元素。例如，“math/rand”包含以rand为包名的文件。
import 此代码将导入分组到一个带括号的的import语句中。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math&amp;#34; ) func main() { fmt.Printf(&amp;#34;Now you have %g problems.\n&amp;#34;, math.Sqrt(7)) } 您还可以编写多个import语句，如：
import &amp;#34;fmt&amp;#34; import &amp;#34;math&amp;#34; 但是，建议使用带括号的import语句。
导出名称 在 Go 中，如果名称以大写字母开头，则会导出该名称。例如，Pizza，Pi 是是从math包中导出的名称。 pizza并且pi不要以大写字母开头，因此它们不会被导出。 导入包时，您只能引用其导出的名称。任何“未导出”的名称都无法从包外部访问。 运行代码。请注意错误消息。 要修复错误，请重命名math.pi为math.Pi并重试。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math&amp;#34; ) func main() { fmt.Println(math.pi) } 函数/方法 (Functions) Functions 函数可以接受零个或多个参数。 在本例中，add接收两个int类型的参数。</description>
    </item>
    
    <item>
      <title>go-zero 单体应用实践（一）</title>
      <link>http://blog.911015.com/go-zero/01.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/go-zero/01.html</guid>
      <description>环境搭建 官方文档
Golang 环境安装 👉 golang Go Module设置 go env -w GO111MODULE=&amp;quot;on&amp;quot; goctl安装 👉 goctl protoc &amp;amp; protoc-gen-go安装 goctl env check -i -f --verbose etcd，redis，mysql 等开发工具可以通过Docker 快速搭建；可参考👉 gonivinck
创建单体应用 1、创建目录 mkdir user-login cd user-login go mod init user-login 2、编辑api文件 userlogin.api api语法介绍
type ( RegisterRequest { Name string `json:&amp;#34;name&amp;#34;` Email string `json:&amp;#34;email&amp;#34;` Password string `json:&amp;#34;password&amp;#34;` } RegisterResponse { ID int `json:&amp;#34;id&amp;#34;` Name string `json:&amp;#34;name&amp;#34;` Email string `json:&amp;#34;email&amp;#34;` } LoginRequest { Email string `json:&amp;#34;email&amp;#34;` Password string `json:&amp;#34;password&amp;#34;` } LoginResponse { Token string `json:&amp;#34;token&amp;#34;` Expire int64 `json:&amp;#34;expire&amp;#34;` } ) service userlogin-api { @handler RegisterHandler post /api/register(RegisterRequest) returns (RegisterResponse); @handler LoginHandler post /api/login(LoginRequest) returns (LoginResponse); } 3、执行生成代码命令 goctl api go -api userlogin.</description>
    </item>
    
    <item>
      <title>Go语言流程控制:Defer</title>
      <link>http://blog.911015.com/wx/2023052202.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/wx/2023052202.html</guid>
      <description>在 Golang 中，defer 是一个关键字，用于定义延迟执行函数。它可以将一个函数推迟到当前函数返回之后执行，即使该函数出现异常或错误也不会影响 defer 定义的代码块。
常见用例 以下是 defer 的一些常见用例： 1、关闭文件资源 使用 defer 关闭文件资源是一种非常常见的方法，可以确保无论代码中发生了什么，文件都能够被关闭。
f, err := os.Open(&amp;#34;/path/to/file&amp;#34;) if err != nil { log.Fatal(err) } defer f.Close() 2、记录耗时 我们可以在开始处理某个请求前调用 time.Now() 函数来记录起始时间，然后在退出函数时计算经过的时间并打印出来。
func processRequest(req *http.Request) { start := time.Now() defer logTime(start) // 处理请求 } func logTime(start time.Time) { log.Printf(&amp;#34;request took %v&amp;#34;, time.Since(start)) } 3、锁的释放 当我们在使用互斥锁时，必须确保每次获取锁后都要及时释放锁，否则会导致死锁的情况。使用 defer 语句可以确保在任何情况下都会释放锁。
var mu sync.Mutex func someFunc() { mu.Lock() defer mu.Unlock() // 执行一些需要锁定的操作 } 注意事项 在使用 defer 时，需要注意以下几个问题：</description>
    </item>
    
    <item>
      <title>一、Hello World</title>
      <link>http://blog.911015.com/grpc/01.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/grpc/01.html</guid>
      <description>一个高性能、开源的通用RPC框架 A high performance, open source universal RPC framework
一、环境配置 1、下载并安装 protocol-buffers 2、安装Go语言插件
go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.28 go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.2
3、创建GRPC项目目录：
mkdir grpc-demo go mod init grpc-demo
二、创建并编译proto 文件 hello/proto/helloworld.proto
Protobuf 中 除了支持如double、float、 int32、int64、 uint32、uint64、 bool、 string 和bytes 等基本数据类型还支持enum，oneof，map，repeated 等类型；更详细的Protobuf文档可以查阅 ：protocol-buffers 文档
syntax = &amp;#34;proto3&amp;#34;; package helloworld; option go_package = &amp;#34;proto/;proto&amp;#34;; service Greeter { rpc SayHello(HelloRequest) returns (HelloReply) {}; } enum Gender { Unknown = 0; Female = 1; Male = 2; } message HelloRequest { string name = 1; int64 age = 2; oneof call { string mobile = 3; string phone = 4; } map&amp;lt;int64,string&amp;gt; role = 5; Gender gender = 6; } message HelloReply { string message = 1; } 创建好proto文件后执行编译命令，生成go文件代码</description>
    </item>
    
    <item>
      <title>02-新手入门</title>
      <link>http://blog.911015.com/beginner/02.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/beginner/02.html</guid>
      <description>在本教程中，您将获得Go编程的简要介绍
安装Go . 写一些简单的 &amp;ldquo;Hello, world&amp;rdquo; . 使用go命令运行代码. 使用Go程序包发现工具查找可以在自己的代码中使用的程序包. 调用外部模块的功能. 前期准备 一些编程经验。 这里的代码非常简单，但了解一些函数相关的知识会有所帮助。. 用于编辑代码的工具。** ** 任何文本编辑器都可以。大多数文本编辑器都很好地支持Go。最受欢迎的是VSCode（免费）、GoLand（付费）和Vim（免费）。 一个命令终端. Go在Linux和Mac上以及Windows中的PowerShell或cmd上使用任何终端都能很好地工作。 Hello World 按一下步骤写一段 “Hello World”代码
1、打开一个命令提示符并cd到您的主目录。 Linux/Mac 系统执行 : cd Window系统执行： cd %HOMEPATH%
2、为您的第一个Go源代码创建一个hello目录 可以使用一下命令：
mkdir hello cd hello 3、为代码启用依赖管理
当您的代码导入其他项目中的包（package）时，您可以通过自己的代码来管理这些模块的依赖关系。该模块由go.mod文件定义，通过该文件追踪提供包的这些模块。该go.mod文件与您的代码一起保存，包括在您的源代码存储库中。要通过创建go.mod文件为代码启用依赖管理，请运行go mod init+模块的名称 命令。该名称是模块的模块路径。在实际开发中，模块路径通常是保存源代码的存储仓库位置。例如，模块路径可能是github.com/mymodule。如果您计划发布您的模块供他人使用，则模块路径必须是Go工具可以下载您的模块的位置。对于本教程，只需使用example/hello。
go mod init example/hello go: creating new go.mod: module example/hello 4、在编辑器中，创建一个文件hello.go，在其中编写代码。 5、将以下代码粘贴到hello.go文件中并保存该文件。
package main import ( &amp;#34;fmt&amp;#34; ) func main() { fmt.Println(&amp;#34;Hello World（^-^）&amp;#34;) } 接下来看一下这段代码的内容：</description>
    </item>
    
    <item>
      <title>2、基础篇（二）：Go语言流程控制</title>
      <link>http://blog.911015.com/tour/02.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/tour/02.html</guid>
      <description>For Go只有一个循环结构，即for循环。
package main import &amp;#34;fmt&amp;#34; func main() { sum := 0 for i := 0; i &amp;lt; 10; i++ { sum += i } fmt.Println(sum) } 基本的for循环有三个用分号分隔的部分：
初始化语句：在第一次迭代之前执行 条件表达式：在每次迭代之前求值 后置语句：在每次循环结束时执行 初始化语句通常是一个简短的变量声明，在那里声明的变量只在for语句的范围内可见。 一旦条件表达式的计算结果为false，循环将停止迭代。 注意：与C、Java或JavaScript等其他语言不同，for语句的三个组件周围没有括号，并且必须要有大括号{}。 初始化语句和后置语句是可选的。如下：
package main import &amp;#34;fmt&amp;#34; func main() { sum := 1 for ; sum &amp;lt; 1000; { sum += sum } fmt.Println(sum) } 更进一步，还可以去掉分号：类似C语言中的的while那样，在Go中是用for实现的。如下：
package main import &amp;#34;fmt&amp;#34; func main() { sum := 1 for sum &amp;lt; 1000 { sum += sum } fmt.</description>
    </item>
    
    <item>
      <title>go-zero 单体应用实践（二）</title>
      <link>http://blog.911015.com/go-zero/02.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/go-zero/02.html</guid>
      <description>中间件使用 在go-zero中，中间件可以分为路由中间件和全局中间件，路由中间件是指某一些特定路由需要实现中间件逻辑，其和jwt类似，没有放在jwt:xxx下的路由不会使用中间件功能， 而全局中间件的服务范围则是整个服务。
路由中间件 1、编辑 api 文件 userlogin/userlogin.api 生命接口需要添加的中间件，多个中间件用逗号分隔
@server( middleware : Tagging,Version ) service userlogin-api { @handler Tags get /api/tags returns (TagResponse) } 2、goctl api 命令重新执行 生成middleware 文件
userlogin/internal/middleware/taggingmiddleware.go userlogin/internal/middleware/versionmiddleware.go 可以看到路由文件中userlogin/internal/handler/routes.go 新增了一下代码
server.AddRoutes( rest.WithMiddlewares( []rest.Middleware{serverCtx.Tagging, serverCtx.Version}, []rest.Route{ { Method: http.MethodGet, Path: &amp;#34;/api/tags&amp;#34;, Handler: TagsHandler(serverCtx), }, }..., ), ) 3、 文件中添加中间件依赖 userlogin/internal/svc/servicecontext.go
type ServiceContext struct { Config config.Config Tagging rest.Middleware Version rest.Middleware UserModel user.UserModel } func NewServiceContext(c config.Config) *ServiceContext { conn := sqlx.</description>
    </item>
    
    <item>
      <title>二、Streaming RPC</title>
      <link>http://blog.911015.com/grpc/02.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/grpc/02.html</guid>
      <description>gRPC调用方式 在gRPC中，一共包含四种调用方式。
Unary RPC:一元RPC Server-side streaming RPC: 服务端流式RPC Client-side streaming RPC: 客户端流式RPC Bidirectional streaming RPC: 双向流式RPC Streaming RPC streaming RPC 适用于大数据包场景，可以进行实时交互；
**服务端流式RPC **：客户端发起一次普通的RPC请求，服务端通过流式响应多次发送数据集，客户端Recv接收数据集 客户端流式RPC：客户端发起多次请求给服务端，而服务端仅响应客户端一次 双向流式RPC: 由客户端以流式请求服务端，服务端同样以流式响应客户端。
代码实现 1、proto文件：创建proto文件定义三种流模式服务，执行protoc命令编译代码；
syntax = &amp;#34;proto3&amp;#34;; package pb; option go_package = &amp;#34;pb/;pb&amp;#34;; message Reply { string type = 1; string value = 2; } message Request { string type = 1; string value = 2; } service Streaming { rpc ServerStream (Request) returns (stream Reply); rpc ClientStream (stream Request) returns (Reply); rpc Bidirectional (stream Request) returns (stream Reply); } 2、server： 客户端流模式下 服务端手到 io.</description>
    </item>
    
    <item>
      <title>编程语言这么多怎么选？</title>
      <link>http://blog.911015.com/wx/2023052201.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/wx/2023052201.html</guid>
      <description>Go Go是一种由Google开发的编程语言。其主要特点包括：
静态类型：在编译时检查类型，可以提供更好的代码健壮性。 并发编程：支持Goroutines（轻量级线程）和Channels（通信机制），使并发编程变得简单。 内存管理：Go具有自动垃圾回收机制，可以减少内存泄漏问题。 Go的生态系统正在快速增长，有许多优秀的开源库和框架可供使用。它非常适合云原生应用的开发，如Docker等。较新的Web框架，例如Gin和Echo，也使Go在Web开发中越来越受欢迎。 在性能方面，Go比动态语言更快，但比C++等系统级语言稍慢。 Go的学习曲线较为平稳，对于具有其他编程经验的开发人员来说相对容易上手。
PHP PHP是一种广泛用于Web开发的动态类型语言。其主要特点包括：
动态类型：无需在编写代码时指定变量类型，使代码更加灵活。 便于Web开发：PHP具有许多与Web相关的函数和库，如文件上传、会话管理等。 面向对象编程：支持面向对象编程风格，使代码更加易于维护。 PHP生态系统非常丰富，包括许多流行的Web框架和CMS平台，例如Laravel和WordPress。这些工具可使Web开发更加高效。 在性能方面，PHP比静态语言慢，但可以通过各种缓存技术（如APC和OPcache）提高性能。 PHP学习曲线相对较低，因此非常适合初学者或那些想快速入门Web开发的人选择。
Java Java是一种强类型的跨平台语言，并且具有以下特点：
静态类型：在编译时检查类型，使代码更加健壮。 跨平台：Java字节码可以在任何支持Java的操作系统上运行。 面向对象编程：支持类和对象，使得代码更易于维护。 Java的生态系统非常丰富，涵盖了众多企业应用程序框架，例如Spring和Hibernate。这些框架可帮助开发人员快速构建稳健的企业级应用程序。 在性能方面，Java比动态语言快，但启动时间较长。 相对于其他语言，Java的学习曲线中等。因为它有一个强大的库和框架生态系统，需要一些时间来理解和掌握这些技术。
Python Python是一种动态类型语言，用于各种用途，包括数据分析、机器学习、Web开发等。其主要特点包括：
动态类型：无需在编写代码时指定变量类型，使代码更灵活。 简洁易读：Python具有清晰简单的语法，使得代码易于阅读和编写。 自然语言处理和数据科学：Python具有丰富的库和工具，如NumPy、pandas和scikit-learn等，使得数据科学工作变得更加容易。 Python生态系统非常丰富，包括许多科学计算库和Web框架，例如Django和Flask。Python也是自然语言处理领域的首选语言。 在性能方面，Python比静态语言慢，但对于普通计算任务而言，其代码实现更为容易。另外，Python可以通过JIT编译器（如PyPy）提高性能。 相对于其他语言，Python的学习曲线较浅，适合初学者或那些希望快速入门数据科学或Web开发的人选择。
C++ C++是一种静态类型语言，常用于底层编程和高性能计算任务。其主要特点包括：
静态类型：在编译时检查类型，可以提供更好的代码健壮性。 高性能：C++可以直接操作硬件，因此可以实现非常高效的代码。 底层编程：C++没有自动垃圾回收机制，使得程序员需要手动管理内存，并且可以进行指针操作等底层编程技术。 C++的生态系统虽然不如其他语言那么丰富，但它有许多优秀的基础设施库和跨平台工具，如Boost和Qt等。 在性能方面，C++是最快的语言之一，因为它可以直接操作硬件和内存。 相对于其他语言，C++的学习曲线较陡峭。它需要更多的时间和精力来掌握，因为它具有底层编程技术和复杂的内存管理要求。
语言 语言特性 生态系统 性能 学习难度 Go 静态类型、并发编程、内存管理 快速增长的开源库和框架，适合云原生应用 比动态语言快，但比C++等系统级语言稍慢 中等 PHP 动态类型、便于Web开发、面向对象编程 丰富的Web生态系统，如WordPress 比静态语言慢，但可以通过各种缓存技术提高性能 简单 Java 静态类型、跨平台、面向对象编程 丰富的企业应用生态系统，如Spring、Hibernate等 比动态语言快，但启动时间较长 中等 Python 动态类型、简洁易读、自然语言处理、数据科学 丰富的科学计算生态系统，如NumPy、pandas、scikit-learn等 比静态语言慢，但普通计算任务易于实现 简单 C++ 静态类型、高性能、底层编程 丰富的基础设施生态系统，如Boost 最接近硬件的语言之一，性能最高 困难 总体而言，Go、Java和Python是比较流行的语言，它们都有丰富的生态系统，并且相对于C++来说学习难度较低。其中，Go具有出色的并发编程能力，适合云原生应用开发；Java是企业级开发的首选语言；Python则在数据科学和自然语言处理方面得到广泛应用。PHP则是一种简单易学的Web开发语言，而C++则适合底层编程和高性能计算任务。当然，选择哪种语言取决于具体的需求和项目要求。</description>
    </item>
    
    <item>
      <title>03-创建Go项目</title>
      <link>http://blog.911015.com/beginner/03.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/beginner/03.html</guid>
      <description>这是教程的第一部分，介绍了Go语言的一些基本功能。如果你刚开始使用Go语言，一定要看一下教程：Go入门，它介绍了Go命令、Go模块和非常简单的Go代码。 在本教程中，您将创建两个模块。第一种是用来被其他库或应用导入。第二个模块在程序中调用第一个模块的方法。 本教程包括七个小的部分：
创建一个模块：编写一个小模块，其中包含可以从另一个模块调用的函数。 从另一个模块调用您的代码：导入并使用您的新模块。 返回并处理错误：添加简单的错误处理。 返回一个随机的问候语：处理切片（slices）中的数据（slices：Go的动态大小数组）。 为多个人返回问候语：将键/值对存储在映射（map）中。 添加测试：使用Go内置的单元测试功能来测试代码。 编译并安装应用程序：在本地编译并安装。 前期准备 一些编程经验。这里的代码非常简单，但了解函数、循环和数组会有所帮助。 用于编辑代码的工具。 一种命令终端。Go在Linux和Mac上以及Windows中的PowerShell或cmd上使用任何终端都能很好地工作。 开始创建模块 首先创建Go模块。我们通常会把一些包含同一类功能函数的包放在同一模块中，例如，您可以创建模块，模块的包具有进行财务分析的功能，以便其他编写财务应用程序的人可以使用您的代码。有关开发模块的更多信息，请参阅开发和发布模块.。 Go语言中 代码，包(package)，模块（module）之间的关系是:代码组成包，包组成模块。您开发的模块需要指定运行代码所需的依赖项，包括Go版本及其所需的其他模块。 当您在模块中添加或改进功能时，您将发布模块的新版本。编写调用这个模块的开发人员可以导入新版本模块，并在将其上线之前使用新版本进行测试。
打开命令行，cd到home目录（或其他存放代码的目录） 新建目录 greetings 用来存放Go代码 使用 go mod init 命令初始化一个module 执行 go mod init 命令；本例中我们用 example.com/greetings；如果您发布模块，这必须是Go工具可以下载模块的路径，那就是本模块代码仓库的路径（例如：github.com/example）；
go mod init example.com/greetings # go: creating new go.mod: module example.com/greetings go mod init 命令创建一个go.mod文件来跟踪代码的依赖关系。到目前为止，该文件只包括模块的名称和代码支持的Go版本。但当你添加依赖项时，go.mod文件会列出你的代码所依赖的版本。这可以保持构建的可复制性，并让你直接控制要使用的模块版本。
在编辑器中新建 greetings.go 文件 在greetings.go文件中写入一下代码并保存 package greetings import &amp;#34;fmt&amp;#34; // Hello returns a greeting for the named person. func Hello(name string) string { // Return a greeting that embeds the name in a message.</description>
    </item>
    
    <item>
      <title>3、基础篇（三）：更多类型: struct, slices, 和 map</title>
      <link>http://blog.911015.com/tour/03.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/tour/03.html</guid>
      <description>指针 Go提供了指针类型。指针保存的是一个值的内存地址。 类型*T是指向T值的指针。它的零值为nil。
var p *int &amp;amp;运算符生成指向其操作数的指针。
i := 42 p = &amp;amp;i *运算符表示指针的基本值。
fmt.Println(*p) // read i through the pointer p *p = 21 // set i through the pointer p 与C不同，Go没有指针运算。
package main import &amp;#34;fmt&amp;#34; func main() { i, j := 42, 2701 p := &amp;amp;i // point to i fmt.Println(*p) // read i through the pointer *p = 21 // set i through the pointer fmt.Println(i) // see the new value of i p = &amp;amp;j // point to j *p = *p / 37 // divide j through the pointer fmt.</description>
    </item>
    
    <item>
      <title>go-zero 单体应用实践（三）</title>
      <link>http://blog.911015.com/go-zero/03.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/go-zero/03.html</guid>
      <description>列表数据分页 1、api 定义 Pager api 可以单独一个文件；此时 userlogin.api 需要 import &amp;ldquo;api/pager.api&amp;rdquo;
Pager { Page int `form:&amp;#34;page,default=1&amp;#34;` PageSize int `form:&amp;#34;page_size,default=10&amp;#34;` TotalSize int `form:&amp;#34;total_size,default=0&amp;#34;` } TagListRequest { Name string `form:&amp;#34;name,optional&amp;#34;` Pager } TagListResponse { List []TagResponse `json:&amp;#34;list&amp;#34;` Matedata Pager `json:&amp;#34;matedata&amp;#34;` } service userlogin-api { @handler Tags get /api/tag/list(TagListRequest) returns (TagListResponse) } 2、model 文件：BlogTagModel增加TageList方法；同时 customBlogTagModel.TagList 实现具体逻辑
BlogTagModel interface { blogTagModel TagList(context.Context, *types.TagListRequest) (*types.TagListResponse, error) } func (c *customBlogTagModel) TagList(ctx context.Context, request *types.TagListRequest) (*types.TagListResponse, error) { result := &amp;amp;types.</description>
    </item>
    
    <item>
      <title>Go语言数据结构： Array 和Slice</title>
      <link>http://blog.911015.com/wx/20230523.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/wx/20230523.html</guid>
      <description>Go语言数据结构： Array 和Slice Go 语言中的数组和切片（slice）都是用于存储一系列数据的集合，但它们之间有几个重要的区别。下面是它们的使用方法和区别：
数组 数组是一个有固定大小的数据集合，定义时需要指定其长度。数组的长度是数组类型的一部分，因此不能改变数组的大小。数组可以包含相同类型的数据，这些数据在内存中是连续的。
创建数组 var a [5]int // 定义一个长度为5，元素类型为int的数组 b := [3]string{&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;, &amp;#34;c&amp;#34;} // 定义一个长度为3，元素类型为string的数组，并初始化数组值 访问数组元素 a[0] = 1 // 给第1个元素赋值为1 x := a[2] // 获取第3个元素的值 遍历数组元素 for i, v := range a { fmt.Printf(&amp;#34;a[%d] = %d\n&amp;#34;, i, v) } 切片 切片是一个动态的数组，长度不固定，可以根据实际情况进行扩展。切片本身并不存储任何数据，它只是底层数组的引用，因此对切片的修改会影响到底层数组的内容。
创建切片 var s []int // 定义一个空的整型切片 s := []int{1, 2, 3} // 定义一个有3个元素的整型切片，并初始化数组值 访问切片元素 x := s[2] // 获取第3个元素的值 遍历切片元素 for i, v := range s { fmt.</description>
    </item>
    
    <item>
      <title>三、拦截器与Metadata</title>
      <link>http://blog.911015.com/grpc/03.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/grpc/03.html</guid>
      <description>拦截器 根据RPC调用类型可以将gRPC拦截器分为两种：
一元拦 截器(Unary Interceptor) :拦截和处理一元RPC调用。 流拦截器(Stream Interceptor) :拦截和处理流式RPC调用。 1、服务端拦截器 服务端一元拦截器类型为 grpc.UnaryServerInterceptor；流拦截器类型为 StreamServerInterceptor; 下面实现一个服务端一元拦截器：在调用服务前后各打印一条日志
func HelloInterceptor() grpc.UnaryServerInterceptor { return func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) { log.Println(&amp;#34;Hello&amp;#34;) resp, err = handler(ctx, req) log.Println(&amp;#34;Bye bye&amp;#34;) return } } 在服务端代码中配置拦截器；
opts := []grpc.ServerOption{ grpc.UnaryInterceptor(interceptors.HelloInterceptor()), } server := grpc.NewServer(opts...) 2、使用多个拦截器 gRPC 默认只支持设置单个拦截器，设置过个拦截器会painc
panic: The unary server interceptor was already set and may not be reset.
设置多个拦截器可以使用 grpc-ecosystem/go-grpc-middleware</description>
    </item>
    
    <item>
      <title> Go 语言数据结构：Maps</title>
      <link>http://blog.911015.com/wx/20230524.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/wx/20230524.html</guid>
      <description>Golang中的Map是一种集合类型，它用于将一个键值对映射到另一个键值对。这些键值对可以是任何可比较的类型，包括内置类型和用户定义的类型，而且每个键只能在Map中出现一次。 具体来说，Map是由一组键值对组成的无序集合。每个键必须是唯一的，而不同的键可以关联到相同的值。Map通常用于需要快速查找特定键以获取相应值的场景，例如字典或计数器。
Map 基本用法 以下是使用Map的一些基本用法：
创建Map：使用make函数创建一个Map对象，同时指定键和值的类型。 myMap := make(map[string]int) 添加元素：通过键值对的方式添加元素到Map中。 myMap[&amp;#34;apple&amp;#34;] = 10 myMap[&amp;#34;orange&amp;#34;] = 5 访问元素：通过键访问Map中的元素值。 fmt.Println(myMap[&amp;#34;apple&amp;#34;]) // Output: 10 更新元素：通过键更新Map中的元素值。 myMap[&amp;#34;apple&amp;#34;] = 15 删除元素：通过键删除Map中的元素。 delete(myMap, &amp;#34;orange&amp;#34;) 遍历Map：使用for range语句遍历Map中的所有键值对,遍历是顺序是不确定的。 for key, value := range myMap { fmt.Println(key, value) } 应用场景 计数器：使用Map可以轻松实现计数器功能。例如，如果需要统计一个字符串中每个字符出现的次数，可以使用一个Map来保存每个字符及其出现次数。 str := &amp;#34;abracadabra&amp;#34; counts := make(map[rune]int) for _, c := range str { counts[c]++ } fmt.Println(counts) // Output: map[a:5 b:2 r:2 c:1 d:1] 缓存：Map也可以用作缓存，以加快应用程序的性能。例如，在Web应用程序中，可以将从数据库中检索到的数据存储在Map中，以避免重复查询相同的数据。 type User struct { ID int Name string } var cache = make(map[int]User) func getUserByID(id int) (User, error) { user, ok := cache[id] if !</description>
    </item>
    
    <item>
      <title> Go 语言数据结构：结构体</title>
      <link>http://blog.911015.com/wx/20230525.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/wx/20230525.html</guid>
      <description>指针 Go提供了指针类型。指针保存的是一个值的内存地址。但是Go没有指针运算。 类型*T是指向T值的指针。它的零值为nil。
var p *int *&amp;amp; 运算符生成指向其操作数的指针。 **运算符表示指针的基本值。
i := 42 p = &amp;amp;i fmt.Println(*p) // read i through the pointer p *p = 21 // set i through the pointer p 结构体（Structs） Go语言中，结构体是一种用户自定义的数据类型，用于存储不同数据类型的集合 。 使用点(.)访问结构字段。 在结构体中，字段首字母的大小写决定了该字段的可见性。 定义结构体 一个结构体包含0到N个字段（Field），每个字段由字段名和类型构成；定义一个结构体的一般方式如下，
type T struct { field1 type1 field2 type2 ... } 如果个字段类型相同也可以简写成 :
type T struct {X,Y int} 创建结构体 假设我们已经定义了这样一个结构体：
type Vertex struct { X int Y int } 如何使用这个结构体呢？创建一个结构体变量常用的方法有：
定义结构体类型变量 var v1 Vertex v1.</description>
    </item>
    
    <item>
      <title>04-入门多模块工作区</title>
      <link>http://blog.911015.com/beginner/04.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/beginner/04.html</guid>
      <description>本教程介绍了 Go 中多模块工作区的基础知识。使用多模块工作区，您可以告诉 Go 命令您正在同时在多个模块中编写代码，并轻松地在这些模块中构建和运行代码。 在本教程中，您将在共享的多模块工作区中创建两个模块，对这些模块进行更改，并在构建中查看这些更改的结果。
前期准备 安装 Go 1.18 或更高版本。 一个编辑代码的工具。 一个命令终端。 本教程需要** go1.18** 或更高版本。使用go.dev/dl中的链接确保您已在 Go 1.18 或更高版本中安装了 Go 。
创建一个模块 首先，为您要编写的代码创建一个模块。 一、打开命令提示符并切换到您的主目录。
# Linux 或 Mac： $ cd # Windows： C:\&amp;gt; cd %HOMEPATH% 本教程的其余部分将显示 $ 作为提示符。您使用的命令也适用于 Windows。
二、在命令提示符下，创建workspace目录。
$ mkdir workspace $ cd workspace 三、初始化模块
本示例将创建一个依赖 golang.org/x/example 模块的hello 模块。
1、创建 hello 模块：
$ mkdir hello $ cd hello $ go mod init example.com/hello go: creating new go.mod: module example.</description>
    </item>
    
    <item>
      <title>4、方法与接口</title>
      <link>http://blog.911015.com/tour/04.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/tour/04.html</guid>
      <description>Methods Go没有类。但是，您可以在类型上定义方法。 方法是一个具有特殊接收器参数的函数。 接收器出现在自己的参数列表中，位于func关键字和方法名称之间。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math&amp;#34; ) type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.Println(v.Abs()) } 在这个例子中，Abs方法有一个名为v的Vertex类型的接收器。 请记住：方法只是一个带有接收器参数的函数。下面的Abs是作为一个普通函数编写的，函数本身没有变化。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math&amp;#34; ) type Vertex struct { X, Y float64 } func Abs(v Vertex) float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.</description>
    </item>
    
    <item>
      <title>go-zero 微服务应用实践（一）</title>
      <link>http://blog.911015.com/go-zero/04.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/go-zero/04.html</guid>
      <description>简介 go-zero 是一个集成了各种工程实践的 web 和 rpc 框架。通过弹性设计保障了大并发服务端的稳定性，经受了充分的实战检验。
本节将用go-zero 开发一个用户服务；主要包括注册、登录、用户信息查询功能
初始化项目 //创建目录 madir project &amp;amp;&amp;amp; cd project //初始化项目 go mod init project 用户服务 0、环境准备 protoc &amp;amp; protoc-gen-go安装
protoc是一款用C++编写的工具，其可以将proto文件翻译为指定语言的代码。在go-zero的微服务中，我们采用grpc进行服务间的通信，而grpc的编写就需要用到protoc和翻译成go语言rpc stub代码的插件protoc-gen-go。
1、创建proto 文件 user/rpc/user.proto
syntax = &amp;#34;proto3&amp;#34;; package user; option go_package = &amp;#34;./user&amp;#34;; message RegisterRequest { string Name = 1; int64 Gender = 2; string Email = 3; string Password = 4; } message RegisterResponse { int64 Id = 1; string Name = 2; int64 Gender = 3; string Email = 4; } message LoginRequest { string Email = 1; string Password = 2; } message LoginResponse { int64 Id = 1; string Name = 2; int64 Gender = 3; string Email = 4; } message UserInfoRequest { int64 Id = 1; } message UserInfoResponse { int64 Id = 1; string Name = 2; int64 Gender = 3; string Email = 4; } service User { rpc Register(RegisterRequest) returns(RegisterResponse); rpc Login(LoginRequest) returns(LoginResponse); rpc UserInfo(UserInfoRequest) returns(UserInfoResponse); } 2、创建 user/generate.</description>
    </item>
    
    <item>
      <title>四、服务注册与发现</title>
      <link>http://blog.911015.com/grpc/04.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/grpc/04.html</guid>
      <description>环境依赖 安装并且启动etcd 按照etcd SDK go get go.etcd.io/etcd/client/v3@v3.5.4 go get google.golang.org/grpc@v1.48.0
旧版本grpc与etcd可能存在不兼容问题，建议使用最新兼容版本
服务注册与发现 实现思路：服务端启动服务时将自己的服务信息如IP、端口、版本等信息注册到注册中心（此处为ETCD），客户端在进行服务调用时会以约定好的服务名到注册中心查询，发现具体可以调用的服务。 服务端实现：
func init() { flag.StringVar(&amp;amp;port, &amp;#34;p&amp;#34;, &amp;#34;8000&amp;#34;, &amp;#34;启动端口号&amp;#34;) flag.Parse() } func main() { server := grpc.NewServer() discover.RegisterDiscoverDemoServer(server, &amp;amp;DiscoverDemo{}) reflection.Register(server) taget := fmt.Sprintf(&amp;#34;grpc-demo/grpc/%s&amp;#34;, types.SERVER_NAME) client, err := etcd3.New(etcd3.Config{ Endpoints: []string{&amp;#34;http://127.0.0.1:2379&amp;#34;}, }) if err != nil { panic(err) } addr := &amp;#34;127.0.0.1:&amp;#34;+port err = register.EtcdAdd(client, taget,addr) if err != nil { return } lis, _ := net.Listen(&amp;#34;tcp&amp;#34;, addr) server.Serve(lis) } register.</description>
    </item>
    
    <item>
      <title> Go 语言入门：方法</title>
      <link>http://blog.911015.com/wx/20230526.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/wx/20230526.html</guid>
      <description>方法 Methods Go没有类。但是，您可以在类型上定义方法。 方法是一个具有特殊接收器参数的函数。 接收器出现在自己的参数列表中，位于func关键字和方法名称之间。语法如下
func (t 类型) 方法名(参数名 参数类型 ...) [返回值类型]{ } 一下代码为官网示例；定义了一个 Vertex 类列；包含X Y 两个字段；定义了一个Abs 方法；计算坐标点到原点的距离。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math&amp;#34; ) type Vertex struct { X, Y float64 } func (v Vertex) Abs() float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.Println(v.Abs()) } 在这个例子中，Abs方法有一个名为v的Vertex类型的接收器。 请记住：方法只是一个带有接收器参数的函数。下面的Abs是作为一个普通函数编写的，函数本身没有变化。
func Abs(v Vertex) float64 { return math.Sqrt(v.X*v.X + v.Y*v.Y) } func main() { v := Vertex{3, 4} fmt.</description>
    </item>
    
    <item>
      <title>5、泛型</title>
      <link>http://blog.911015.com/tour/05.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/tour/05.html</guid>
      <description>Go支持使用类型参数进行泛型编程。本课展示了在代码中使用泛型的一些示例。
类型参数 Go函数可以使用类型参数让函数支持多个类型。函数的类型参数用中括号包裹，位于函数的参数之前。
func Index[T comparable](s []T, x T) int 这个声明意味着s是任何类型T的一个切片，它满足comparable内置约束。x也是相同类型的值。 compatible是一个有用的约束，可以使用==和！=类型值上的运算符。在本例中，我们使用它将一个值与所有切片元素进行比较，直到找到匹配。此Index函数适用于任何支持比较的类型。
package main import &amp;#34;fmt&amp;#34; // Index returns the index of x in s, or -1 if not found. func Index[T comparable](s []T, x T) int { for i, v := range s { // v and x are type T, which has the comparable // constraint, so we can use == here. if v == x { return i } } return -1 } func main() { // Index works on a slice of ints si := []int{10, 20, 15, -10} fmt.</description>
    </item>
    
    <item>
      <title>go-zero 微服务应用实践（二）</title>
      <link>http://blog.911015.com/go-zero/05.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/go-zero/05.html</guid>
      <description>服务调用 完成rpc访问功能后，还需要进行客户端调用，会用到goctl 的api功能；创建api目录编写api文件；api相关语法可以参考官方文档：api语法介绍
1、API文件编写 其中 登录注册增加了参数验证，使用 validator 包进行验证详细使用方法可以到 github.com/go-playground/validator 查看
syntax = &amp;#34;v1&amp;#34; type ( LoginRequest { Email string `json:&amp;#34;Email&amp;#34; validate:&amp;#34;required,email&amp;#34;` Password string `json:&amp;#34;password&amp;#34; validate:&amp;#34;required,gte=8&amp;#34;` } LoginResponse { AccessToken string `json:&amp;#34;accessToken&amp;#34;` AccessExpire int64 `json:&amp;#34;accessExpire&amp;#34;` } RegisterRequest { Name string `json:&amp;#34;name&amp;#34; validate:&amp;#34;required,gte=2,lte=20&amp;#34;` Gender int64 `json:&amp;#34;gender&amp;#34; validate:&amp;#34;oneof=1 2&amp;#34;` Email string `json:&amp;#34;Email&amp;#34; validate:&amp;#34;required,email&amp;#34;` Password string `json:&amp;#34;password&amp;#34; validate:&amp;#34;required,gte=8&amp;#34;` } RegisterResponse { Id int64 `json:&amp;#34;id&amp;#34;` Name string `json:&amp;#34;name&amp;#34;` Gender int64 `json:&amp;#34;gender&amp;#34;` Email string `json:&amp;#34;Email&amp;#34;` } UserInfoRequest { } UserInfoResponse { Id int64 `json:&amp;#34;id&amp;#34;` Name string `json:&amp;#34;name&amp;#34;` Gender int64 `json:&amp;#34;gender&amp;#34;` Email string `json:&amp;#34;Email&amp;#34;` } ) service User { @handler Login post /api/user/login(LoginRequest) returns (LoginResponse) @handler Register post /api/user/register(RegisterRequest) returns (RegisterResponse) } @server( jwt: Auth ) service User { @handler UserInfo post /api/user/userinfo(UserInfoRequest) returns (UserInfoResponse) } 2、执行goctl命令 goctl api go -api .</description>
    </item>
    
    <item>
      <title>五、gRPC-Gateway</title>
      <link>http://blog.911015.com/grpc/05.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/grpc/05.html</guid>
      <description>简介 gRPC-Gateway是protoc的一个插件。它读取gRPC服务定义并生成反向代理服务器，该服务器将RESTful JSON API转换为gRPC。此服务器根据gRPC定义中的自定义选项生成。
grpc-gateway文档 安装依赖 go get github.com/grpc-ecosystem/grpc-gateway/v2/protoc-gen-grpc-gateway
proto 文件 gateway/pb/gateway.proto 文件；其中 需要 import google/api/annotations.proto；可以将 github.com\grpc-ecosystem\grpc-gateway 下的 third_party\googleapis\google\api 文件拷贝到项目目录下；执行protoc命令
protoc -I=./gateway/pb/ -I=./third_party/ &amp;ndash;go_out=./gateway/ &amp;ndash;go-grpc_out=./gateway/ -grpc-gateway_out=./gateway/ ./gateway/pb/gateway.proto
syntax = &amp;#34;proto3&amp;#34;; package stream; option go_package = &amp;#34;pb/;gateway&amp;#34;; import &amp;#34;google/api/annotations.proto&amp;#34;; message Request { string name = 1; } message Reply { string content = 1; } service GatewayDemo { rpc Gate(Request) returns (Reply) { option (google.api.http) = { get: &amp;#34;/v1/gate/{name}&amp;#34; }; } } Server端 server端与正常gRPC服务没什么差别；</description>
    </item>
    
    <item>
      <title> Go 语言中的接口：Interface</title>
      <link>http://blog.911015.com/wx/20230527.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/wx/20230527.html</guid>
      <description>Interfaces 接口类型被定义为一组方法签名。 接口类型的值可以包含实现这些方法的任何值。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math&amp;#34; ) type Abser interface { Abs() float64 } func main() { var a Abser f := MyFloat(-math.Sqrt2) v := Vertex{3, 4} a = f // a MyFloat implements Abser a = &amp;amp;v // a *Vertex implements Abser // In the following line, v is a Vertex (not *Vertex) // and does NOT implement Abser. a = v fmt.Println(a.Abs()) } type MyFloat float64 func (f MyFloat) Abs() float64 { if f &amp;lt; 0 { return float64(-f) } return float64(f) } type Vertex struct { X, Y float64 } func (v *Vertex) Abs() float64 { return math.</description>
    </item>
    
    <item>
      <title>6、并发</title>
      <link>http://blog.911015.com/tour/06.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/tour/06.html</guid>
      <description>Go提供的并发功能是核心语言的一部分。
Goroutines goroutine是一个由Go运行时管理的轻量级线程。
go f(x, y, z) 开始运行新的goroutine f(x, y, z) f、x、y和z的求值发生在当前goroutine中，f的执行发生在新goroutine。 Goroutines在相同的地址空间中运行，因此对共享内存的访问必须同步。sync包提供了有用的并发原语，尽管Go中并不需要它们，因为还有其他基元。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func say(s string) { for i := 0; i &amp;lt; 5; i++ { time.Sleep(100 * time.Millisecond) fmt.Println(s) } } func main() { go say(&amp;#34;world&amp;#34;) say(&amp;#34;hello&amp;#34;) } Channels Channel是一种类型化的管道，通过它可以使用通道操作符&amp;lt;-发送和接收值。
ch &amp;lt;- v // Send v to channel ch. v := &amp;lt;-ch // Receive from ch, and // assign value to v. 数据沿箭头方向流动。 与map和slice一样， channel必须在使用前初始化：</description>
    </item>
    
    <item>
      <title>六、证书验证</title>
      <link>http://blog.911015.com/grpc/06.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/grpc/06.html</guid>
      <description>还记得前面章节中gRPC的服务中客户端在链接服务器中通过 grpc.WithInsecure() 选项跳过了对服务器证书的验证吗？为了保障gRPC通信不被第三方监听篡改或伪造，我们试一下对服务器启动TLS加密特性。
一、生成证书 通过一个安全可靠的根证书分别对服务器和客户端的证书进行签名。这样客户端或服务器在收到对方的证书后可以通过根证书进行验证证书的有效性。
1、CA证书 创建 ca.conf
[ req ] default_bits = 4096 distinguished_name = req_distinguished_name [ req_distinguished_name ] countryName = Country Name (2 letter code) countryName_default = CN stateOrProvinceName = State or Province Name (full name) stateOrProvinceName_default = Beiging localityName = Locality Name (eg, city) localityName_default = Beijing organizationName = Organization Name (eg, company) organizationName_default = company commonName = Common Name (e.g. server FQDN or YOUR name) commonName_max = 64 commonName_default = Ted CA Test 生成ca根证书</description>
    </item>
    
    <item>
      <title>与我联系</title>
      <link>http://blog.911015.com/contact.html</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://blog.911015.com/contact.html</guid>
      <description>Email：create98715@duck.comQQ：3336449889关注公众号领取Go学习资料
关注公众号领取Go学习资料</description>
    </item>
    
  </channel>
</rss>
